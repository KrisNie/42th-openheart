<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS on 42th openheart</title>
    <link>https://www.openheart.icu/tags/cs/</link>
    <description>Recent content in CS on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Thu, 12 Aug 2021 15:15:57 +0000</lastBuildDate><atom:link href="https://www.openheart.icu/tags/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Working Effectively with Legacy Code</title>
      <link>https://www.openheart.icu/cs/working-effectively-with-legacy-code/</link>
      <pubDate>Thu, 12 Aug 2021 15:15:57 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/working-effectively-with-legacy-code/</guid>
      <description>The Mechanics of Change Changing Software Four Reasons to Change Software  Adding a feature Fixing a bug Improving the design Optimizing resource usage  Changing Software Dependency-Breaking Techniques </description>
    </item>
    
    <item>
      <title>CS Conferences</title>
      <link>https://www.openheart.icu/cs/cs-conferences/</link>
      <pubDate>Mon, 09 Aug 2021 13:43:10 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/cs-conferences/</guid>
      <description>List of computer science conferences </description>
    </item>
    
    <item>
      <title>Design Patterns</title>
      <link>https://www.openheart.icu/cs/design-patterns/</link>
      <pubDate>Mon, 02 Aug 2021 15:57:23 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/design-patterns/</guid>
      <description>Structural Design Patterns Creational Design Patterns Behavioral Design Patterns Observer  The observer design pattern is suitable for distributed push-based notifications, because it supports a clean separation between two different components or application layers, such as a data source (business logic) layer and a user interface (display) layer. The pattern can be implemented whenever a provider uses callbacks to supply its clients with current information.
Implementing the pattern requires that you provide the following:</description>
    </item>
    
    <item>
      <title>Adaptive Code</title>
      <link>https://www.openheart.icu/cs/adaptive-code/</link>
      <pubDate>Sat, 21 Nov 2020 22:30:12 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/adaptive-code/</guid>
      <description>Adaptive Code: Agile coding with design patterns and SOLID principles 从标题中就不难发现，Adaptive Code的重点有三个：
  敏捷编码
  设计模式
  SOLID(单一功能、开闭原则、里氏替换、接口隔离以及依赖反转)原则
  Scrum scrum.org 2020-Scrum-Guide-US
 Scrum is:
 Lightweight Simple to understand Difficult to master   What  All work is prioritized on the product backlog and, at the start of each sprint, the development team commits to the work that they will complete during the new iteration by placing it on the sprint backlog.</description>
    </item>
    
    <item>
      <title>Unit Test Practice</title>
      <link>https://www.openheart.icu/cs/unit-test-practice/</link>
      <pubDate>Sat, 21 Nov 2020 22:30:12 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/unit-test-practice/</guid>
      <description>Unit Test Practice  纸上得来终觉浅，绝知此事要躬行。
 Shifting Left 所谓左移，左倾，不是指冒险主义。是将整个流程中右边部分向左边移动，比如测试。 : )
 Shift Left is a practice intended to find and prevent defects early in the software delivery process. The idea is to improve quality by moving tasks to the left as early in the lifecycle as possible.
In the traditional software development model, requirements are kept on the left side of the plan, and the delivery and testing requirements on the right.</description>
    </item>
    
    <item>
      <title>Dependency Injection</title>
      <link>https://www.openheart.icu/cs/dependency-injection/</link>
      <pubDate>Thu, 15 Oct 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/dependency-injection/</guid>
      <description>Dependency Injection IOC Spring 框架为Java提供了IOC（Inversion of Control），只是提供了一个服务容器，程序控制我们需要的对象，而不是在使用对象时我们亲自直接控制。既然提到了IOC就详细了解一下这种设计思想：
为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”。
控制反转是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。
软件系统在没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。
控制反转可以用来减低计算机代码之间的耦合度。 其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。
DIP 要了解控制反转( Inversion of Control ), 我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）。
依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。 简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。
在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。
该原则规定：
 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。  该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。控制反转就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）。
设计模式中的五大原则 SOLID 中的 D 指代的就是依赖反转原则。
eg: Lamp and Button：A Simple DIP Example
DI IOC与DI的区别  控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。 依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。 通过IOC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。  .net core 框架自带IServiceProvider以实现依赖注入</description>
    </item>
    
    <item>
      <title>Static Search Table &amp; Dynamic Search Table</title>
      <link>https://www.openheart.icu/cs/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8%E4%B8%8E%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/</link>
      <pubDate>Sat, 25 Jul 2020 18:32:23 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8%E4%B8%8E%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8/</guid>
      <description>今天在看BST时，指导书上讲二叉排序树时与二分查找进行对比，引出几个模棱两可的概念（静态查找表、动态查找表），经查找后整理得本文
概述 首先要了解几个基础概念
查找(Searching) 是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。
查找表(Search Table) 是由同⼀类型的数据元素(记录)构成的集合。
关键字(Key) 是数据元素中某个数据项的值，又称为键值，用它可以表示⼀个数据元素，也可以标识一个记录的某个数据项(字段)，我们称为关键码。 若关键字可以唯⼀地标识一个记录, 则称此关键字为主关键字 (Primary Key)。 对于那些可以识别多个属于元素(记录)的关键字，我们称为次关键字(Secondary Key)。
查找表操作可分为静态查找和动态查找。
静态查找表(Static Search Table) 只作查找操作的查找表。
 查询某个”特定的”数据元素是否在查找表中; 检索某个&amp;quot;特定的&amp;quot;数据元素和各种属性;  静态查找只是仅查找，并不会去改变集合内的数据元素。常用的查找有。
顺序查找（ Linear search，又称线性查找）  原理 ：顺序查找就是按顺序从头到尾依次往下查找，从表中的第一个(或最后一个)记录开始，逐个进行记录关键字和给定值比较，找到数据，则提前结束查找，找不到便一直查找下去，直到数据最后一位
 public static int linearSearch(int[] a, int num) { for(int i = 0; i &amp;lt; a.length; i++) { if(a[i] == num){ // 返回数据所在的下标，也就是位置  return i; } } // 不存在的话返回-1  return -1; } 索引顺序表查找（分块查找） 整个表中的元素未必有序，但若划分为若干块后，每一块中的所有元素均小于（或大于）其后面块中的所有元素。我们称这种为分块有序。
分块查找要求把一个数据分为若干块，每一块里面的元素可以是无序的，但是块与块之间的元素需要是有序的。（对于一个非递减的数列来说，第i块中的每个元素一定比第i-1块中的任意元素大）
 原理：</description>
    </item>
    
    <item>
      <title>Computer network</title>
      <link>https://www.openheart.icu/cs/computer-network/</link>
      <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/cs/computer-network/</guid>
      <description>Computer Network Issues 网络的七层架构  物理层 数据链路层 网络层 传输层 会话层 表示层 应用层  TCP/IP 原理 TCP 三次握手/四次挥手 三次握手 TCP 在传输之前会进行三次沟通，一般称为“三次握手”。
四次挥手 TCP在传输完数据断开的时候要进行四次沟通，一般称为“四次挥手”。
Private IP Address vs Public IP Address &amp;amp; Public IP Port  0-1023是公认端口号，即已经公认定义或为将要公认定义的软件保留的，而1024-65535是并没有公共定义的端口号，用户可以自己定义这些端口的作用。
 Reference  常用端口号 为什么ipconfig和浏览器查询出的ip不一样？  </description>
    </item>
    
  </channel>
</rss>
