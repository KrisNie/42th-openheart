<!DOCTYPE html>
<html><head>
<title>Schema Security</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="架构安全性">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<link rel="shortcut icon" href="/images/smile_favicon.ico" type="image/x-icon" />
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css">



<meta property="og:title" content="Schema Security" />
<meta property="og:description" content="架构安全性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.openheart.icu/computing-science/schema-security/" />
<meta property="article:published_time" content="2022-07-19T17:28:00+00:00" />
<meta property="article:modified_time" content="2022-07-19T17:28:00+00:00" /><meta property="og:site_name" content="My Blog" />





<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Schema Security"/>
<meta name="twitter:description" content="架构安全性"/>







<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">


  






<link rel="stylesheet" href="https://www.openheart.icu/scss/journal.min.501d7307b277cc4885da27e54d8eb3a01eb04a3eb1539d4db0f640bad47a803c.css" integrity="sha256-UB1zB7J3zEiF2iflTY6zoB6wSj6xU51NsPZAutR6gDw=" media="screen">



<link rel="stylesheet" href="https://www.openheart.icu/scss/dark-mode.min.7757e4001197b1cd1c03bf75eeef947c882e0bbc26b5096a3c1a66992f55521a.css" integrity="sha256-d1fkABGXsc0cA7917u&#43;UfIguC7wmtQlqPBpmmS9VUho=" media="screen">


<script src="/vendor/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons");
</script>






  <script src="/js/toc.js"></script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/vendor/js/md5.min.js"></script>
<script>
  var gitalk = new Gitalk({
  clientID: '78028e4d522031d4773c',
  clientSecret: 'e387ce8646bde4df55f81e9dc6c1e72b91248d82',
  repo: '42th-openheart',
  owner: 'KrisNie',
  admin: ['KrisNie'],
  id: md5(location.pathname),
  distractionFreeMode: 'false'
  });
  window.onload = function () {
        gitalk.render('gitalk-container')
  }
</script>












</head>
<body>
    	<div id="app"><div id="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://www.openheart.icu/">
    
        <div class="nav-title">
            42th openheart
        </div>
        
        <div class="nav-subtitle">
            Kris Nie&#39;s Blog.
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/arithmetic">
                Arithmetic
            </a>
            
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/computing-science">
                Computing Science
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/microsoft-dotnet">
                Microsoft DotNet
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/business">
                Business
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/speech">
                Speech
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/about">
                About
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        


<i class="fa fa-weixin" aria-hidden="true"></i>
QuadragintaDuo
<br>
<i class="fa fa-envelope" aria-hidden="true"></i>
krisnie42@qq.com
<br>
<span id="busuanzi_container_site_pv">
    site pv:<span id="busuanzi_value_site_pv"></span>
</span>
| 
<span id="busuanzi_container_site_uv">
	site uv:<span id="busuanzi_value_site_uv"></span>
</span>
<br>
<a href="https://beian.miit.gov.cn/">鲁ICP备20007116号-1</a>
<br>
Powered by Hugo | Theme - <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a>

<br>


&copy;
	
	2022 ALL RIGHTS RESERVED KRIS NIE
	


    </div>
    
</div><div id="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#authentication" onclick="onNavClick(`#authentication-nav`)" id="authentication-nav">
									Authentication
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#authentication-standards" onclick="onNavClick(`#authentication-standards-nav`)" id="authentication-standards-nav">
									Authentication standards
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#http-authentication" onclick="onNavClick(`#http-authentication-nav`)" id="http-authentication-nav">
									HTTP Authentication
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#web-authentication" onclick="onNavClick(`#web-authentication-nav`)" id="web-authentication-nav">
									Web Authentication
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#implementation-of-the-authentication" onclick="onNavClick(`#implementation-of-the-authentication-nav`)" id="implementation-of-the-authentication-nav">
									Implementation of the Authentication
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#authorization" onclick="onNavClick(`#authorization-nav`)" id="authorization-nav">
									Authorization
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#rbac" onclick="onNavClick(`#rbac-nav`)" id="rbac-nav">
									RBAC
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#oauth2" onclick="onNavClick(`#oauth2-nav`)" id="oauth2-nav">
									OAuth2
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e6%8e%88%e6%9d%83%e7%a0%81%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#授权码模式-nav`)" id="授权码模式-nav">
									授权码模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e9%9a%90%e5%bc%8f%e6%8e%88%e6%9d%83%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#隐式授权模式-nav`)" id="隐式授权模式-nav">
									隐式授权模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%af%86%e7%a0%81%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#密码模式-nav`)" id="密码模式-nav">
									密码模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#客户端模式-nav`)" id="客户端模式-nav">
									客户端模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#credential" onclick="onNavClick(`#credential-nav`)" id="credential-nav">
									Credential
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#cookie-session" onclick="onNavClick(`#cookie-session-nav`)" id="cookie-session-nav">
									Cookie-Session
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#jwt" onclick="onNavClick(`#jwt-nav`)" id="jwt-nav">
									JWT
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#confidentiality" onclick="onNavClick(`#confidentiality-nav`)" id="confidentiality-nav">
									Confidentiality
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#transport-security" onclick="onNavClick(`#transport-security-nav`)" id="transport-security-nav">
									Transport Security
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#verification" onclick="onNavClick(`#verification-nav`)" id="verification-nav">
									Verification
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#reference" onclick="onNavClick(`#reference-nav`)" id="reference-nav">
									Reference
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a type="button" class="pagination-action" id="darkModeToggleButton">
            <span class="material-icons pagination-action-icon" id="darkModeToggleIcon">
                dark_mode
            </span>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" id="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/arithmetic">
                    Arithmetic
                </a>
                
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/computing-science">
                    Computing Science
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/microsoft-dotnet">
                    Microsoft DotNet
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/business">
                    Business
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/speech">
                    Speech
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/about">
                    About
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#authentication" onclick="onNavClick(`#authentication-nav`)" id="authentication-nav">
									Authentication
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#authentication-standards" onclick="onNavClick(`#authentication-standards-nav`)" id="authentication-standards-nav">
									Authentication standards
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#http-authentication" onclick="onNavClick(`#http-authentication-nav`)" id="http-authentication-nav">
									HTTP Authentication
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#web-authentication" onclick="onNavClick(`#web-authentication-nav`)" id="web-authentication-nav">
									Web Authentication
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#implementation-of-the-authentication" onclick="onNavClick(`#implementation-of-the-authentication-nav`)" id="implementation-of-the-authentication-nav">
									Implementation of the Authentication
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#authorization" onclick="onNavClick(`#authorization-nav`)" id="authorization-nav">
									Authorization
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#rbac" onclick="onNavClick(`#rbac-nav`)" id="rbac-nav">
									RBAC
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#oauth2" onclick="onNavClick(`#oauth2-nav`)" id="oauth2-nav">
									OAuth2
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e6%8e%88%e6%9d%83%e7%a0%81%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#授权码模式-nav`)" id="授权码模式-nav">
									授权码模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e9%9a%90%e5%bc%8f%e6%8e%88%e6%9d%83%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#隐式授权模式-nav`)" id="隐式授权模式-nav">
									隐式授权模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%af%86%e7%a0%81%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#密码模式-nav`)" id="密码模式-nav">
									密码模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#%e5%ae%a2%e6%88%b7%e7%ab%af%e6%a8%a1%e5%bc%8f" onclick="onNavClick(`#客户端模式-nav`)" id="客户端模式-nav">
									客户端模式
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#credential" onclick="onNavClick(`#credential-nav`)" id="credential-nav">
									Credential
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#cookie-session" onclick="onNavClick(`#cookie-session-nav`)" id="cookie-session-nav">
									Cookie-Session
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#jwt" onclick="onNavClick(`#jwt-nav`)" id="jwt-nav">
									JWT
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#confidentiality" onclick="onNavClick(`#confidentiality-nav`)" id="confidentiality-nav">
									Confidentiality
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#transport-security" onclick="onNavClick(`#transport-security-nav`)" id="transport-security-nav">
									Transport Security
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#verification" onclick="onNavClick(`#verification-nav`)" id="verification-nav">
									Verification
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#reference" onclick="onNavClick(`#reference-nav`)" id="reference-nav">
									Reference
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div id="drawer-mask" v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav id="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div id="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a id="navTitle" class="navbar-brand" href="https://www.openheart.icu/">
            42th openheart
        </a>
        
        <button type="button" class="nav-darkmode-toggle" id="darkModeToggleButton2">
            <i class="material-icons" id="darkModeToggleIcon2">
                dark_mode
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" id="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://www.openheart.icu/">
        <div class="single-column-header-title">42th openheart</div>
        
        <div class="single-column-header-subtitle">Kris Nie&#39;s Blog.</div>
        

    </a>
</div>

            <div id="content">
                <div id="streamContainer" class="stream-container">

    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                
            >
                <div class="post-title">
                    Schema Security
                    
                    <div class="post-subtitle">
                        架构安全性
                    </div>
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2022-07-19 17:28
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/technical">Technical</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/cs">CS</a>
                                &nbsp;
                            
                        
                        
                            <i class="material-icons" style="">schedule</i>
                            

                            
                            

                            
                            59 min
                            
                            50 s.
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <h1 id="authentication">Authentication</h1>
<p>系统如何正确分辨出操作用户的真实身份？</p>
<p>认证并不是仅仅是校验一下用户名、密码是否正确这么简单。</p>
<p>账户和权限信息作为一种必须最大限度保障安全和隐私，同时又要兼顾各个系统模块甚至系统间共享访问的基础主数据，它的存储、管理与使用都面临一系列复杂的问题。对于某些大规模的信息系统，账户和权限的管理往往要由专门的基础设施来负责，譬如微软的<a href="https://en.wikipedia.org/wiki/Active_Directory">活动目录</a>（Active Directory，AD）或者<a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">轻量目录访问协议</a>（Lightweight Directory Access Protocol，LDAP），跨系统的共享使用甚至会用到区块链技术。</p>
<h2 id="authentication-standards">Authentication standards</h2>
<p>基于 HTML 和 JavaScript 的超文本 Web 应用（B/S 系统）对最终用户认证的需求使得“安全认证”的重点逐渐从“代码级安全”转为“用户级安全”，即你是否信任正在操作的用户。</p>
<p>认证需要覆盖通信信道、协议和内容三个层面，而这三种层面认证恰好涵盖了主流的三种认证方式，具体含义和应用场景列举如下。</p>
<ul>
<li><strong>通信信道上的认证</strong>：你和我建立通信连接之前，要先证明你是谁。在网络传输（Network）场景中的典型是基于 SSL/TLS 传输安全层的认证。</li>
<li><strong>通信协议上的认证</strong>：你请求获取我的资源之前，要先证明你是谁。在互联网（Internet）场景中的典型是基于 HTTP 协议的认证。</li>
<li><strong>通信内容上的认证</strong>：你使用我提供的服务之前，要先证明你是谁。在万维网（World Wide Web）场景中的典型是基于 Web 内容的认证。</li>
</ul>
<h3 id="http-authentication">HTTP Authentication</h3>
<p>认证方案（Authentication Schemes），它是指生成用户身份凭证的某种方法，这个概念最初源于 HTTP 协议的认证框架（Authentication Framework）。</p>
<p>IETF 在<a href="https://tools.ietf.org/html/rfc7235">RFC 7235</a>中定义了 HTTP 协议的通用认证框架，要求所有支持 HTTP 协议的服务器，在未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码，同时应在响应报文头里附带以下两个分别代表网页认证和代理认证的 Header 之一，告知客户端应该采取何种方式产生能代表访问者身份的凭证信息：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#a61717;background-color:#e3d2d2">WWW-Authenticate: &lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;
</span><span style="color:#a61717;background-color:#e3d2d2">Proxy-Authenticate: &lt;认证方案&gt; realm=&lt;保护区域的描述信息&gt;
</span></code></pre></div><p>接收到该响应后，客户端必须遵循服务端指定的认证方案，在请求资源的报文头中加入身份凭证信息，由服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden 错误。请求头报文应包含以下 Header 项之一：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#a61717;background-color:#e3d2d2">Authorization: &lt;认证方案&gt; &lt;凭证内容&gt;
</span><span style="color:#a61717;background-color:#e3d2d2">Proxy-Authorization: &lt;认证方案&gt; &lt;凭证内容&gt;
</span></code></pre></div><p>HTTP 认证框架提出认证方案是希望能把认证“要产生身份凭证”的目的与“具体如何产生凭证”的实现分离开来，无论客户端通过生物信息（指纹、人脸）、用户密码、数字证书抑或其他方式来生成凭证，都属于是如何生成凭证的具体实现，都可以包容在 HTTP 协议预设的框架之内。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220729143837907.png" alt="image-20220729143837907"></p>
<!-- raw HTML omitted -->
<p>HTTP Basic 认证是一种主要以演示为目的的认证方案，也应用于一些不要求安全性的场合，譬如家里的路由器登录等，最基础的认证方案。Basic 认证产生用户身份凭证的方法是让用户输入用户名和密码，经过 Base64 编码“加密”后作为身份凭证。譬如请求资源<code>GET /admin</code>后，浏览器会收到来自服务端的如下响应：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#8b008b;font-weight:bold">HTTP</span>/<span style="color:#b452cd">1.1</span> <span style="color:#b452cd">401</span> <span style="color:#008b45;font-weight:bold">Unauthorized</span>
Date: Mon, 24 Feb 2020 16:50:53 GMT
WWW-Authenticate: Basic realm=&#34;example&#34;
</code></pre></div><p>此时，浏览器必须询问最终用户，弹出 HTTP Basic 认证对话框，要求提供用户名和密码。</p>
<p>用户在对话框中输入密码信息，譬如输入用户名<code>admin</code>，密码<code>123456</code>，浏览器会将字符串<code>admin:123456</code>编码为<code>YWRtaW46MTIzNDU2</code>，然后发送给服务端，HTTP 请求如下所示：</p>
<div class="highlight"><pre style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#008b45">GET</span> <span style="color:#008b45;text-decoration:underline">/admin</span> <span style="color:#8b008b;font-weight:bold">HTTP</span>/<span style="color:#b452cd">1.1</span>
Authorization: Basic YWRtaW46MTIzNDU2
</code></pre></div><p>服务端接收到请求，解码后检查用户名和密码是否合法，如果合法就返回<code>/admin</code>的资源，否则就返回 403 Forbidden 错误，禁止下一步操作。注意 Base64 只是一种编码方式，并非任何形式的加密，所以 Basic 认证的风险是显而易见的。除 Basic 认证外，IETF 还定义了很多种可用于实际生产环境的认证方案，列举如下。</p>
<ul>
<li><strong>Digest</strong>: <a href="https://tools.ietf.org/html/rfc7616">RFC 7616</a>，HTTP 摘要认证，可视为 Basic 认证的改良版本，针对 Base64 明文发送的风险，Digest 认证把用户名和密码加盐（一个被称为 Nonce 的变化值作为盐值）后再通过 MD5/SHA 等哈希算法取摘要发送出去。但是这种认证方式依然是不安全的，无论客户端使用何种加密算法加密，无论是否采用了 Nonce 这样的动态盐值去抵御重放和冒认，遇到中间人攻击时依然存在显著的安全风险。</li>
<li><strong>Bearer</strong>: <a href="https://tools.ietf.org/html/rfc6750">RFC 6750</a>，基于 OAuth 2 规范来完成认证，OAuth2 是一个同时涉及认证与授权的协议。</li>
<li><strong>HOBA</strong>: <a href="https://tools.ietf.org/html/rfc7486">RFC 7486</a> ，HOBA（HTTP Origin-Bound Authentication）是一种基于自签名证书的认证方案。基于数字证书的信任关系主要有两类模型：一类是采用 CA（Certification Authority）层次结构的模型，由 CA 中心签发证书；另一种是以 IETF 的 Token Binding 协议为基础的 OBC（Origin Bound Certificate）自签名证书模型。</li>
</ul>
<p>HTTP 认证框架中的认证方案是允许自行扩展的，并不要求一定由 RFC 规范来定义，只要用户代理（User Agent，通常是浏览器，泛指任何使用 HTTP 协议的程序）能够识别这种私有的认证方案即可。因此，很多厂商也扩展了自己的认证方案。</p>
<ul>
<li><strong><a href="https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html">AWS4-HMAC-SHA256</a></strong>：亚马逊 AWS 基于 HMAC-SHA256 哈希算法的认证。</li>
<li><strong>NTLM</strong> / <strong>Negotiate</strong>：这是微软公司 NT LAN Manager（NTLM）用到的两种认证方式。</li>
<li><strong>Windows Live ID</strong>：微软开发并提供的“统一登入”认证。</li>
<li><strong><a href="https://developer.twitter.com/en/docs/authentication/basic-auth">Twitter Basic</a></strong>：一个不存在的网站所改良的 HTTP 基础认证。</li>
</ul>
<h3 id="web-authentication">Web Authentication</h3>
<p>IETF 为 HTTP 认证框架设计了可插拔（Pluggable）的认证方案，原本是希望能涌现出各式各样的认证方案去支持不同的应用场景。尽管上节列举了一些还算常用的认证方案。但目前的信息系统，尤其是在系统对终端用户的认证场景中，直接采用 HTTP 认证框架的比例其实十分低。</p>
<p>HTTP 是“超文本传输协议”，传输协议的根本职责是把资源从服务端传输到客户端，至于资源具体是什么内容，只能由客户端自行解析驱动。以 HTTP 协议为基础的认证框架也只能面向传输协议而不是具体传输内容来设计，如果用户想要从服务器中下载文件，弹出一个 HTTP 服务器的对话框，让用户登录是可接受的；但如果用户访问信息系统中的具体服务，身份认证肯定希望是由系统本身的功能去完成的，而不是由 HTTP 服务器来负责认证。这种依靠内容而不是传输协议来实现的认证方式，在万维网里被称为“Web 认证”，由于实现形式上登录表单占了绝对的主流，因此通常也被称为“表单认证&quot;（Form Authentication）。</p>
<p>直至 2019 年以前，表单认证都没有什么行业标准可循，表单是什么样，其中的用户字段、密码字段、验证码字段是否要在客户端加密，采用何种方式加密，接受表单的服务地址是什么等，都完全由服务端与客户端的开发者自行协商决定。“没有标准的约束”反倒成了表单认证的一大优点，表单认证允许我们做出五花八门的页面，各种程序语言、框架或开发者本身都可以自行决定认证的全套交互细节。</p>
<p>想要支持密码或扫码等多种登录方式、想要支持图形验证码来驱逐爬虫与机器人、想要支持在登录表单提交之前进行必要的表单校验，等等，这些需求十分具体，不具备写入标准规范的通用性，却具备足够的合理性，应当在实现层面去满足。同时，如何控制权限保证不产生越权操作、如何传输信息保证内容不被窃听篡改、如何加密敏感内容保证即使泄漏也不被逆推出明文，等等，这些问题已有通行的解决方案，明确定义在规范之中，也应当在架构层面去遵循。</p>
<p>2019 年 3 月，万维网联盟（World Wide Web Consortium，W3C）批准了由<a href="https://fidoalliance.org/">FIDO</a>（Fast IDentity Online，一个安全、开放、防钓鱼、无密码认证标准的联盟）领导起草的世界首份 Web 内容认证的标准“<a href="https://webauthn.io/">WebAuthn</a>”。WebAuthn 彻底抛弃了传统的密码登录方式，改为直接采用生物识别（指纹、人脸、虹膜、声纹）或者实体密钥（以 USB、蓝牙、NFC 连接的物理密钥容器）来作为身份凭证，从根本上消灭了用户输入错误产生的校验需求和防止机器人模拟产生的验证码需求等问题，甚至可以省掉表单界面，所以这个规范不关注界面该是什么样子、要不要验证码、是否要前端校验这些问题。</p>
<p>可以在<a href="https://github.blog/2019-08-21-github-supports-webauthn-for-security-keys/">GitHub 网站的 2FA 认证功能</a>中实际体验一下如何通过 WebAuthn 完成两段式登录.</p>
<p>硬件方面，要求用带有 Touch ID 的 MacBook，或者其他支持指纹、FaceID 验证的手机（目前在售的移动设备基本都带有生物识别装置）。软件方面，直至 iOS 13.6，iPhone 和 iPad 仍未支持 WebAuthn，但 Android 和 Mac OS 系统中的 Chrome，以及 Windows 的 Edge 浏览器都已经可以正常使用 WebAuthn 了。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220729152756012.png" alt="image-20220729152756012"></p>
<!-- raw HTML omitted -->
<p>WebAuthn 规范涵盖了“注册”与“认证”两大流程，先来介绍注册流程，它大致可以分为以下步骤：</p>
<ol>
<li>用户进入系统的注册页面，这个页面的格式、内容和用户注册时需要填写的信息均不包含在 WebAuthn 标准的定义范围内。</li>
<li>当用户填写完信息，点击“提交注册信息”的按钮后，服务端先暂存用户提交的数据，生成一个随机字符串（规范中称为 Challenge）和用户的 UserID（在规范中称作凭证 ID），返回给客户端。</li>
<li>客户端的 WebAuthn API 接收到 Challenge 和 UserID，把这些信息发送给验证器（Authenticator），验证器可理解为用户设备上 TouchID、FaceID、实体密钥等认证设备的统一接口。</li>
<li>验证器提示用户进行验证，如果支持多种认证设备，还会提示用户选择一个想要使用的设备。验证的结果是生成一个密钥对（公钥和私钥），由验证器存储私钥、用户信息以及当前的域名。然后使用私钥对 Challenge 进行签名，并将签名结果、UserID 和公钥一起返回客户端。</li>
<li>浏览器将验证器返回的结果转发给服务器。</li>
<li>服务器核验信息，检查 UserID 与之前发送的是否一致，并用公钥解密后得到的结果与之前发送的 Challenge 相比较，一致即表明注册通过，由服务端存储该 UserID 对应的公钥。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220729154041416.png" alt="image-20220729154041416"></p>
<!-- raw HTML omitted -->
<p>登录流程与注册流程类似，如果你理解了注册流程，就很容易理解登录流程了。登录流程大致可以分为以下步骤：</p>
<ol>
<li>用户访问登录页面，填入用户名后即可点击登录按钮。</li>
<li>服务器返回随机字符串 Challenge、用户 UserID。</li>
<li>浏览器将 Challenge 和 UserID 转发给验证器。</li>
<li>验证器提示用户进行认证操作。由于在注册阶段验证器已经存储了该域名的私钥和用户信息，所以如果域名和用户都相同的话，就不需要生成密钥对了，直接以存储的私钥加密 Challenge，然后返回给浏览器。</li>
<li>服务端接收到浏览器转发来的被私钥加密的 Challenge，以此前注册时存储的公钥进行解密，如果解密成功则宣告登录成功。</li>
</ol>
<p>WebAuthn 采用非对称加密的公钥、私钥替代传统的密码，这是非常理想的认证方案，私钥是保密的，只有验证器需要知道它，连用户本人都不需要知道，也就没有人为泄漏的可能；公钥是公开的，可以被任何人看到或存储。公钥可用于验证私钥生成的签名，但不能用来签名，除了得知私钥外，没有其他途径能够生成可被公钥验证为有效的签名，这样服务器就可以通过公钥是否能够解密来判断最终用户的身份是否合法。</p>
<p>WebAuthn 还解决了传统密码在网络传输上的风险，对防御中间人攻击来说都是没有意义的。 WebAuthn 为登录过程带来极大的便捷性，不仅注册和验证的用户体验十分优秀，而且彻底避免了用户在一个网站上泄漏密码，所有使用相同密码的网站都受到攻击的问题，这个优点使得用户无须再为每个网站想不同的密码。</p>
<h2 id="implementation-of-the-authentication">Implementation of the Authentication</h2>
<ol>
<li><a href="https://shiro.apache.org/">Apache Shiro</a></li>
<li><a href="https://spring.io/projects/spring-security">Spring Security</a></li>
<li><a href="https://stackoverflow.com/questions/15419147/net-security-frameworks-for-net">Security Frameworks for .NET</a></li>
</ol>
<blockquote>
<p>I don&rsquo;t know those frameworks but from a quick glance at Apache Shiro and Spring Security I get that you are looking for something that will do <em>cryptography</em>, <em>session management</em>, <em>authentication</em> and <em>authorization</em>. Unfortunately I don&rsquo;t know any frameworks that will do that for you except what&rsquo;s built into .NET by default.</p>
<p><strong>Cryptography</strong> is provided by the <a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.aspx"><code>System.Security.Cryptography</code> namespace</a>.</p>
<p><strong>Authentication</strong> and <strong>Authorization</strong> are provided by default by ASP.Net, as Windows, Forms or password authentication. See for example the <a href="http://www.codeproject.com/Articles/98950/ASP-NET-authentication-and-authorization">ASP.NET authentication and authorization</a> article on CodeProject.</p>
<p><strong>Session management</strong> is also built into ASP.Net. For example, see <a href="http://msdn.microsoft.com/en-us/library/75x4ha6s.aspx">ASP.NET State Management Overview</a> on MSDN.</p>
</blockquote>
<p>安全框架提供的功能都很类似，大致包括以下四类：</p>
<ul>
<li>认证功能（Authentication）：以 HTTP 协议中定义的各种认证、表单等认证方式确认用户身份，这是本节的主要话题。</li>
<li>安全上下文（Session management）：用户获得认证之后，要开放一些接口，让应用可以得知该用户的基本资料、用户拥有的权限、角色，等等。</li>
<li>授权功能（Authorization）：判断并控制认证后的用户对什么资源拥有哪些操作许可。</li>
<li>密码的存储与验证（Cryptography）：密码是烫手的山芋，存储、传输还是验证都应谨慎处理。</li>
</ul>
<hr>
<h1 id="authorization">Authorization</h1>
<p>系统如何控制一个用户该看到哪些数据、能操作哪些功能？</p>
<p>授权这个概念通常伴随着认证、审计、账号一同出现，并称为 AAAA（Authentication、Authorization、Audit、Account，也有一些领域把 Account 解释为计费的意思）。授权行为在程序中的应用非常广泛，给某个类或某个方法设置范围控制符（public、protected、private、namespace）在本质上也是一种授权（访问控制）行为。而在安全领域中所说的授权就更具体一些，通常涉及以下两个相对独立的问题：</p>
<ul>
<li><strong>确保授权的过程可靠</strong>：对于单一系统来说，授权的过程是比较容易做到可控的，以前很多语境上提到授权，实质上讲的都是访问控制，理论上两者是应该分开的。而在涉及多方的系统中，授权过程则是一个比较困难却必须严肃对待的问题：如何既让第三方系统能够访问到所需的资源，又能保证其不泄露用户的敏感数据呢？常用的多方授权协议主要有 OAuth2 和 SAML 2.0（两个协议涵盖的功能并不是直接对等的）。</li>
<li><strong>确保授权的结果可控</strong>：授权的结果用于对程序功能或者资源的<a href="https://en.wikipedia.org/wiki/Access-control_list">访问控制</a>（Access Control），成理论体系的权限控制模型有很多，譬如：
<ul>
<li><a href="https://en.wikipedia.org/wiki/Discretionary_access_control">自主访问控制</a>（Discretionary Access Control，DAC）</li>
<li><a href="https://en.wikipedia.org/wiki/Mandatory_access_control">强制访问控制</a>（Mandatory Access Control，MAC）</li>
<li><a href="https://en.wikipedia.org/wiki/Attribute-based_access_control">基于属性的访问控制</a>（Attribute-Based Access Control，ABAC）</li>
<li><a href="https://en.wikipedia.org/wiki/Role-based_access_control">基于角色的访问控制</a>（Role-Based Access Control，RBAC）：最为常用的一种。</li>
</ul>
</li>
</ul>
<h2 id="rbac">RBAC</h2>
<p>所有的访问控制模型，实质上都是在解决同一个问题：“<strong>谁</strong>（User）拥有什么<strong>权限</strong>（Authority）去<strong>操作</strong>（Operation）哪些<strong>资源</strong>（Resource）”。</p>
<p>这个问题初看起来并不难，一种直观的解决方案就是在用户对象上设定一些权限，当用户使用资源时，检查是否有对应的操作权限即可。很多著名的安全框架，譬如 Spring Security 的访问控制本质上就是支持这么做的。不过，这种把权限直接关联在用户身上的简单设计，在复杂系统上确实会导致一些比较烦琐的问题。试想一下，如果某个系统涉及到成百上千的资源，又有成千上万的用户，一旦两者搅合到一起，要为每个用户访问每个资源都分配合适的权限，必定导致巨大的操作量和极高的出错概率，这也正是 RBAC 所关注的问题之一。</p>
<p>RBAC 模型有多种定义，其中以美国 George Mason 大学信息安全技术实验室提出的 RBAC96 模型最具有系统性，得到普遍的认可。为了避免对每一个用户设定权限，RBAC（<a href="https://en.wikipedia.org/wiki/Role-based_access_control">Role-based access control</a>） 将权限从用户身上剥离，改为绑定到“<strong>角色</strong>”（Role）上，将权限控制变为对“<strong>角色</strong>拥有操作哪些<strong>资源</strong>的<strong>许可</strong>”这个逻辑表达式的值是否为真的求解过程。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220729181435054.png" alt="image-20220729181435054"></p>
<!-- raw HTML omitted -->
<p>“<strong>许可</strong>”（Permission）是抽象权限的具象化体现，权限在 RBAC 系统中的含义是“允许何种<strong>操作</strong>作用于哪些<strong>资源</strong>之上”，这句话的具体实例即为“许可”。提出许可这个概念的目的其实与提出角色的目的是完全一致的，只是更为抽象。角色为的是解耦用户与权限之间的多对多关系，而许可为的是解耦操作与资源之间的多对多关系，譬如不同的数据都能够有增、删、改等操作，如果将数据与操作搅和在一起也会面临配置膨胀问题。这里举个更具体的例子帮助你理清众多名词之间的关系，譬如某个论文管理系统的 UserStory 中，与访问控制相关的 Backlog 可能会是这样描述的：</p>
<blockquote>
<p><strong>Backlog</strong>：</p>
<p><strong>周同学</strong>（User）是某 SCI 杂志的<strong>审稿人</strong>（Role），职责之一是在系统中<strong>审核论文</strong>（Authority）。在<strong>审稿过程</strong>（Session）中，当他认为某篇<strong>论文</strong>（Resource）达到了可以公开发表标准时，就会在后台<strong>点击通过按钮</strong>（Operation）来完成审核。</p>
</blockquote>
<p>以上 Backlog 中“给论文点击通过按钮”就是一种许可，它是“审核论文”这项权限的具象化体现。</p>
<p>采用 RBAC 不仅是为了简化配置操作，还天然地满足了计算机安全中的“<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小特权原则</a>”（Least Privilege）。在 RBAC 模型中，角色拥有许可的数量是根据完成该角色工作职责所需的最小权限来赋予的，最典型例子是操作系统权限管理中的用户组，根据对不同角色的职责分工，如管理员（Administrator）、系统用户（System）、验证用户（Authenticated Users）、普通用户（Users）、来宾用户（Guests）等分配各自的权限，既保证用户能够正常工作，也避免用户出现越权操作的风险。当用户的职责发生变化时，在系统中就体现为它所隶属的角色被改变，譬如将“普通用户角色”改变“管理员角色”，就可以迅速让该用户具备管理员的多个细分权限，降低权限分配错误的风险。</p>
<p>RBAC 还允许对不同角色之间定义关联与约束，进一步强化它的抽象描述能力。如不同的角色之间可以有继承性，典型的是 RBAC-1 模型的角色权限继承关系。譬如描述开发经理应该和开发人员一样具有代码提交的权限，描述开发人员都应该和任何公司员工一样具有食堂就餐的权限，就可以直接将食堂就餐赋予公司员工的角色上，把代码提交赋予到开发人员的角色上，再让开发人员的角色从公司员工派生，开发经理的角色从开发人员中派生即可。</p>
<p>不同角色之间也可以具有互斥性，典型的是 RBAC-2 模型的角色职责分离关系。互斥性要求权限被赋予角色时，或角色被赋予用户时应遵循的强制性职责分离规定。举个例子，角色的互斥约束可限制同一用户只能分配到一组互斥角色集合中至多一个角色，譬如不能让同一名员工既当会计，也当出纳，否则资金安全无法保证。角色的基数约束可限制某一个用户拥有的最大角色数目，譬如不能让同一名员工从产品、设计、开发、测试全部包揽，否则产品质量无法保证。</p>
<p>建立访问控制模型的基本目的是为了管理垂直权限和水平权限。垂直权限即功能权限，譬如前面提到的审稿编辑有通过审核的权限、开发经理有代码提交的权限、出纳有从账户提取资金的权限，这一类某个角色完成某项操作的许可，都可以直接翻译为功能权限。由于实际应用与权限模型具有高度对应关系，将权限从具体的应用中抽离出来，放到通用的模型中是相对容易的。</p>
<p>与此相对，水平权限即数据权限管理起来则要困难许多。譬如用户 A、B 都属于同一个角色，但它们各自在系统中产生的数据完全有可能是私有的，A 访问或删除了 B 的数据也照样属于越权。一般来说，数据权限是很难抽象与通用的，仅在角色层面控制并不能满足全部业务的需要，很多时候只能具体到用户，甚至要具体管理到发生数据的某一行、某一列之上，因此数据权限基本只能由信息系统自主来来完成，并不存在能通用数据权限框架。</p>
<p>Kubernetes 完全遵循了 RBAC 来进行服务访问控制。 Spring Security 也参考了（但并没有完全遵循）RBAC 来设计它的访问控制功能。Spring Security 的设计里，用户和角色都可以拥有权限，譬如在它的 HttpSecurity 接口就同时有着 hasRole()和 hasAuthority()方法，可能刚接触的程序员会疑惑，混淆它们之间的关系。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220729181500729.png" alt="image-20220729181500729"></p>
<!-- raw HTML omitted -->
<p>从实现角度来看，Role 和 Authority 的差异可以很大，用户可以自行决定系统中到底 Permission 只能对应到角色身上，还是可以让用户也拥有某些角色中没有的权限。这一点不符合 RBAC 的思想，但在 Spring Security 的文档上说的很清楚：这取决于你自己如何使用。</p>
<blockquote>
<p>The core difference between these two（注：指 Role 和 Authority） is the semantics we attach to how we use the feature. For the framework, the difference is minimal – and it basically deals with these in exactly the same way.</p>
<p>Role 和 Authority 的核心差异取决于用户打算如何使用这些特性，在框架层面它们的差别是极小的，基本采用了完全相同的方式来进行处理。</p>
</blockquote>
<p>通过 RBAC 很容易控制最终用户在广义和精细级别上能够做什么，可以指定用户是管理员、专家用户抑或普通用户，并使角色和访问权限与组织中员工的身份职位保持一致，仅根据需要为员工完成工作的最低限度来分配权限。这些都是大量软件系统、长时间积累下来的经验，将这些经验运用在软件产品上，绝大多数情况下要比自己发明创造一个新的轮子更加安全。</p>
<h2 id="oauth2">OAuth2</h2>
<p>相对更复杂烦琐的 <a href="https://oauth.net/2/">OAuth2</a> 认证授权协议（更烦琐的 OAuth1 已经完全被废弃了）是在<a href="https://tools.ietf.org/html/rfc6749">RFC 6749</a>中定义的国际标准，在 RFC 6749 正文的第一句就阐明了 OAuth2 是<strong>面向于解决第三方应用</strong>（Third-Party Application）的认证授权协议。如果你的系统并不涉及第三方，也不使用第三方的服务，那引入 OAuth2 其实并无必要。</p>
<p>如果使用GitHub Pages搭建网站，它的建设和更新大致流程是：作者以 Markdown 形式写好了某篇文章，上传到由 GitHub 提供的代码仓库，接着由<a href="https://travis-ci.com/">Travis-CI</a>提供的持续集成服务会检测到该仓库发生了变化，触发一次编译活动，生成目录和静态的 HTML 页面，然后推送回<a href="https://pages.github.com/">GitHub Pages</a>，再触发国内的 CDN 缓存刷新。这个过程要能顺利进行，就存在一系列必须解决的授权问题，Travis-CI 只有得到了我的明确授权，GitHub 才能同意它读取我代码仓库中的内容，问题是它该如何获得我的授权呢？一种最简单粗暴的方案是把我的用户账号和密码都告诉 Travis-CI，但这显然导致了以下这些问题：</p>
<ul>
<li><strong>密码泄漏</strong>：如果 Travis-CI 被黑客攻破，将导致我的 GitHub 的密码也同时被泄漏。</li>
<li><strong>访问范围</strong>：Travis-CI 将有能力读取、修改、删除、更新我放在 GitHub 上的所有代码仓库，而我并不希望它能够修改删除文件。</li>
<li><strong>授权回收</strong>：只有修改密码才能回收我授予给 Travis-CI 的权力，可是我在 GitHub 的密码只有一个，授权的应用除了 Travis-CI 之外却还有许多，修改了意味着所有别的第三方的应用程序会全部失效。</li>
</ul>
<p>以上列举的这些问题，也正是 OAuth2 所要解决的问题，尤其是要求第三方系统没有支持 HTTPS 传输安全的环境下依然能够解决这些问题，这并非易事。</p>
<p>OAuth2 给出了多种解决办法，这些办法的共同特征是以令牌（Token）代替用户密码作为授权的凭证。有了令牌之后，哪怕令牌被泄漏，也不会导致密码的泄漏；令牌上可以设定访问资源的范围以及时效性；每个应用都持有独立的令牌，哪个失效都不会波及其他。这样上面提出的三个问题就都解决了。有了一层令牌之后，整个授权的流程如图所示。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220808161958036.png" alt="image-20220808161958036"></p>
<!-- raw HTML omitted -->
<p>这个时序图里面涉及到了 OAuth2 中几个关键术语：</p>
<ul>
<li><strong>第三方应用</strong>（Third-Party Application）：需要得到授权访问我资源的那个应用，即此场景中的“Travis-CI”。</li>
<li><strong>授权服务器</strong>（Authorization Server）：能够根据我的意愿提供授权（授权之前肯定已经进行了必要的认证过程，但它与授权可以没有直接关系）的服务器，即此场景中的“GitHub”。</li>
<li><strong>资源服务器</strong>（Resource Server）：能够提供第三方应用所需资源的服务器，它与认证服务可以是相同的服务器，也可以是不同的服务器，此场景中的“我的代码仓库”。</li>
<li><strong>资源所有者</strong>（Resource Owner）： 拥有授权权限的人，即此场景中的“我”。</li>
<li><strong>操作代理</strong>（User Agent）：指用户用来访问服务器的工具，对于人类用户来说，这个通常是指浏览器，但在微服务中一个服务经常会作为另一个服务的用户，此时指的可能就是 HttpClient、RPCClient 或者其他访问途径。</li>
</ul>
<p>“用令牌代替密码”确实是解决问题的好方法，但这充其量只能算个思路，距离可实施的步骤还是不够具体的，时序图中的“要求/同意授权”、“要求/同意发放令牌”、“要求/同意开放资源”几个服务请求、响应该如何设计，这就是执行步骤的关键了。对此，OAuth2 一共提出了四种不同的授权方式（这也是 OAuth2 复杂烦琐的主要原因），分别为：</p>
<ul>
<li>授权码模式（Authorization Code）</li>
<li>隐式授权模式（Implicit）</li>
<li>密码模式（Resource Owner Password Credentials）</li>
<li>客户端模式（Client Credentials）</li>
</ul>
<h3 id="授权码模式">授权码模式</h3>
<p>授权码模式是四种模式中最严谨繁琐的，它考虑到了几乎所有敏感信息泄漏的预防和后果。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220808162226442.png" alt="image-20220808162226442"></p>
<!-- raw HTML omitted -->
<p>开始进行授权过程以前，第三方应用先要到授权服务器上进行注册，所谓注册，是指向认证服务器提供一个域名地址，然后从授权服务器中获取 ClientID 和 ClientSecret，以便能够顺利完成如下授权过程：</p>
<ol>
<li>第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供 ClientID 及用户同意授权后的回调 URI，这是一次客户端页面转向。</li>
<li>授权服务器根据 ClientID 确认第三方应用的身份，用户在授权服务器中决定是否同意向该身份的应用进行授权，用户认证的过程未定义在此步骤中，在此之前应该已经完成。</li>
<li>如果用户同意授权，授权服务器将转向第三方应用在第 1 步调用中提供的回调 URI，并附带上一个授权码和获取令牌的地址作为参数，这是第二次客户端页面转向。</li>
<li>第三方应用通过回调地址收到授权码，然后将授权码与自己的 ClientSecret 一起作为参数，通过服务器向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。该服务器的地址应与注册时提供的域名处于同一个域中。</li>
<li>授权服务器核对授权码和 ClientSecret，确认无误后，向第三方应用授予令牌。令牌可以是一个或者两个，其中必定要有的是访问令牌（Access Token），可选的是刷新令牌（Refresh Token）。访问令牌用于到资源服务器获取资源，有效期较短，刷新令牌用于在访问令牌失效后重新获取，有效期较长。</li>
<li>资源服务器根据访问令牌所允许的权限，向第三方应用提供资源。</li>
</ol>
<p>这个过程设计，已经考虑到了几乎所有合理的意外情况，如下几个最容易遇到的意外状况：</p>
<ul>
<li>会不会有其他应用冒充第三方应用骗取授权？
ClientID 代表一个第三方应用的“用户名”，这项信息是可以完全公开的。但 ClientSecret 应当只有应用自己才知道，这个代表了第三方应用的“密码”。在第 5 步发放令牌时，调用者必须能够提供 ClientSecret 才能成功完成。只要第三方应用妥善保管好 ClientSecret，就没有人能够冒充它。</li>
<li>为什么要先发放授权码，再用授权码换令牌？
这是因为客户端转向（通常就是一次 HTTP 302 重定向）对于用户是可见的，换而言之，授权码可能会暴露给用户以及用户机器上的其他程序，但由于用户并没有 ClientSecret，光有授权码也是无法换取到令牌的，所以避免了令牌在传输转向过程中被泄漏的风险。</li>
<li>为什么要设计一个时限较长的刷新令牌和时限较短的访问令牌？不能直接把访问令牌的时间调长吗？
这是为了缓解 OAuth2 在实际应用中的一个主要缺陷，通常访问令牌一旦发放，除非超过了令牌中的有效期，否则很难（需要付出较大代价）有其他方式让它失效，所以访问令牌的时效性一般设计的比较短，譬如几个小时，如果还需要继续用，那就定期用刷新令牌去更新，授权服务器就可以在更新过程中决定是否还要继续给予授权。</li>
</ul>
<p>尽管授权码模式是严谨的，但是它并不够好用，这不仅仅体现在它那繁复的调用过程上，还体现在它对第三方应用提出了一个“貌似不难”的要求：第三方应用必须有应用服务器，因为第 4 步要发起服务端转向，而且要求服务端的地址必须与注册时提供的地址在同一个域内。不要觉得要求一个系统要有应用服务器是天经地义理所当然的事情，你现在阅读文章的这个网站就没有任何应用服务器的支持，里面使用到了 Gitalk 作为每篇文章的留言板，它对 GitHub 来说照样是第三方应用，需要 OAuth2 授权来解决。除基于浏览器的应用外，现在越来越普遍的是移动或桌面端的客户端 Web 应用（Client-Side Web Applications），譬如现在大量的基于 Cordova、Electron、Node-Webkit.js 的<a href="https://en.wikipedia.org/wiki/Progressive_web_application">PWA 应用</a>，它们都没有应用服务器的支持。由于有这样的实际需求，因此引出了 OAuth2 的第二种授权模式：隐式授权。</p>
<h3 id="隐式授权模式">隐式授权模式</h3>
<p>隐式授权省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端支持，一步到位。代价是在隐式授权中，授权服务器不会再去验证第三方应用的身份，因为已经没有应用服务器了，ClientSecret 没有人保管，就没有存在的意义了。但其实还是会限制第三方应用的回调 URI 地址必须与注册时提供的域名一致，尽管有可能被 DNS 污染之类的攻击所攻破，但仍算是尽可能努力一下。同样的原因，也不能避免令牌暴露给资源所有者，不能避免用户机器上可能意图不轨的其他程序、HTTP 的中间人攻击等风险了。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220808162450990.png" alt="image-20220808162450990"></p>
<!-- raw HTML omitted -->
<p>在时序图所示的交互过程里，隐式模式与授权码模式的显著区别是授权服务器在得到用户授权后，直接返回了访问令牌，这显著地降低了安全性，但 OAuth2 仍然努力尽可能地做到相对安全，譬如在前面提到的隐式授权中，尽管不需要用到服务端，但仍然需要在注册时提供回调域名，此时会要求该域名与接受令牌的服务处于同一个域内。此外，同样基于安全考虑，在隐式模式中明确禁止发放刷新令牌。</p>
<p>在 RFC 6749 对隐式授权的描述中，特别强调了令牌必须是“通过 Fragment 带回”的。</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/URI_fragment">URI Fragment</a></p>
<p>In computer hypertext, a fragment identifier is a string of characters that refers to a resource that is subordinate to another, primary resource. The primary resource is identified by a Uniform Resource Identifier (URI), and the fragment identifier points to the subordinate resource.</p>
</blockquote>
<p>Fragment 就是地址中<code>#</code>号后面的部分，譬如这个地址：</p>
<blockquote>
<p><a href="https://www.google.com/webhp/#/detail/1">https://www.google.com/webhp/#/detail/1</a></p>
</blockquote>
<p>后面的<code>/detail/1</code>便是 Fragment，这个语法是在<a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>中定义的，RFC 3986 中解释了 Fragment 是用于客户端定位的 URI 从属资源，譬如 HTML 中就可以使用 Fragment 来做文档内的跳转而不会发起服务端请求，你现在可以点击一下这篇文章左边菜单中的几个子标题，看看浏览器地址栏的变化。此外，RFC 3986 还规定了如果浏览器对一个带有 Fragment 的地址发出 Ajax 请求，那 Fragment 是不会跟随请求被发送到服务端的，只能在客户端通过 Script 脚本来读取。所以隐式授权巧妙地利用这个特性，尽最大努力地避免了令牌从操作代理到第三方服务之间的链路存在被攻击而泄漏出去的可能性。至于认证服务器到操作代理之间的这一段链路的安全，则只能通过 TLS（即 HTTPS）来保证中间不会受到攻击了，我们可以要求认证服务器必须都是启用 HTTPS 的，但无法要求第三方应用同样都支持 HTTPS。</p>
<h3 id="密码模式">密码模式</h3>
<p>前面所说的授权码模式和隐私模式属于纯粹的授权模式，它们与认证没有直接的联系，如何认证用户的真实身份是与进行授权互相独立的过程。但在密码模式里，认证和授权就被整合成了同一个过程了。</p>
<p>密码模式原本的设计意图是仅限于用户对第三方应用是高度可信任的场景中使用，因为用户需要把密码明文提供给第三方应用，第三方以此向授权服务器获取令牌。这种高度可信的第三方是极为较罕见的，尽管介绍 OAuth2 的材料中，经常举的例子是“操作系统作为第三方应用向授权服务器申请资源”，但真实应用中极少遇到这样的情况，合理性依然十分有限。</p>
<p>如果要采用密码模式，那“第三方”属性就必须弱化，把“第三方”视作是系统中与授权服务器相对独立的子模块，在物理上独立于授权服务器部署，但是在逻辑上与授权服务器仍同属一个系统，这样将认证和授权一并完成的密码模式才会有合理的应用场景。</p>
<p>理解了密码模式的用途，它的调用过程就很简单了，就是第三方应用拿着用户名和密码向授权服务器换令牌而已。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220808162839418.png" alt="image-20220808162839418"></p>
<!-- raw HTML omitted -->
<p>密码模式下“保障安全”的职责无法由 OAuth2 来承担，只能由用户和第三方应用来自行保障，尽管 OAuth2 在规范中强调到“此模式下，第三方应用不得保存用户的密码”，但这并没有任何技术上的约束力。</p>
<h3 id="客户端模式">客户端模式</h3>
<p>客户端模式是四种模式中最简单的，它只涉及到两个主体，第三方应用和授权服务器。如果严谨一点，现在称“第三方应用”其实已经不合适了，因为已经没有了“第二方”的存在，资源所有者、操作代理在客户端模式中都是不必出现的。甚至严格来说叫“授权”都已不太恰当，资源所有者都没有了，也就不会有谁授予谁权限的过程。</p>
<p>客户端模式是指第三方应用以自己的名义，向授权服务器申请资源许可。此模式通常用于管理操作或者自动处理类型的场景中。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220808163117539.png" alt="image-20220808163117539"></p>
<!-- raw HTML omitted -->
<p>微服务架构并不提倡同一个系统的各服务间有默认的信任关系，所以服务之间调用也需要先进行认证授权，然后才能通信。此时，客户端模式便是一种常用的服务间认证授权的解决方案。</p>
<p>OAuth2 中还有一种与客户端模式类似的授权模式，在<a href="https://tools.ietf.org/html/rfc8628#section-3.4">RFC 8628</a>中定义为“设备码模式”（Device Code），这里顺带提一下。设备码模式用于在无输入的情况下区分设备是否被许可使用，典型的应用便是手机锁网解锁（锁网在国内较少，但在国外很常见）或者设备激活（譬如某游戏机注册到某个游戏平台）的过程。</p>
<p><img src="https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220808163344693.png" alt="image-20220808163344693"></p>
<!-- raw HTML omitted -->
<p>进行验证时，设备需要从授权服务器获取一个 URI 地址和一个用户码，然后需要用户手动或设备自动地到验证 URI 中输入用户码。在这个过程中，设备会一直循环，尝试去获取令牌，直到拿到令牌或者用户码过期为止。</p>
<hr>
<h1 id="credential">Credential</h1>
<p>系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</p>
<p>在前面介绍 OAuth2 的内容中，每一种授权模式的最终目标都是拿到访问令牌，但从未涉及过拿回来的令牌应该长什么样子。凭证要讨论的主角就是令牌了，同时，还会讨论如果不使用 OAuth2，如何以最传统的方式完成认证、授权。</p>
<p>以 HTTP 协议的 Cookie-Session 机制为代表的服务端状态存储在三十年来都是主流的解决方案。不过，到了最近十年，由于分布式系统中共享数据必然会受到 CAP 不兼容原理的打击限制，迫使人们重新去审视之前已基本放弃掉的客户端状态存储，这就让原本通常只在多方系统中采用的 JWT 令牌方案。</p>
<h2 id="cookie-session">Cookie-Session</h2>
<h2 id="jwt">JWT</h2>
<hr>
<h1 id="confidentiality">Confidentiality</h1>
<p>系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</p>
<hr>
<h1 id="transport-security">Transport Security</h1>
<p>系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</p>
<hr>
<h1 id="verification">Verification</h1>
<p>系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</p>
<hr>
<h1 id="reference">Reference</h1>
<ol>
<li><a href="http://icyfenix.cn/architect-perspective/general-architecture/system-security/">http://icyfenix.cn/architect-perspective/general-architecture/system-security/</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows-server/identity/identity-and-access">Identity and Access documentation</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview">Active Directory Domain Services Overview</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/security/">Security in .NET</a></li>
</ol>

                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">Last modified on 2022-07-19</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="https://www.openheart.icu/business/purchase-orders/">
			Next<br>Purchase Orders
                </a>
                
                
                
                <a class="older-posts" href="https://www.openheart.icu/microsoft-dotnet/dot-net-6&#43;/">
			Previous<br>Dot Net 6&#43;
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                


<div id="gitalk-container"></div>









            </div>
        </div>
    </div>


                    </div>
            </div><div id="single-column-footer">
	
	<i class="fa fa-weixin" aria-hidden="true"></i>
	QuadragintaDuo
	<br>
	<i class="fa fa-envelope" aria-hidden="true"></i>
	krisnie42@qq.com
	<br>
		site pv:<span id="busuanzi_value_site_pv_m"></span>
	| 
		site uv:<span id="busuanzi_value_site_uv_m"></span>
	<br>
	鲁ICP备20007116号
	<br>
	Powered by Hugo | Theme - <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a>
	
	<br>
	
	
	&copy;
		
		2022 ALL RIGHTS RESERVED KRIS NIE
		
	<script>
		$(function(){
			$("#busuanzi_value_site_uv").bind('DOMNodeInserted',function(e){
				console.log('DOMNodeInserted');
				debugger;
				$('#busuanzi_value_site_uv_m').after($('#busuanzi_value_site_uv').text()); 
				$('#busuanzi_value_site_pv_m').after($('#busuanzi_value_site_pv').text());
			});
		})
	</script>
</div>
            </div>
    
    <script src="/js/journal.js"></script>
    </body>
</html>
