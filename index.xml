<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>42th openheart</title>
    <link>https://www.openheart.icu/</link>
    <description>Recent content on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Wed, 01 Dec 2021 14:28:00 +0000</lastBuildDate>
    
        <atom:link href="https://www.openheart.icu/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Representational State Transfer</title>
        <link>https://www.openheart.icu/cs/representational-state-transfer/</link>
        <pubDate>Wed, 01 Dec 2021 14:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/representational-state-transfer/</guid>
        <description>42th openheart https://www.openheart.icu/cs/representational-state-transfer/ -&lt;h1 id=&#34;whats-rest&#34;&gt;What&amp;rsquo;s REST?&lt;/h1&gt;
&lt;p&gt;Representational State Transfer, 表征状态转移&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比较容易理解 REST 思想的途径是先理解什么是 HTTP，再配合一些实际例子来进行类比，你会发现“REST”（&lt;strong&gt;Re&lt;/strong&gt;presentational &lt;strong&gt;S&lt;/strong&gt;tate &lt;strong&gt;T&lt;/strong&gt;ransfer）实际上是“HTT”（&lt;strong&gt;H&lt;/strong&gt;yper&lt;strong&gt;t&lt;/strong&gt;ext &lt;strong&gt;T&lt;/strong&gt;ransfer）的进一步抽象，两者就如同接口与实现类的关系一般。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hypertext&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By now the word &amp;ldquo;hypertext&amp;rdquo; has become generally accepted for branching and responding text, but the corresponding word &amp;ldquo;hypermedia&amp;rdquo;, meaning complexes of branching and responding graphics, movies and sound – as well as text – is much less used.&lt;/p&gt;
&lt;p&gt;现在，&amp;ldquo;超文本 &amp;ldquo;一词已被普遍接受，它指的是能够进行分支判断和差异响应的文本，相应地， &amp;ldquo;超媒体 &amp;ldquo;一词指的是能够进行分支判断和差异响应的图形、电影和声音（也包括文本）的复合体。&lt;/p&gt;
&lt;p&gt;—— Theodor Holm Nelson &lt;a href=&#34;https://en.wikipedia.org/wiki/Literary_Machines&#34;&gt;Literary Machines&lt;/a&gt;, 1992&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;resource&#34;&gt;Resource&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;资源&lt;/strong&gt;：譬如你现在正在阅读一篇有关REST的文章，这篇文章的内容本身（你可以将其理解为其蕴含的信息、数据）我们称之为“资源”。无论你是购买的书籍、是在浏览器看的网页、是打印出来看的文稿、是在电脑屏幕上阅读抑或是手机上浏览，尽管呈现的样子各不相同，但其中的信息是不变的，你所阅读的仍是同一份“资源”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;representation&#34;&gt;Representation&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;表征&lt;/strong&gt;：当你通过电脑浏览器阅读文章时，浏览器向服务端发出请求“我需要这个资源的 HTML 格式”，服务端向浏览器返回的这个 HTML 就被称之为“表征”，你可能通过其他方式拿到本文的 PDF、Markdown、RSS 等其他形式的版本，它们也同样是一个资源的多种表征。可见“表征”这个概念是指信息与用户交互时的表示形式，这与我们软件分层架构中常说的“表示层”（Presentation Layer）的语义其实是一致的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;state&#34;&gt;State&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;：当你读完了这篇文章，想看后面是什么内容时，你向服务器发出请求“给我下一篇文章”。但是“下一篇”是个相对概念，必须依赖“当前你正在阅读的文章是哪一篇”才能正确回应，这类在特定语境中才能产生的上下文信息即被称为“状态”。我们所说的有状态（Stateful）抑或是无状态（Stateless），都是只相对于服务端来说的，服务器要完成“取下一篇”的请求，要么自己记住用户的状态：这个用户现在阅读的是哪一篇文章，这称为有状态；要么客户端来记住状态，在请求的时候明确告诉服务器：我正在阅读某某文章，现在要读它的下一篇，这称为无状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;transfer&#34;&gt;Transfer&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;转移&lt;/strong&gt;：无论状态是由服务端还是客户端来提供的，“取下一篇文章”这个行为逻辑必然只能由服&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;related-concepts&#34;&gt;Related concepts&lt;/h2&gt;
&lt;h3 id=&#34;uniform-interface&#34;&gt;Uniform Interface&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;统一接口&lt;/strong&gt;：上面说的服务器“通过某种方式”让表征状态发生转移，具体是什么方式？如果你真的是用浏览器阅读本文电子版的话，请把本文滚动到结尾处，右下角有下一篇文章的 URI 超链接地址，这是服务端渲染这篇文章时就预置好的，点击它让页面跳转到下一篇，就是所谓“某种方式”的其中一种方式。任何人都不会对点击超链接网页会出现跳转感到奇怪，但你细想一下，URI 的含义是统一资源标识符，是一个名词，如何能表达出“转移”动作的含义呢？答案是 HTTP 协议中已经提前约定好了一套“统一接口”，它包括：GET、HEAD、POST、PUT、DELETE、TRACE、OPTIONS 七种基本操作，任何一个支持 HTTP 协议的服务器都会遵守这套规定，对特定的 URI 采取这些操作，服务器就会触发相应的表征状态转移。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;hypertext-driven&#34;&gt;Hypertext Driven&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;超文本驱动&lt;/strong&gt;：尽管表征状态转移是由浏览器主动向服务器发出请求所引发的，该请求导致了“在浏览器屏幕上显示出了下一篇文章的内容”这个结果的出现。但是，你我都清楚这不可能真的是浏览器的主动意图，浏览器是根据用户输入的 URI 地址来找到网站首页，服务器给予的首页超文本内容后，浏览器再通过超文本内部的链接来导航到了这篇文章，阅读结束时，也是通过超文本内部的链接来再导航到下一篇。浏览器作为所有网站的通用的客户端，任何网站的导航（状态转移）行为都不可能是预置于浏览器代码之中，而是由服务器发出的请求响应信息（超文本）来驱动的。这点与其他带有客户端的软件有十分本质的区别，在那些软件中，业务逻辑往往是预置于程序代码之中的，有专门的页面控制器（无论在服务端还是在客户端中）来驱动页面的状态转移。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;self-descriptive-messages&#34;&gt;Self-Descriptive Messages&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;自描述消息&lt;/strong&gt;：由于资源的表征可能存在多种不同形态，在消息中应当有明确的信息来告知客户端该消息的类型以及应如何处理这条消息。一种被广泛采用的自描述方法是在名为“Content-Type”的 HTTP Header 中标识出&lt;a href=&#34;https://en.wikipedia.org/wiki/Media_type&#34;&gt;互联网媒体类型&lt;/a&gt;（MIME type），譬如“Content-Type : application/json; charset=utf-8”，则说明该资源会以 JSON 的格式来返回，请使用 UTF-8 字符集进行处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;restful-system&#34;&gt;RESTful System&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Traditionally, people design RPC APIs in terms of API interfaces and methods, such as CORBA and Windows COM. As time goes by, more and more interfaces and methods are introduced. The end result can be an overwhelming number of interfaces and methods, each of them different from the others. Developers have to learn each one carefully in order to use it correctly, which can be both time consuming and error prone&lt;/p&gt;
&lt;p&gt;以前，人们面向方法去设计 RPC API，譬如 CORBA 和 DCOM，随着时间推移，接口与方法越来越多却又各不相同，开发人员必须了解每一个方法才能正确使用它们，这样既耗时又容易出错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;—— &lt;a href=&#34;https://cloud.google.com/apis/design&#34;&gt;Google API Design Guide&lt;/a&gt;, 2017&lt;/p&gt;
&lt;p&gt;Fielding 认为，一套理想的、完全满足 REST 风格的系统应该满足以下六大原则&lt;/p&gt;
&lt;h2 id=&#34;client-server&#34;&gt;Client-Server&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;服务端与客户端分离&lt;/strong&gt;：将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来，有助于提高用户界面的跨平台的可移植性，这一点正越来越受到广大开发者所认可，以前完全基于服务端控制和渲染（如 JSF 这类）框架实际用户已甚少，而在服务端进行界面控制（Controller），通过服务端或者客户端的模版渲染引擎来进行界面渲染的框架（如 Struts、SpringMVC 这类）也受到了颇大的冲击。这一点主要推动力量与 REST 可能关系并不大，前端技术（从 ES 规范，到语言实现，到前端框架等）的近年来的高速发展，使得前端表达能力大幅度加强才是真正的幕后推手。由于前端的日渐强势，现在还流行起由前端代码反过来驱动服务端进行渲染的 SSR（Server-Side Rendering）技术，在 Serverless、SEO 等场景中已经占领了一块领地。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;stateless&#34;&gt;Stateless&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;无状态&lt;/strong&gt;：无状态是 REST 的一条核心原则，部分开发者在做服务接口规划时，觉得 REST 风格的服务怎么设计都感觉别扭，很有可能的一种原因是在服务端持有着比较重的状态。REST 希望服务器不要去负责维护状态，每一次从客户端发送的请求中，应包括所有的必要的上下文信息，会话信息也由客户端负责保存维护，服务端依据客户端传递的状态来执行业务处理逻辑，驱动整个应用的状态变迁。客户端承担状态维护职责以后，会产生一些新的问题，譬如身份认证、授权等可信问题，它们都应有针对性的解决方案（这部分内容可参见“&lt;a href=&#34;http://icyfenix.cn/architect-perspective/general-architecture/system-security&#34;&gt;安全架构&lt;/a&gt;”的内容）。
但必须承认的现状是，目前大多数的系统都达不到这个要求，往往越复杂、越大型的系统越是如此。服务端无状态可以在分布式计算中获得非常高价值的好处，但大型系统的上下文状态数量完全可能膨胀到让客户端在每次请求时提供变得不切实际的程度，在服务端的内存、会话、数据库或者缓存等地方持有一定的状态成为一种是事实上存在，并将长期存在、被广泛使用的主流的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;cacheability&#34;&gt;Cacheability&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;可缓存&lt;/strong&gt;：无状态服务虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。“降低网络性”的通俗解释是某个功能如果使用有状态的设计只需要一次（或少量）请求就能完成，使用无状态的设计则可能会需要多次请求，或者在请求中带有额外冗余的信息。为了缓解这个矛盾，REST 希望软件系统能够如同万维网一样，允许客户端和中间的通讯传递者（譬如代理）将部分服务端的应答缓存起来。当然，为了缓存能够正确地运作，服务端的应答中必须明确地或者间接地表明本身是否可以进行缓存、可以缓存多长时间，以避免客户端在将来进行请求的时候得到过时的数据。运作良好的缓存机制可以减少客户端、服务器之间的交互，甚至有些场景中可以完全避免交互，这就进一步提高了性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;layered-system&#34;&gt;Layered System&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分层系统&lt;/strong&gt;：这里所指的并不是表示层、服务层、持久层这种意义上的分层。而是指客户端一般不需要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样也便于缓存、伸缩和安全策略的部署。该原则的典型的应用是内容分发网络（Content Distribution Network，CDN）。如果你是通过网站浏览到这篇文章的话，你所发出的请求一般（假设你在中国国境内的话）并不是直接访问位于 GitHub Pages 的源服务器，而是访问了位于国内的 CDN 服务器，但作为用户，你完全不需要感知到这一点。我们将在“&lt;a href=&#34;http://icyfenix.cn/architect-perspective/general-architecture/diversion-system&#34;&gt;透明多级分流系统&lt;/a&gt;”中讨论如何构建自动的、可缓存的分层系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;uniform-interface-1&#34;&gt;Uniform Interface&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;统一接口&lt;/strong&gt;：这是 REST 的另一条核心原则，REST 希望开发者面向资源编程，希望软件系统设计的重点放在抽象系统该有哪些资源上，而不是抽象系统该有哪些行为（服务）上。这条原则你可以类比计算机中对文件管理的操作来理解，管理文件可能会进行创建、修改、删除、移动等操作，这些操作数量是可数的，而且对所有文件都是固定的、统一的。如果面向资源来设计系统，同样会具有类似的操作特征，由于 REST 并没有设计新的协议，所以这些操作都借用了 HTTP 协议中固有的操作命令来完成。
统一接口也是 REST 最容易陷入争论的地方，基于网络的软件系统，到底是面向资源更好，还是面向服务更合适，这事情哪怕是很长时间里都不会有个定论，也许永远都没有。但是，已经有一个基本清晰的结论是：&lt;strong&gt;面向资源编程的抽象程度通常更高&lt;/strong&gt;。抽象程度高意味着坏处是往往距离人类的思维方式更远，而好处是往往通用程度会更好。用这样的语言去诠释 REST，大概本身就挺抽象的。&lt;/p&gt;
&lt;p&gt;譬如，几乎每个系统都有的登录和注销功能，如果你理解成登录对应于 login()服务，注销对应于 logout()服务这样两个独立服务，这是“符合人类思维”的；如果你理解成登录是 PUT Session，注销是 DELETE Session，这样你只需要设计一种“Session 资源”即可满足需求，甚至以后对 Session 的其他需求，如查询登陆用户的信息，就是 GET Session 而已，其他操作如修改用户信息等都可以被这同一套设计囊括在内，这便是“抽象程度更高”带来的好处。
想要在架构设计中合理恰当地利用统一接口，Fielding 建议系统应能做到每次请求中都包含资源的 ID，所有操作均通过资源 ID 来进行；建议每个资源都应该是自描述的消息；建议通过超文本来驱动应用状态的转移。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;code-on-demandhttpsenwikipediaorgwikicode_on_demand&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Code_on_demand&#34;&gt;Code-On-Demand&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;按需代码&lt;/strong&gt;：按需代码被 Fielding 列为一条可选原则。它是指任何按照客户端（譬如浏览器）的请求，将可执行的软件程序从服务器发送到客户端的技术，按需代码赋予了客户端无需事先知道所有来自服务端的信息应该如何处理、如何运行的宽容度。举个具体例子，以前的&lt;a href=&#34;https://en.wikipedia.org/wiki/Java_applet&#34;&gt;Java Applet&lt;/a&gt;技术，今天的&lt;a href=&#34;https://en.wikipedia.org/wiki/WebAssembly&#34;&gt;WebAssembly&lt;/a&gt;等都属于典型的按需代码，蕴含着具体执行逻辑的代码是存放在服务端，只有当客户端请求了某个 Java Applet 之后，代码才会被传输并在客户端机器中运行，结束后通常也会随即在客户端中被销毁掉。将按需代码列为可选原则的原因并非是它特别难以达到，而更多是出于必要性和性价比的实际考虑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;richardson-maturity-modelhttpsmartinfowlercomarticlesrichardsonmaturitymodelhtml&#34;&gt;&lt;a href=&#34;https://martinfowler.com/articles/richardsonMaturityModel.html&#34;&gt;Richardson Maturity Model&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Richardson 将服务接口“REST 的程度”从低到高，分为 0 至 3 级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Swamp of &lt;a href=&#34;https://en.wikipedia.org/wiki/Plain_Old_XML&#34;&gt;Plain Old XML&lt;/a&gt;：完全不 REST。另外，关于 Plain Old XML 这说法，SOAP 表示感觉有被冒犯到。&lt;/li&gt;
&lt;li&gt;Resources：开始引入资源的概念。&lt;/li&gt;
&lt;li&gt;HTTP Verbs：引入统一接口，映射到 HTTP 协议的方法上。&lt;/li&gt;
&lt;li&gt;Hypermedia Controls：超媒体控制在本文里面的说法是“超文本驱动”，在 Fielding 论文里的说法是“Hypertext As The Engine Of Application State，HATEOAS”，其实都是指同一件事情。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设你是一名软件工程师，接到需求（原文中的需求复杂一些，这里简化了）的 UserStory 描述是这样的：&lt;/p&gt;
&lt;h2 id=&#34;医生预约系统&#34;&gt;医生预约系统&lt;/h2&gt;
&lt;p&gt;作为一名病人，我想要从系统中得知指定日期内我熟悉的医生是否具有空闲时间，以便于我向该医生预约就诊。&lt;/p&gt;
&lt;h3 id=&#34;level-0&#34;&gt;Level 0&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;医院开放了一个&lt;code&gt;/appointmentService&lt;/code&gt;的 Web API，传入日期、医生姓名作为参数，可以得到该时间段该名医生的空闲时间，该 API 的一次 HTTP 调用如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#008b45&#34;&gt;POST&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;/appointmentService?action=query&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt;

{date: &amp;#34;2020-03-04&amp;#34;, doctor: &amp;#34;mjones&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后服务器会传回一个包含了所需信息的回应：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;OK&lt;/span&gt;

[
	{start:&amp;#34;14:00&amp;#34;, end: &amp;#34;14:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;},
	{start:&amp;#34;16:00&amp;#34;, end: &amp;#34;16:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;}
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;得到了医生空闲的结果后，我觉得 14:00 的时间比较合适，于是进行预约确认，并提交了我的基本信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#008b45&#34;&gt;POST&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;/appointmentService?action=confirm&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt;

{
	appointment: {date: &amp;#34;2020-03-04&amp;#34;, start:&amp;#34;14:00&amp;#34;, doctor: &amp;#34;mjones&amp;#34;},
	patient: {name: icyfenix, age: 30, ……}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果预约成功，那我能够收到一个预约成功的响应：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;OK&lt;/span&gt;

{
	code: 0,
	message: &amp;#34;Successful confirmation of appointment&amp;#34;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果发生了问题，譬如有人在我前面抢先预约了，那么我会在响应中收到某种错误信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;OK&lt;/span&gt;

{
	code: 1
	message: &amp;#34;doctor not available&amp;#34;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到此，整个预约服务宣告完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;level-1&#34;&gt;Level 1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;第 0 级是 RPC 的风格，如果需求永远不会变化，也不会增加，那它完全可以良好地工作下去。但是，如果你不想为预约医生之外的其他操作、为获取空闲时间之外的其他信息去编写额外的方法，或者改动现有方法的接口，那还是应该考虑一下如何使用 REST 来抽象资源。&lt;/p&gt;
&lt;p&gt;通往 REST 的第一步是引入资源的概念，在 API 中基本的体现是围绕着资源而不是过程来设计服务，说的直白一点，可以理解为服务的 Endpoint 应该是一个名词而不是动词。此外，每次请求中都应包含资源的 ID，所有操作均通过资源 ID 来进行，譬如，获取医生指定时间的空闲档期：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#008b45&#34;&gt;POST&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;/doctors/mjones&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt;

{date: &amp;#34;2020-03-04&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后服务器传回一组包含了 ID 信息的档期清单，注意，ID 是资源的唯一编号，有 ID 即代表“医生的档期”被视为一种资源：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;OK&lt;/span&gt;

[
	{id: 1234, start:&amp;#34;14:00&amp;#34;, end: &amp;#34;14:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;},
	{id: 5678, start:&amp;#34;16:00&amp;#34;, end: &amp;#34;16:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;}
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我还是觉得 14:00 的时间比较合适，于是又进行预约确认，并提交了我的基本信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#008b45&#34;&gt;POST&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;/schedules/1234&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt;

{name: icyfenix, age: 30, ……}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;后面预约成功或者失败的响应消息在这个级别里面与之前一致，就不重复了。比起第 0 级，第 1 级的特征是引入了资源，通过资源 ID 作为主要线索与服务交互，但第 1 级至少还有三个问题并没有解决：一是只处理了查询和预约，如果我临时想换个时间，要调整预约，或者我的病忽然好了，想删除预约，这都需要提供新的服务接口。二是处理结果响应时，只能靠着结果中的&lt;code&gt;code&lt;/code&gt;、&lt;code&gt;message&lt;/code&gt;这些字段做分支判断，每一套服务都要设计可能发生错误的 code，这很难考虑全面，而且也不利于对某些通用的错误做统一处理；三是并没有考虑认证授权等安全方面的内容，譬如要求只有登陆用户才允许查询医生档期时间，某些医生可能只对 VIP 开放，需要特定级别的病人才能预约，等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;level-2&#34;&gt;Level 2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;第 1 级遗留三个问题都可以靠引入统一接口来解决。HTTP 协议的七个标准方法是经过精心设计的，只要架构师的抽象能力够用，它们几乎能涵盖资源可能遇到的所有操作场景。REST 的做法是把不同业务需求抽象为对资源的增加、修改、删除等操作来解决第一个问题；使用 HTTP 协议的 Status Code，可以涵盖大多数资源操作可能出现的异常，而且 Status Code 可以自定义扩展，以此解决第二个问题；依靠 HTTP Header 中携带的额外认证、授权信息来解决第三个问题，这个在实战中并没有体现，请参考安全架构中的“&lt;a href=&#34;http://icyfenix.cn/architect-perspective/general-architecture/system-security/credentials&#34;&gt;凭证&lt;/a&gt;”相关内容。&lt;/p&gt;
&lt;p&gt;按这个思路，获取医生档期，应采用具有查询语义的 GET 操作进行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#008b45&#34;&gt;GET&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;/doctors/mjones/schedule?date=2020-03-04&amp;amp;status=open&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后服务器会传回一个包含了所需信息的回应：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;OK&lt;/span&gt;

[
	{id: 1234, start:&amp;#34;14:00&amp;#34;, end: &amp;#34;14:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;},
	{id: 5678, start:&amp;#34;16:00&amp;#34;, end: &amp;#34;16:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;}
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我仍然觉得 14:00 的时间比较合适，于是又进行预约确认，并提交了我的基本信息，用以创建预约，这是符合 POST 的语义的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#008b45&#34;&gt;POST&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;/schedules/1234&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt;

{name: icyfenix, age: 30, ……}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果预约成功，那我能够收到一个预约成功的响应：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;201&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Created&lt;/span&gt;

Successful confirmation of appointment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果发生了问题，譬如有人在我前面抢先预约了，那么我会在响应中收到某种错误信息：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;409&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Conflict&lt;/span&gt;

doctor not available
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;level-3&#34;&gt;Level 3&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;第 2 级是目前绝大多数系统所到达的 REST 级别，但仍不是完美的，至少还存在一个问题：你是如何知道预约 mjones 医生的档期是需要访问&lt;code&gt;/schedules/1234&lt;/code&gt;这个服务 Endpoint 的？也许你甚至第一时间无法理解为何我会有这样的疑问，这当然是程序代码写的呀！但 REST 并不认同这种已烙在程序员脑海中许久的想法。RMM 中的 Hypermedia Controls、Fielding 论文中的 HATEOAS 和现在提的比较多的“超文本驱动”，所希望的是除了第一个请求是有你在浏览器地址栏输入所驱动之外，其他的请求都应该能够自己描述清楚后续可能发生的状态转移，由超文本自身来驱动。所以，当你输入了查询的指令之后：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#008b45&#34;&gt;GET&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;/doctors/mjones/schedule?date=2020-03-04&amp;amp;status=open&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;服务器传回的响应信息应该包括诸如如何预约档期、如何了解医生信息等可能的后续操作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HTTP&lt;/span&gt;/&lt;span style=&#34;color:#b452cd&#34;&gt;1.1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;200&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;OK&lt;/span&gt;

{
	schedules：[
		{
			id: 1234, start:&amp;#34;14:00&amp;#34;, end: &amp;#34;14:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;,
			links: [
				{rel: &amp;#34;comfirm schedule&amp;#34;, href: &amp;#34;/schedules/1234&amp;#34;}
			]
		},
		{
			id: 5678, start:&amp;#34;16:00&amp;#34;, end: &amp;#34;16:50&amp;#34;, doctor: &amp;#34;mjones&amp;#34;,
			links: [
				{rel: &amp;#34;comfirm schedule&amp;#34;, href: &amp;#34;/schedules/5678&amp;#34;}
			]
		}
	],
	links: [
		{rel: &amp;#34;doctor info&amp;#34;, href: &amp;#34;/doctors/mjones/info&amp;#34;}
	]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果做到了第 3 级 REST，那服务端的 API 和客户端也是完全解耦的，你要调整服务数量，或者同一个服务做 API 升级将会变得非常简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;deficiencies-and-controversies&#34;&gt;Deficiencies and controversies&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面向资源的编程思想只适合做 CRUD，面向过程、面向对象编程才能处理真正复杂的业务逻辑&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;面向过程编程时，为什么要以算法和处理过程为中心，输入数据，输出结果？当然是为了符合计算机世界中主流的交互方式。&lt;/li&gt;
&lt;li&gt;面向对象编程时，为什么要将数据和行为统一起来、封装成对象？当然是为了符合现实世界的主流的交互方式。&lt;/li&gt;
&lt;li&gt;面向资源编程时，为什么要将数据（资源）作为抽象的主体，把行为看作是统一的接口？当然是为了符合网络世界的主流的交互方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于需要直接控制传输，如二进制细节、编码形式、报文格式、连接方式等细节的场景中，REST 确实不合适，这些场景往往存在于服务集群的内部节点之间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST 不利于事务支持&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题首先要看你怎么看待“事务（Transaction）”这个概念。如果“事务”指的是数据库那种的狭义的刚性 ACID 事务，那除非完全不持有状态，否则分布式系统本身与此就是有矛盾的（CAP 不可兼得），这是分布式的问题而不是 REST 的问题。如果“事务”是指通过服务协议或架构，在分布式服务中，获得对多个数据同时提交的统一协调能力（&lt;strong&gt;2PC/3PC&lt;/strong&gt;），譬如&lt;a href=&#34;http://docs.oasis-open.org/ws-tx/wstx-wsat-1.1-spec-errata-os/wstx-wsat-1.1-spec-errata-os.html&#34;&gt;WS-AtomicTransaction&lt;/a&gt;、&lt;a href=&#34;http://docs.oasis-open.org/ws-tx/wstx-wscoor-1.1-spec-errata-os/wstx-wscoor-1.1-spec-errata-os.html&#34;&gt;WS-Coordination&lt;/a&gt;这样的功能性协议，这 REST 确实不支持，假如你已经理解了这样做的代价，仍决定要这样做的话，&lt;strong&gt;Web Service 是比较好的选择&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST 没有传输可靠性支持&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 HTTP 中你发送出去一个请求，通常会收到一个与之相对的响应，譬如 HTTP/1.1 200 OK 或者 HTTP/1.1 404 Not Found 诸如此类的。但如果你没有收到任何响应，那就无法确定消息到底是没有发送出去，抑或是没有从服务端返回回来，这其中的关键差别是服务端到底是否被触发了某些处理？应对传输可靠性最简单粗暴的做法是把消息再重发一遍。这种简单处理能够成立的前提是服务应具有&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%AA%E7%AD%89&#34;&gt;幂等性&lt;/a&gt;（Idempotency），即服务被重复执行多次的效果与执行一次是相等的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST 缺乏对资源进行“部分”和“批量”的处理能力&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;譬如你仅仅想获得某个用户的姓名，RPC 风格中可以设计一个“getUsernameById”的服务，返回一个字符串，尽管这种服务的通用性实在称不上“设计”二字，但确实可以工作；而 REST 风格中你将向服务端请求整个用户对象，然后丢弃掉返回的结果中该用户除用户名外的其他属性，这便是一种“过度获取”（&lt;a href=&#34;https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching&#34;&gt;Overfetching&lt;/a&gt;）。REST 的应对手段是通过位于中间节点或客户端的缓存来缓解这种问题，但此缺陷的本质是由于 HTTP 协议完全没有对请求资源的结构化描述能力（但有非结构化的部分内容获取能力，即今天多用于断点续传的&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Range_requests&#34;&gt;Range Header&lt;/a&gt;），所以返回资源的哪些内容、以什么数据类型返回等等，都不可能得到协议层面的支持，要做你就只能自己在 GET 方法的 Endpoint 上设计各种参数来实现。&lt;/p&gt;
&lt;p&gt;譬如你准备把某个用户的名字增加一个“VIP”前缀，提交一个 PUT 请求修改这个用户的名称即可，而你要给 1000 个用户加 VIP 时，如果真的去调用 1000 次 PUT，浏览器会回应你 HTTP/1.1 429 Too Many Requests，老板则会揍你一顿。此时，你就不得不先创建一个（如名为“VIP-Modify-Task”）任务资源，把 1000 个用户的 ID 交给这个任务，最后驱动任务进入执行状态。又譬如你去网店买东西，下单、冻结库存、支付、加积分、扣减库存这一系列步骤会涉及到多个资源的变化，你可能面临不得不创建一种“事务”的抽象资源，或者用某种具体的资源（譬如“结算单”）贯穿这个过程的始终，每次操作其他资源时都带着事务或者结算单的 ID。HTTP 协议由于本身的无状态性，会相对不适应（并非不能够）处理这类业务场景。&lt;/p&gt;
&lt;p&gt;目前，一种理论上较优秀的可以解决以上这几类问题的方案是&lt;a href=&#34;https://graphql.cn/&#34;&gt;GraphQL&lt;/a&gt;，这是由 Facebook 提出并开源的一种面向资源 API 的数据查询语言，如同 SQL 一样，挂了个“查询语言”的名字，但其实 CRUD 都有涉猎。比起依赖 HTTP 无协议的 REST，GraphQL 可以说是另一种“有协议”的、更彻底地面向资源的服务方式。然而凡事都有两面，离开了 HTTP，它又面临着几乎所有 RPC 框架所遇到的那个如何推广交互接口的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Roy Thomas Fielding, 2000, &lt;a href=&#34;https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&#34;&gt;Architectural Styles and the Design of Network-based Software Architectures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm&#34;&gt;Representational State Transfer (REST)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Theodor Holm Nelson, 1967, &lt;a href=&#34;https://archive.org/details/SelectedPapers1977&#34;&gt;Brief Words on the Hypertext&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cloud.google.com/apis/design&#34;&gt;Google API Design Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Google, &lt;a href=&#34;https://cloud.google.com/apis/design/custom_methods&#34;&gt;Custom methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Leonard Richardson, &lt;a href=&#34;https://book.douban.com/subject/22139962/&#34;&gt;RESTful Web APIs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Leonard Richardson, &lt;a href=&#34;https://book.douban.com/subject/2054201/&#34;&gt;RESTful Web Services&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/representational-state-transfer/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Transactions</title>
        <link>https://www.openheart.icu/cs/transactions/</link>
        <pubDate>Wed, 01 Dec 2021 14:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/transactions/</guid>
        <description>42th openheart https://www.openheart.icu/cs/transactions/ -&lt;h1 id=&#34;acid&#34;&gt;ACID&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;事务处理几乎在每一个信息系统中都会涉及，它存在的意义是为了保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾，即数据状态的&lt;strong&gt;一致性&lt;/strong&gt;（&lt;strong&gt;C&lt;/strong&gt;onsistency）。&lt;/p&gt;
&lt;p&gt;按照数据库的经典理论，要达成这个目标，需要三方面共同努力来保障。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt;（&lt;strong&gt;A&lt;/strong&gt;tomic）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt;（&lt;strong&gt;I&lt;/strong&gt;solation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt;（&lt;strong&gt;D&lt;/strong&gt;urability）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;场景事例&lt;/p&gt;
&lt;p&gt;Fenix&amp;rsquo;s Bookstore 是一个在线书店。每当一本书被成功售出时，需要确保以下三件事情被正确地处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户的账号扣减相应的商品款项。&lt;/li&gt;
&lt;li&gt;商品仓库中扣减库存，将商品标识为待配送状态。&lt;/li&gt;
&lt;li&gt;商家的账号增加相应的商品款项。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;local-transaction&#34;&gt;Local Transaction&lt;/h1&gt;
&lt;h2 id=&#34;atomicity--durability&#34;&gt;Atomicity &amp;amp; Durability&lt;/h2&gt;
&lt;h3 id=&#34;commit-logging&#34;&gt;Commit Logging&lt;/h3&gt;
&lt;p&gt;Crash Recovery 通常采用Commit Logging（提交日志）方式，只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In any database context, a &amp;ldquo;commit&amp;rdquo; is the application of a single transaction to the DB. A commit log is a record of transactions. It&amp;rsquo;s used to keep track of what&amp;rsquo;s happening, and help with e.g. disaster recovery - generally, all commits are written to the log before being applied, so transactions that were in flight when the server went down can be recovered and re-applied by checking the log.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Logging 保障数据持久性、原子性的原理并不难理解：首先，日志一旦成功写入 Commit Record，那整个事务就是成功的，即使真正修改数据时崩溃了，重启后根据已经写入磁盘的日志信息恢复现场、继续修改数据即可，这保证了持久性；其次，如果日志没有成功写入 Commit Record 就发生崩溃，那整个事务就是失败的，系统重启后会看到一部分没有 Commit Record 的日志，那将这部分日志标记为回滚状态即可，整个事务就像完全没好有发生过一样，这保证了原子性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有一些数据库就是直接采用 Commit Logging 机制来实现事务的，譬如较具代表性的是阿里的&lt;a href=&#34;https://zh.wikipedia.org/wiki/OceanBase&#34;&gt;OceanBase&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;shadow-paging&#34;&gt;Shadow Paging&lt;/h3&gt;
&lt;p&gt;通过日志实现事务的原子性和持久性是当今的主流方案，但并不是唯一的选择。除日志外，还有另外一种称为“&lt;a href=&#34;https://en.wikipedia.org/wiki/Shadow_paging&#34;&gt;Shadow Paging&lt;/a&gt;”（有译为“影子分页”）的事务实现机制，常用的轻量级数据库 SQLite Version 3 采用的事务机制就是 Shadow Paging。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Shadow Paging 的大体思路是对数据的变动会写到硬盘的数据中，但并不是直接就地修改原先的数据，而是先将数据复制一份副本，保留原数据，修改副本数据。在事务过程中，被修改的数据会同时存在两份，一份是修改前的数据，一份是修改后的数据，这也是“影子”（Shadow）这个名字的由来。当事务成功提交，所有数据的修改都成功持久化之后，最后一步是去修改数据的引用指针，将引用从原数据改为新复制出来修改后的副本，最后的“修改指针”这个操作将被认为是原子操作，现代磁盘的写操作可以认为在硬件上保证了不会出现“改了半个值”的现象。所以 Shadow Paging 也可以保证原子性和持久性。Shadow Paging 实现事务要比 Commit Logging 更加&lt;strong&gt;简单&lt;/strong&gt;，但涉及隔离性与并发锁时，Shadow Paging 实现的事务&lt;strong&gt;并发能力就相对有限&lt;/strong&gt;，因此在高性能的数据库中应用不多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;write-ahead-logging&#34;&gt;Write-Ahead Logging&lt;/h3&gt;
&lt;p&gt;但是，Commit Logging 存在一个巨大的先天缺陷：所有对数据的真实修改都必须发生在事务提交以后，即日志写入了 Commit Record 之后。&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在此之前，即使磁盘 I/O 有足够空闲、即使某个事务修改的数据量非常庞大，占用了大量的内存缓冲区，无论有何种理由，都决不允许在事务提交之前就修改磁盘上的数据，这一点是 Commit Logging 成立的前提，却对提升数据库的性能十分不利。所以，ARIES 提出了“Write-Ahead Logging”的日志改进方案，所谓“提前写入”（Write-Ahead），就是允许在事务提交之前，提前写入变动数据的意思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Write-Ahead Logging 先将何时写入变动数据，按照事务提交时点为界，划分为 FORCE 和 STEAL 两类情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FORCE&lt;/strong&gt;：当事务提交后，要求变动数据必须同时完成写入则称为 FORCE，如果不强制变动数据必须同时完成写入则称为 NO-FORCE。现实中绝大多数数据库采用的都是 NO-FORCE 策略，因为只要有了日志，变动数据随时可以持久化，从优化磁盘 I/O 性能考虑，没有必要强制数据写入立即进行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;STEAL&lt;/strong&gt;：在事务提交前，允许变动数据提前写入则称为 STEAL，不允许则称为 NO-STEAL。从优化磁盘 I/O 性能考虑，允许数据提前写入，有利于利用空闲 I/O 资源，也有利于节省数据库缓存区的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Logging 允许 NO-FORCE，但不允许 STEAL。因为假如事务提交前就有部分变动数据写入磁盘，那一旦事务要回滚，或者发生了崩溃，这些提前写入的变动数据就都成了错误。&lt;/p&gt;
&lt;p&gt;Write-Ahead Logging 允许 NO-FORCE，也允许 STEAL，它给出的解决办法是增加了另一种被称为 Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除。Undo Log 现在一般被翻译为“回滚日志”，此前记录的用于崩溃恢复时重演数据变动的日志就相应被命名为 Redo Log，一般翻译为“重做日志”。由于 Undo Log 的加入，Write-Ahead Logging 在崩溃恢复时会执行以下三个阶段的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分析阶段&lt;/strong&gt;（Analysis）：该阶段从最后一次检查点（Checkpoint，可理解为在这个点之前所有应该持久化的变动都已安全落盘）开始扫描日志，找出所有没有 End Record 的事务，组成待恢复的事务集合，这个集合至少会包括 Transaction Table 和 Dirty Page Table 两个组成部分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重做阶段&lt;/strong&gt;（Redo）：该阶段依据分析阶段中产生的待恢复的事务集合来重演历史（Repeat History），具体操作为：找出所有包含 Commit Record 的日志，将这些日志修改的数据写入磁盘，写入完成后在日志中增加一条 End Record，然后移除出待恢复事务集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回滚阶段&lt;/strong&gt;（Undo）：该阶段处理经过分析、重做阶段后剩余的恢复事务集合，此时剩下的都是需要回滚的事务，它们被称为 Loser，根据 Undo Log 中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些 Loser 事务的目的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;重做阶段和回滚阶段的操作都应该设计为幂等的。FORCE 和 STEAL 的四种组合关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAnYAAAD3CAMAAACn+emfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDNkVCQjZENkRDQjExMUVBQjJFNUFDQzNEQ0I4MEI1RiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDNkVCQjZEN0RDQjExMUVBQjJFNUFDQzNEQ0I4MEI1RiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkM2RUJCNkQ0RENCMTExRUFCMkU1QUNDM0RDQjgwQjVGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkM2RUJCNkQ1RENCMTExRUFCMkU1QUNDM0RDQjgwQjVGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+k8yiTAAAADNQTFRFkpKSS0tL3t7eXl5eenp67+/v9/f3sLCwzMzMp6en39/fxsbGhoaGMjIymcz//8zM////7dxksgAACUhJREFUeNrs3YmaojgUhmEEEXqmj8X9X+1kIZKwKFAJEeY79XSpWGXr329WmbHoKOrwKoiAgh0FO4qCHQU7ioIdBTuKgh0FO4qCHQU7CnYUdR125a2q1V97K7vucReR4QkU6lbbtWKqqgtz2f/c/dH1v7S9WvO3xH/cPHWN/DKwk8Y+07pST7q8mWeuqpH2cTcvoPC+978yOrLtLyzUYzfRHzcbuyvkl4OdepZF/0e3paZ/Jq8nP355jRTey97eWJskj5uP3QXyy8FOddnqmZrG2qk2W7gxwj370ct73Kt/zM/ujS38h4n1uPnYXSC/DOz+qqFAPVPdeZvY+lFC52mv9i/PzCHMOFLYQ/ti0zMg+4txHzcbuyvkl4FdoeYjf6exqWt6xjptVY2ZKDf7edi5dvzHzcTuCvnlYKdfhzdIuNjcdHn08lRfXtuZ824e/ZIr+uNmYneB/LKwG6bFZsaqm2njTV/Dl6cHD7ti38+jrqaxxXjcTOzOn18Wdqp/NhsArrnYV6ZuNTOduV286+/7YivUY9oBKe7jZmR3/vzysKur6XanbrMmtWDqKv/avSgd72syu31qUiR43IzsTp8fb45RGQp2FOwo2FEU7CjYURTsKNhRFOwo2FFUenZymcrzz3PV/GAHuyuyO+Kf5pm88rG7Zn6wgx3sYAc7YoMd7GAHO9jBDnawgx3syA92sIMd7MgPdrCDHexgR2ywgx3sYEdssIMd7GAHO/KDHexgBzvygx3sYAc72BEb7GAHO9gRG+xgBzvYwY78YAc72MGO/GAHO9jBDnbEBjvYwQ52xAY72MEOdrAjP9jBDnawO2t++n933V9TX8/lnxXYwS5GfjKQm7B7/R/YYQe7+PkFrHx2/qX3OQCwg93v8hthEn3gOdyaYUlvB7sIg6z35ykSDLOwg13Kud1r5HSDrMzd92GMhR3s9vV2bpBd7O3YQIFdkt7OfTHIbmEXjgOyvql+LbvhI+REfXXLPytRVrLL7GS0zt3ErpCm68qbPtSqF3QrX8d1Ffo+ddm+jtwf/VV1pa6GQ9/KbpJXZHZH5jf61MKA3fRTDSVObyeDrHl2T9nFrqptbI0OpzAJ6eN9gK2OtdHfzBF983FXv1JXVV1X48S+vrd7Pwnexe7Y/AJWPjv/8vNnk27o7RaWFE6j7GSnmqSOzbZYE4kXW5+MvmWO6NuNa9JnYBc2zw/Dwi52h+U3wiT6QDfcmmEZYd8u2E8Zs3zfhj+wu5U6ssa2U5dJH5tprPqifcVWu2S/n10Yomu6sdkdlp94f8xPecNsJHZHnQpQ3P5IoWPrc+rTG93U6blBYgirn5s039vbydyIEZfdgfmFI6cbZGXuvk+f/52fXVnIn5nYxEyQ/dj6jPzYvn2QlfC9nY87nHvYHZdf0Nu5QXaxt+u+u7cr9VprGCTC1voaJExrVc2zHaYvZ2AX7LInWckemN+4t3Nfpxxky2FabKfEjajV2fyUuNXrthMtKURkxE7Wu1vL7tD8JNg/WWIno3Xu79glON9Oh6EaYeFW+dMNgMLfACjUzRNtoIh7Ozspu6Pym/R2MsiaZ9dt3kAZLcKewbo23vl2JoxGptud7tqw3WlXYnZ3yt/udGPGl65kg95uyzC7mt2R+YW93cKSwmmUHeyCKxJsnXC+3fpBwqcmwcXZ3hyb7NsF+yljlm8XsmvZPYN3InhPllMBUp0KMEyIJ5tQsINdQnZBH+cPspxvB7sD2HlbnZxvB7uDB1lhbge75OwmE7kE59vBDnbvNlBEninOt4Md7N5sF0vwX47FO98OdrB7P8iGJ95FOt8OdrDLcCoAscEOdrCDHbHBDnawgx3syA92sIMd7MgPdrCDHexgR2ywgx3sYEdssIMd7GAHO/KDHexgBzvygx3sYAc72BEb7GAHO9gRG+xgBzvYwQ52sIMd7GBHfrCDHexgBztigx3sYAc7YoMd7GAHO9jBDnawg93wkq5SudhdMz/Ywe6K7H6S1zEDUS5218wPdrCDHexgR2ywgx3sYAc72MEOdrCDHfnBDnawgx35wQ52sIMd7IgNdrCDHeyIDXawgx3sYEd+sIMd7GBHfrCDHexgBztigx3sYAc7YoMd7GAHO9iRH+xgBzvYkR/sYAc72MGO2GAHO9jBjthgBzvYwQ525Ac72MEOduQHO9jBDnawIzbYwQ52sCM22MEOdrCDHfmdj13/eWjuVn8Adp8yeH2S3Lqkfp+f7LhnA7vCvBh17+NuL/sj94e62qort7Krq+HQb9kFsYi9emZ2qfLzPrNwgml035TkRnbBxyPKcDu4LzI7FYuuulKplDf1zRxppem6RlqdYmvuS9Lbyel7u7T5ySJC+ZlwlAWun9kFV2S49O4LDb4RvI2dvdRpmWs6qfLWdEOkkdgF36/Q2yXNz0Mm7tukf5NJH7e1txtd6eHJhF303q5Ppq6KITbTWKOyC5uiDXLDjOWL2aXJTxZuiddm47CzHZjvT7ouPbvyVriAXoOEa8hubtL8vreTMJzh6+zskuQn4o+ytpHOLDDe3VrNLujj/EE2GFU/fsb4piXFrfRjcxl5scUaZE0cr6nwJXq7dPlJ2EoXO0J528dtZae+BUuKNX3c7wdZ01pV82z7GXFkdsMA8bN+UnemQTZefv7EdzQ7Ga1kUwyycsjcbjQlbqWquwRLCpuUx06uspKNnZ8M5OYw+ffIaLkmP/Pd5OolhTU3s5J9cZRY7OrKBOU2AAq9BRV/A0Vsnlfat0uZnyxtF4vM9HKf9gdWb6CIdAtLCglWuRHYeduddiWmIwu3O1WuMVayo0F2dWf33eyS5Le0dg1jG4+4MtrX27pdLN4YGy4ivOnf2d6TFa8pSt9sT7ykSJrfhN3wtoQnT2bfxfj5zSAr3eK+3duFLKcCXOs9WU4FgB35wQ52sIMd+cEOdrCDHeyIDXawgx3siA12sIMd7GBHfrCDHexgR36wgx3sYAc7YoMd7GAHO2KDHexgBzvYkR/sYAc72JEf7GAHO9jBjthgBzvYwY7YYAc72MEOduQHO9jBDnbkBzvYwQ52sCM22MEOdrAjNtjBDnawgx3sYAc72MGO/GAHO9jBDnZp/7qrVC5218wPdrC7HjuKmivYUbCjYEdRsKNgR1Gwo2BHUbCjYEdRsKNgR/1v6j8BBgBwlHBpFQqO/AAAAABJRU5ErkJggg==&#34; alt=&#34;force-steal&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;isolation&#34;&gt;Isolation&lt;/h2&gt;
&lt;h3 id=&#34;lock-synchronizationpessimistic-locking&#34;&gt;Lock synchronization(Pessimistic Locking)&lt;/h3&gt;
&lt;p&gt;此处的三种加锁都属于悲观加锁策略，即认为如果不先做加锁再访问数据，就肯定会出现问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Write Lock&lt;/strong&gt;（写锁，也叫作排他锁，eXclusive Lock，简写为 X-Lock）：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Read Lock&lt;/strong&gt;（读锁，也叫作共享锁，Shared Lock，简写为 S-Lock）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有它自己一个事务加了读锁，允许直接将其升级为写锁，然后写入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Range Lock&lt;/strong&gt;（范围锁）：对于某个范围直接加排他锁，在这个范围内的数据不能被写入。加了范围锁后，不仅无法修改该范围内已有的数据，也不能在该范围内新增或删除任何数据，后者是一组排他锁的集合无法做到的。如下语句是典型的加范围锁的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; * &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; books &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; price &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;100&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FOR&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;UPDATE&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;optimistic-concurrency-control&#34;&gt;Optimistic Concurrency Control&lt;/h3&gt;
&lt;p&gt;乐观并发控制（OCC）的乐观加锁策略认为事务之间数据存在竞争是偶然情况，没有竞争才是普遍情况，这样就不应该在一开始就加锁，而是应当在出现竞争时再找补救措施。&lt;/p&gt;
&lt;h3 id=&#34;isolation-level&#34;&gt;Isolation Level&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Serializable&lt;/strong&gt;（可串行化）：&lt;code&gt;可串行&lt;/code&gt;化完全符合普通程序员对数据竞争加锁的理解，如果不考虑性能优化的话，对事务所有读、写的数据全都加上读锁、写锁和范围锁即可做到&lt;code&gt;可串行化&lt;/code&gt;（“即可”是简化理解，实际还是很复杂的，要分成 Expanding 和 Shrinking 两阶段去处理读锁、写锁与数据间的关系，称为&lt;a href=&#34;https://en.wikipedia.org/wiki/Two-phase_locking&#34;&gt;Two-Phase Lock&lt;/a&gt;，2PL）。但是，&lt;a href=&#34;https://en.wikipedia.org/wiki/Concurrency_control&#34;&gt;并发控制理论&lt;/a&gt;（Concurrency Control）决定了隔离程度与并发能力是相互抵触的，隔离程度越高，并发访问时的吞吐量就越低。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Specifies the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Statements cannot read data that has been modified but not yet committed by other transactions.&lt;/li&gt;
&lt;li&gt;No other transactions can modify data that has been read by the current transaction until the current transaction completes.&lt;/li&gt;
&lt;li&gt;Other transactions cannot insert new rows with key values that would fall in the range of keys read by any statements in the current transaction until the current transaction completes.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;SQL Server 在可重复读与可串行化中间还有一个Level叫做&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/sql/snapshot-isolation-in-sql-server&#34;&gt;SNAPSHOT&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction. The transaction can only recognize data modifications that were committed before the start of the transaction. Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction. The effect is as if the statements in a transaction get a snapshot of the committed data as it existed at the start of the transaction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Repeatable Read&lt;/strong&gt;（可重复读）： &lt;code&gt;可重复读&lt;/code&gt;对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。&lt;code&gt;可重复读&lt;/code&gt;比&lt;code&gt;可串行化&lt;/code&gt;弱化的地方在于&lt;a href=&#34;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Phantom_reads&#34;&gt;幻读问题&lt;/a&gt;（Phantom Reads），它是指在事务执行过程中，两个完全相同的范围查询得到了不同的结果集。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Specifies that statements cannot read data that has been modified but not yet committed by other transactions and that no other transactions can modify data that has been read by the current transaction until the current transaction completes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Read Committed&lt;/strong&gt;（读已提交）：&lt;code&gt;读已提交&lt;/code&gt;对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。&lt;code&gt;读已提交&lt;/code&gt;比&lt;code&gt;可重复读&lt;/code&gt;弱化的地方在于&lt;a href=&#34;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Non-repeatable_reads&#34;&gt;不可重复读问题&lt;/a&gt;（Non-Repeatable Reads），它是指在事务执行过程中，对同一行数据的两次查询得到了不同的结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;READ COMMITTED in SQL Server: Specifies that statements cannot read data that has been modified but not committed by other transactions. This prevents dirty reads. Data can be changed by other transactions between individual statements within the current transaction, resulting in nonrepeatable reads or phantom data. This option is the SQL Server default.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Read Uncommitted&lt;/strong&gt;（读未提交）：&lt;code&gt;读未提交&lt;/code&gt;对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。&lt;code&gt;读未提交&lt;/code&gt;比&lt;code&gt;读已提交&lt;/code&gt;弱化的地方在于&lt;a href=&#34;https://en.wikipedia.org/wiki/Isolation_(database_systems)#Dirty_reads&#34;&gt;脏读问题&lt;/a&gt;（Dirty Reads），它是指在事务执行过程中，一个事务读取到了另一个事务未提交的数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;READ UNCOMMITTED in SQL Server: Specifies that statements can read rows that have been modified by other transactions but not yet committed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;multi-version-concurrency-control&#34;&gt;Multi-Version Concurrency Control&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;除了都以锁来实现外，以上四种隔离级别还有另一个共同特点，就是幻读、不可重复读、脏读等问题都是由于一个事务在读数据过程中，受另外一个写数据的事务影响而破坏了隔离性，针对这种“一个事务读+另一个事务写”的隔离问题，近年来有一种名为“&lt;a href=&#34;https://en.wikipedia.org/wiki/Multiversion_concurrency_control&#34;&gt;多版本并发控制&lt;/a&gt;”（Multi-Version Concurrency Control，MVCC）的无锁优化方案被主流的商业数据库广泛采用。MVCC 是一种读取优化策略，它的“无锁”是特指读取时不需要加锁。MVCC 的基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的。在这句话中，“版本”是个关键词，你不妨将版本理解为数据库中每一行记录都存在两个看不见的字段：CREATE_VERSION 和 DELETE_VERSION，这两个字段记录的值都是事务 ID，事务 ID 是一个全局严格递增的数值，然后根据以下规则写入数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入数据时：CREATE_VERSION 记录插入数据的事务 ID，DELETE_VERSION 为空。&lt;/li&gt;
&lt;li&gt;删除数据时：DELETE_VERSION 记录删除数据的事务 ID，CREATE_VERSION 为空。&lt;/li&gt;
&lt;li&gt;修改数据时：将修改数据视为“删除旧数据，插入新数据”的组合，即先将原有数据复制一份，原有数据的 DELETE_VERSION 记录修改数据的事务 ID，CREATE_VERSION 为空。复制出来的新数据的 CREATE_VERSION 记录修改数据的事务 ID，DELETE_VERSION 为空。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时，如有另外一个事务要读取这些发生了变化的数据，将根据隔离级别来决定到底应该读取哪个版本的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离级别是&lt;code&gt;可重复读&lt;/code&gt;：总是读取 CREATE_VERSION 小于或等于当前事务 ID 的记录，在这个前提下，如果数据仍有多个版本，则取最新（事务 ID 最大）的。&lt;/li&gt;
&lt;li&gt;隔离级别是&lt;code&gt;读已提交&lt;/code&gt;：总是取最新的版本即可，即最近被 Commit 的那个版本的数据记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外两个隔离级别都没有必要用到 MVCC，因为&lt;code&gt;读未提交&lt;/code&gt;直接修改原始数据即可，其他事务查看数据的时候立刻可以看到，根本无须版本字段。&lt;code&gt;可串行化&lt;/code&gt;本来的语义就是要阻塞其他事务的读取操作，而 MVCC 是做读取时无锁优化的，自然就不会放到一起用。&lt;/p&gt;
&lt;p&gt;MVCC 是只针对“读+写”场景的优化，如果是两个事务同时修改数据，即“写+写”的情况，那就没有多少优化的空间了，此时加锁几乎是唯一可行的解决方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;global-transaction&#34;&gt;Global Transaction&lt;/h1&gt;
&lt;p&gt;此处的全局事务被限定为一种适用于单个服务使用多个数据源场景的事务解决方案。&lt;/p&gt;
&lt;h2 id=&#34;2-phase-commit&#34;&gt;2 Phase Commit&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;准备阶段&lt;/strong&gt;：又叫作投票阶段，在这一阶段，协调者询问事务的所有参与者是否准备好提交，参与者如果已经准备好提交则回复 Prepared，否则回复 Non-Prepared。这里所说的准备操作跟人类语言中通常理解的准备并不相同，对于数据库来说，准备操作是在重做日志中记录全部事务提交操作所要做的内容，它与本地事务中真正提交的区别只是暂不写入最后一条 Commit Record 而已，这意味着在做完数据持久化后并不立即释放隔离性，即仍继续持有锁，维持数据对其他非事务内观察者的隔离状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提交阶段&lt;/strong&gt;：又叫作执行阶段，协调者如果在上一阶段收到所有事务参与者回复的 Prepared 消息，则先自己在本地持久化事务状态为 Commit，在此操作完成后向所有参与者发送 Commit 指令，所有参与者立即执行提交操作；否则，任意一个参与者回复了 Non-Prepared 消息，或任意一个参与者超时未回复，协调者将自己的事务状态持久化为 Abort 之后，向所有参与者发送 Abort 指令，参与者立即执行回滚操作。对于数据库来说，这个阶段的提交操作应是很轻量的，仅仅是持久化一条 Commit Record 而已，通常能够快速完成，只有收到 Abort 指令时，才需要根据回滚日志清理已提交的数据，这可能是相对重负载的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4&#34;&gt;两段式提交&lt;/a&gt;（2 Phase Commit，2PC）协议，能够成功保证一致性还需要一些其他前提条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须假设网络在提交阶段的短时间内是可靠的，即提交阶段不会丢失消息。同时也假设网络通信在全过程都不会出现误差，即可以丢失消息，但不会传递错误的消息，目标并不是解决诸如&lt;a href=&#34;https://en.wikipedia.org/wiki/Byzantine_fault&#34;&gt;拜占庭将军&lt;/a&gt;一类的问题。两段式提交中投票阶段失败了可以补救（回滚），而提交阶段失败了无法补救（不再改变提交或回滚的结果，只能等崩溃的节点重新恢复），因而此阶段耗时应尽可能短，这也是为了尽量控制网络风险的考虑。&lt;/li&gt;
&lt;li&gt;必须假设因为网络分区、机器崩溃或者其他原因而导致失联的节点最终能够恢复，不会永久性地处于失联状态。由于在准备阶段已经写入了完整的重做日志，所以当失联机器一旦恢复，就能够从日志中找出已准备妥当但并未提交的事务数据，并向协调者查询该事务的状态，确定下一步应该进行提交还是回滚操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两段式提交的交互时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220104175102306.png&#34; alt=&#34;image-20220104175102306&#34;&gt;&lt;/p&gt;
&lt;p&gt;两段式提交原理简单，并不难实现，但有几个非常显著的缺点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单点问题&lt;/strong&gt;：协调者在两段提交中具有举足轻重的作用，协调者等待参与者回复时可以有超时机制，允许参与者宕机，但参与者等待协调者指令时无法做超时处理。一旦宕机的不是其中某个参与者，而是协调者的话，所有参与者都会受到影响。如果协调者一直没有恢复，没有正常发送 Commit 或者 Rollback 的指令，那所有参与者都必须一直等待。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能问题&lt;/strong&gt;：两段提交过程中，所有参与者相当于被绑定成为一个统一调度的整体，期间要经过两次远程服务调用，三次数据持久化（准备阶段写重做日志，协调者做状态持久化，提交阶段在日志写入 Commit Record），整个过程将持续到参与者集群中最慢的那一个处理操作结束为止，这决定了两段式提交的性能通常都较差。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性风险&lt;/strong&gt;：前面已经提到，两段式提交的成立是有前提条件的，当网络稳定性和宕机恢复能力的假设不成立时，仍可能出现一致性问题。宕机恢复能力这一点不必多谈，1985 年 Fischer、Lynch、Paterson 提出了“&lt;a href=&#34;https://en.wikipedia.org/wiki/Consensus_(computer_science)#Solvability_results_for_some_agreement_problems&#34;&gt;FLP 不可能原理&lt;/a&gt;”，证明了如果宕机最后不能恢复，那就不存在任何一种分布式协议可以正确地达成一致性结果。该原理在分布式中是与“CAP 不可兼得原理“齐名的理论。而网络稳定性带来的一致性风险是指：尽管提交阶段时间很短，但这仍是一段明确存在的危险期，如果协调者在发出准备指令后，根据收到各个参与者发回的信息确定事务状态是可以提交的，协调者会先持久化事务状态，并提交自己的事务，如果这时候网络忽然被断开，无法再通过网络向所有参与者发出 Commit 指令的话，就会导致部分数据（协调者的）已提交，但部分数据（参与者的）既未提交，也没有办法回滚，产生了数据不一致的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-phase-commit&#34;&gt;3 Phase Commit&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4&#34;&gt;三段式提交&lt;/a&gt;（3 Phase Commit，3PC）把原本的两段式提交的准备阶段再细分为两个阶段，分别称为 CanCommit、PreCommit，把提交阶段改称为 DoCommit 阶段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其中，新增的 CanCommit 是一个询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。将准备阶段一分为二的理由是这个阶段是重负载的操作，一旦协调者发出开始准备的消息，每个参与者都将马上开始写重做日志，它们所涉及的数据资源即被锁住，如果此时某一个参与者宣告无法完成提交，相当于大家都白做了一轮无用功。所以，增加一轮询问阶段，如果都得到了正面的响应，那事务能够成功提交的把握就比较大了，这也意味着因某个参与者提交时发生崩溃而导致大家全部回滚的风险相对变小。因此，在事务需要回滚的场景中，三段式的性能通常是要比两段式好很多的，但在事务能够正常提交的场景中，两者的性能都依然很差，甚至三段式因为多了一次询问，还要稍微更差一些。&lt;/p&gt;
&lt;p&gt;同样也是由于事务失败回滚概率变小的原因，在三段式提交中，如果在 PreCommit 阶段之后发生了协调者宕机，即参与者没有能等到 DoCommit 的消息的话，默认的操作策略将是提交事务而不是回滚事务或者持续等待，这就相当于避免了协调者单点问题的风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;三段式提交的操作时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220104175333821.png&#34; alt=&#34;image-20220104175333821&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从以上过程可以看出，三段式提交对单点问题和回滚时的性能问题有所改善，但是它对一致性风险问题并未有任何改进，在这方面它面临的风险甚至反而是略有增加了的。譬如，进入 PreCommit 阶段之后，协调者发出的指令不是 Ack 而是 Abort，而此时因网络问题，有部分参与者直至超时都未能收到协调者的 Abort 指令的话，这些参与者将会错误地提交事务，这就产生了不同参与者之间数据不一致的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;share-transaction&#34;&gt;Share Transaction&lt;/h1&gt;
&lt;p&gt;共享事务（Share Transaction）与全局事务相反，是指多个服务共用同一个&lt;a href=&#34;https://en.wikipedia.org/wiki/Datasource&#34;&gt;数据源&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;直接让各个服务共享数据库连接，在同一个应用进程中的不同持久化工具（JDBC、ORM、JMS 等）间共享数据库连接并不困难，某些中间件服务器，譬如 WebSphere 会内置有“&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/zh/SSAW57_8.5.5/com.ibm.websphere.nd.multiplatform.doc/ae/cdat_conshrnon.html&#34;&gt;可共享连接&lt;/a&gt;”功能来专门给予这方面的支持。但这种共享的前提是数据源的使用者都在同一个进程内，由于数据库连接的基础是网络连接，它是与 IP 地址和端口号绑定的，字面意义上的“不同服务节点共享数据库连接”很难做到，所以为了实现共享事务，就必须新增一个“交易服务器”的中间角色，无论是用户服务、商家服务还是仓库服务，它们都通过同一台交易服务器来与数据库打交道。&lt;/p&gt;
&lt;p&gt;使用同一个数据库处理多个交易服务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220113164037986.png&#34; alt=&#34;image-20220113164037986&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用消息队列服务器来代替交易服务器。用户、商家、仓库的服务操作业务时，通过消息将所有对数据库的改动传送到消息队列服务器，通过消息的消费者来统一处理，实现由本地事务保障的持久化操作。这被称作“&lt;a href=&#34;https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html&#34;&gt;单个数据库的消息驱动更新&lt;/a&gt;”（Message-Driven Update of a Single Database）。&lt;/p&gt;
&lt;p&gt;“共享事务”的提法和这里所列的两种处理方式在实际应用中并不值得提倡，鲜有采用这种方式的成功案例，能够查询到的资料几乎都发源于十余年前 Spring 的核心开发者&lt;a href=&#34;https://spring.io/team/dsyer&#34;&gt;Dave Syer&lt;/a&gt;撰写的文章《&lt;a href=&#34;https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html&#34;&gt;Distributed Transactions in Spring, with and without XA&lt;/a&gt;》。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;distributed-transaction&#34;&gt;Distributed Transaction&lt;/h1&gt;
&lt;h2 id=&#34;cap-与-acid&#34;&gt;CAP 与 ACID&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如果放弃分区容忍性&lt;/strong&gt;（CA without P），意味着我们将假设节点之间通信永远是可靠的。永远可靠的通信在分布式系统中必定不成立的，这不是你想不想的问题，而是只要用到网络来共享数据，分区现象就会始终存在。在现实中，最容易找到放弃分区容忍性的例子便是传统的关系数据库集群，这样的集群虽然依然采用由网络连接的多个节点来协同工作，但数据却不是通过网络来实现共享的。以 Oracle 的 RAC 集群为例，它的每一个节点均有自己独立的 SGA、重做日志、回滚日志等部件，但各个节点是通过共享存储中的同一份数据文件和控制文件来获取数据的，通过共享磁盘的方式来避免出现网络分区。因而 Oracle RAC 虽然也是由多个实例组成的数据库，但它并不能称作是分布式数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果放弃可用性&lt;/strong&gt;（CP without A），意味着我们将假设一旦网络发生分区，节点之间的信息同步时间可以无限制地延长，此时，问题相当于退化到前面“全局事务”中讨论的一个系统使用多个数据源的场景之中，我们可以通过 2PC/3PC 等手段，同时获得分区容忍性和一致性。在现实中，选择放弃可用性的 CP 系统情况一般用于对数据质量要求很高的场合中，除了 DTP 模型的分布式数据库事务外，著名的 HBase 也是属于 CP 系统，以 HBase 集群为例，假如某个 RegionServer 宕机了，这个 RegionServer 持有的所有键值范围都将离线，直到数据恢复过程完成为止，这个过程要消耗的时间是无法预先估计的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果放弃一致性&lt;/strong&gt;（AP without C），意味着我们将假设一旦发生分区，节点之间所提供的数据可能不一致。选择放弃一致性的 AP 系统目前是设计分布式系统的主流选择，因为 P 是分布式网络的天然属性，你再不想要也无法丢弃；而 A 通常是建设分布式的目的，如果可用性随着节点数量增加反而降低的话，很多分布式系统可能就失去了存在的价值，除非银行、证券这些涉及金钱交易的服务，宁可中断也不能出错，否则多数系统是不能容忍节点越多可用性反而越低的。目前大多数 NoSQL 库和支持分布式的缓存框架都是 AP 系统，以 Redis 集群为例，如果某个 Redis 节点出现网络分区，那仍不妨碍各个节点以自己本地存储的数据对外提供缓存服务，但这时有可能出现请求分配到不同节点时返回给客户端的是不一致的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;base&#34;&gt;BASE&lt;/h2&gt;
&lt;p&gt;BASE 分别是基本可用性（&lt;strong&gt;B&lt;/strong&gt;asically &lt;strong&gt;A&lt;/strong&gt;vailable）、柔性事务（&lt;strong&gt;S&lt;/strong&gt;oft State）和最终一致性（&lt;strong&gt;E&lt;/strong&gt;ventually Consistent）&lt;/p&gt;
&lt;p&gt;交易过程中正确修改账号、仓库和商家服务中的数据的过程时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220113164636482.png&#34; alt=&#34;image-20220113164636482&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上这种靠着持续重试来保证可靠性的解决方案谈不上是 Dan Pritchett 的首创或者独创，它在计算机的其他领域中已被频繁使用，也有了专门的名字叫作“&lt;a href=&#34;https://en.wikipedia.org/wiki/Best-effort_delivery&#34;&gt;最大努力交付&lt;/a&gt;”（Best-Effort Delivery），譬如 TCP 协议中未收到 ACK 应答自动重新发包的可靠性保障就属于最大努力交付。而可靠事件队列还有一种更普通的形式，被称为“最大努力一次提交”（Best-Effort 1PC），指的就是将最有可能出错的业务以本地事务的方式完成后，采用不断重试的方式（不限于消息系统）来促使同一个分布式事务中的其他关联业务全部完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tcc&#34;&gt;TCC&lt;/h2&gt;
&lt;p&gt;TCC 是另一种常见的分布式事务机制，它是“Try-Confirm-Cancel”三个单词的缩写。&lt;/p&gt;
&lt;p&gt;三个阶段为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Try&lt;/strong&gt;：尝试执行阶段，完成所有业务可执行性的检查（保障一致性），并且预留好全部需用到的业务资源（保障隔离性）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Confirm&lt;/strong&gt;：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cancel&lt;/strong&gt;：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行，也需要满足幂等性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCC 修改交易数据的执行过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220113165023071.png&#34; alt=&#34;image-20220113165023071&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由上述操作过程可见，TCC 其实有点类似 2PC 的准备阶段和提交阶段，但 TCC 是位于用户代码层面，而不是在基础设施层面，这为它的实现带来了较高的灵活性，可以根据需要设计资源锁定的粒度。TCC 在业务执行时只操作预留资源，几乎不会涉及锁和资源的争用，具有很高的性能潜力。但是 TCC 并非纯粹只有好处，它也带来了更高的开发成本和业务侵入性，意味着有更高的开发成本和更换事务实现方案的替换成本，所以，通常我们并不会完全靠裸编码来实现 TCC，而是基于某些分布式事务中间件（譬如阿里开源的&lt;a href=&#34;https://seata.io/zh-cn/&#34;&gt;Seata&lt;/a&gt;）去完成，尽量减轻一些编码工作量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;saga&#34;&gt;SAGA&lt;/h2&gt;
&lt;p&gt;SAGA 在英文中是“长篇故事、长篇记叙、一长串事件”的意思。“长时间事务”（Long Lived Transaction）运作效率的方法，大致思路是把一个大事务分解为可以交错运行的一系列子事务集合。原本 SAGA 的目的是避免大事务长时间锁定数据库的资源，后来才发展成将一个分布式环境中的大事务分解为一系列本地事务的设计模式。SAGA 由两部分操作组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大事务拆分若干个小事务，将整个分布式事务 T 分解为 n 个子事务，命名为 $T_1$，$T_2$，…，$T_i$，…，$T_n$。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正常提交，其对数据的影响（最终一致性）应与连续按顺序成功提交 Ti等价。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为每一个子事务设计对应的补偿动作，命名为 $C_1$，$C_2$，…，$C_i$，…，$C_n$。$T_i$与 $C_i$&lt;/p&gt;
&lt;p&gt;必须满足以下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$T_i$与$C_i$都具备幂等性。&lt;/li&gt;
&lt;li&gt;$T_i$与 $C_i$满足交换律（Commutative），即先执行 $T_i$还是先执行 $C_i$，其效果都是一样的。&lt;/li&gt;
&lt;li&gt;$C_i$必须能成功提交，即不考虑 $C_i$本身提交失败被回滚的情形，如出现就必须持续重试直至成功，或者要人工介入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种恢复策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;正向恢复&lt;/strong&gt;（Forward Recovery）：如果 $T_i$事务提交失败，则一直对$T_i$进行重试，直至成功为止（最大努力交付）。这种恢复方式不需要补偿，适用于事务最终都要成功的场景，譬如在别人的银行账号中扣了款，就一定要给别人发货。正向恢复的执行模式为：$T_1$，$T_2$，…，$T_i$（失败），T_i（重试）…，$T_{i+1}$，…，$T_n$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向恢复&lt;/strong&gt;（Backward Recovery）：如果 $T_i$事务提交失败，则一直执行 $C_i$对 $T_i$进行补偿，直至成功为止（最大努力交付）。这里要求 $C_i$必须（在持续重试后）执行成功。反向恢复的执行模式为：$T_1$，$T_2$，…，$T_i$（失败），$C_i$（补偿），…，$C_2$，$C_1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;从整体上看是 &lt;a href=&#34;https://seata.io/zh-cn/docs/overview/what-is-seata.html&#34;&gt;AT 事务&lt;/a&gt;是参照了 XA 两段提交协议实现的，但针对 XA 2PC 的缺陷，即在准备阶段必须等待所有数据源都返回成功后，协调者才能统一发出 Commit 命令而导致的&lt;a href=&#34;https://en.wikipedia.org/wiki/Liebig&#39;s_law_of_the_minimum&#34;&gt;木桶效应&lt;/a&gt;（所有涉及的锁和资源都需要等待到最慢的事务完成后才能统一释放），设计了针对性的解决方案。大致的做法是在业务数据提交时自动拦截所有 SQL，将 SQL 对数据修改前、修改后的结果分别保存快照，生成行锁，通过本地事务一起提交到操作的数据源中，相当于自动记录了重做和回滚日志。如果分布式事务成功提交，那后续清理每个数据源中对应的日志数据即可；如果分布式事务需要回滚，就根据日志数据自动产生用于补偿的“逆向 SQL”。基于这种补偿方式，分布式事务中所涉及的每一个数据源都可以单独提交，然后立刻释放锁和资源。这种异步提交的模式，相比起 2PC 极大地提升了系统的吞吐量水平。而代价就是大幅度地牺牲了隔离性，甚至直接影响到了原子性。因为在缺乏隔离性的前提下，以补偿代替回滚并不一定是总能成功的。譬如，当本地事务提交之后、分布式事务完成之前，该数据被补偿之前又被其他操作修改过，即出现了脏写（Dirty Write），这时候一旦出现分布式事务需要回滚，就不可能再通过自动的逆向 SQL 来实现补偿，只能由人工介入处理了。&lt;/p&gt;
&lt;p&gt;通常来说，脏写是一定要避免的，所有传统关系数据库在最低的隔离级别上都仍然要加锁以避免脏写，因为脏写情况一旦发生，人工其实也很难进行有效处理。所以 GTS 增加了一个“全局锁”（Global Lock）的机制来实现写隔离，要求本地事务提交之前，一定要先拿到针对修改记录的全局锁后才允许提交，没有获得全局锁之前就必须一直等待，这种设计以牺牲一定性能为代价，避免了有两个分布式事务中包含的本地事务修改了同一个数据，从而避免脏写。在读隔离方面，AT 事务默认的隔离级别是读未提交（Read Uncommitted），这意味着可能产生脏读（Dirty Read）。也可以采用全局锁的方案解决读隔离问题，但直接阻塞读取的话，代价就非常大了，一般不会这样做。由此可见，分布式事务中没有一揽子包治百病的解决办法，因地制宜地选用合适的事务处理方案才是唯一有效的做法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics&#34;&gt;Algorithms for Recovery and Isolation Exploiting Semantics，ARIES&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.research.ibm.com/labs/almaden/&#34;&gt;IBM Almaden&lt;/a&gt;, &lt;a href=&#34;https://cs.stanford.edu/people/chrismre/cs345/rl/aries.pdf&#34;&gt;ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://vldb.org/conf/1990/P392.PDF&#34;&gt;ARIES/KVL: A Key-Value Locking Method for Concurrency Control of Multiaction Transactions Operating on B-Tree Indexes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/2582889/what-is-a-commit-log&#34;&gt;what is a commit log?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dan Pritchett, 2008, ACM, &lt;a href=&#34;https://queue.acm.org/detail.cfm?id=1394128&#34;&gt;Base: An Acid Alternative&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pat Helland, 2007, &lt;a href=&#34;https://www-db.cs.wisc.edu/cidr/cidr2007/papers/cidr07p15.pdf&#34;&gt;Life beyond Distributed Transactions: An Apostate’s Opinion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Hector Garcia-Molina &amp;amp; Kenneth Salem, 1987, ACM, &lt;a href=&#34;https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf&#34;&gt;SAGAS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Seata, &lt;a href=&#34;https://seata.io/zh-cn/docs/overview/what-is-seata.html&#34;&gt;AT 事务模式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/transactions/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Transparent Multilevel Diversion</title>
        <link>https://www.openheart.icu/cs/transparent-multilevel-diversion-system/</link>
        <pubDate>Wed, 01 Dec 2021 14:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/transparent-multilevel-diversion-system/</guid>
        <description>42th openheart https://www.openheart.icu/cs/transparent-multilevel-diversion-system/ -&lt;p&gt;在用户使用信息系统的过程中，请求从浏览器出发，在域名服务器的指引下找到系统的入口，经过网关、负载均衡器、缓存、服务集群等一系列设施，最后触及到末端存储于数据库服务器中的信息，然后逐级返回到用户的浏览器之中。这其中要经过很多技术部件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有一些部件位于客户端或网络的边缘，能够迅速响应用户的请求，避免给后方的 I/O 与 CPU 带来压力，典型如本地缓存、内容分发网络、反向代理等。&lt;/li&gt;
&lt;li&gt;有一些部件的处理能力能够线性拓展，易于伸缩，可以使用较小的代价堆叠机器来获得与用户数量相匹配的并发性能，应尽量作为业务逻辑的主要载体，典型如集群中能够自动扩缩的服务节点。&lt;/li&gt;
&lt;li&gt;有一些部件稳定服务对系统运行有全局性的影响，要时刻保持着容错备份，维护着高可用性，典型如服务注册中心、配置中心。&lt;/li&gt;
&lt;li&gt;有一些设施是天生的单点部件，只能依靠升级机器本身的网络、存储和运算性能来提升处理能力，如位于系统入口的路由、网关或者负载均衡器（它们都可以做集群，但一次网络请求中无可避免至少有一个是单点的部件）、位于请求调用链末端的传统关系数据库等，都是典型的容易形成单点部件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对系统进行流量规划时，我们应该充分理解这些部件的价值差异，有两条简单、普适的原则能指导我们进行设计：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一条原则是尽可能减少单点部件，如果某些单点是无可避免的，则应尽最大限度减少到达单点部件的流量。在系统中往往会有多个部件能够处理、响应用户请求，譬如要获取一张存储在数据库的用户头像图片，浏览器缓存、内容分发网络、反向代理、Web 服务器、文件服务器、数据库都可能提供这张图片。恰如其分地引导请求分流至最合适的组件中，避免绝大多数流量汇集到单点部件（如数据库），同时依然能够在绝大多数时候保证处理结果的准确性，使单点系统在出现故障时自动而迅速地实施补救措施，这便是系统架构中多级分流的意义。&lt;/li&gt;
&lt;li&gt;另一条更关键的原则是&lt;a href=&#34;https://en.wikipedia.org/wiki/Occam%27s_razor&#34;&gt;奥卡姆剃刀原则&lt;/a&gt;。作为一名架构设计者，你应对多级分流的手段有全面的理解与充分的准备，同时清晰地意识到这些设施并不是越多越好。在实际构建系统时，你应当在有明确需求、真正必要的时候再去考虑部署它们。不是每一个系统都要追求高并发、高可用的，根据系统的用户量、峰值流量和团队本身的技术与运维能力来考虑如何部署这些设施才是合理的做法，在能满足需求的前提下，&lt;strong&gt;最简单的系统就是最好的系统&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;client-cache&#34;&gt;Client Cache&lt;/h1&gt;
&lt;h2 id=&#34;强制缓存&#34;&gt;强制缓存&lt;/h2&gt;
&lt;p&gt;假设在某个时点到来以前，譬如收到响应后的 10 分钟内，资源的内容和状态一定不会被改变，因此客户端可以无须经过任何请求，在该时点前一直持有和使用该资源的本地缓存副本。&lt;/p&gt;
&lt;p&gt;根据约定，强制缓存在浏览器的地址输入、页面链接跳转、新开窗口、前进和后退中均可生效，但在用户主动刷新页面时应当自动失效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires&#34;&gt;Expires&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;受限于客户端的本地时间。&lt;/li&gt;
&lt;li&gt;无法处理涉及到用户身份的私有资源，譬如，某些资源被登录用户缓存在自己的浏览器上是合理的，但如果被代理服务器或者内容分发网络缓存起来，则可能被其他未认证的用户所获取。&lt;/li&gt;
&lt;li&gt;无法描述“不缓存”的语义。譬如，浏览器为了提高性能，往往会自动在当次会话中缓存某些 MIME 类型的资源，在 HTTP/1.0 的服务器中就缺乏手段强制浏览器不允许缓存某个资源。以前为了实现这类功能，通常不得不使用脚本，或者手工在资源后面增加时间戳（譬如如“xx.js?t=1586359920”、“xx.jpg?t=1586359350”）来保证每次资源都会重新获取。
关于“不缓存”的语义，在 HTTP/1.0 中其实预留了“Pragma: no-cache”来表达，但 Pragma 参数在 HTTP/1.0 中并没有确切描述其具体行为，随后就被 HTTP/1.1 中出现过的 Cache-Control 所替代，现在，尽管主流浏览器通常都会支持 Pragma，但行为仍然是不确定的，实际并没有什么使用价值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control&#34;&gt;Cache-Control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;协商缓存&#34;&gt;协商缓存&lt;/h2&gt;
&lt;p&gt;强制缓存是基于时效性的，但无论是人还是服务器，其实多数情况下都并没有什么把握去承诺某项资源多久不会发生变化。&lt;/p&gt;
&lt;p&gt;根据约定，协商缓存不仅在浏览器的地址输入、页面链接跳转、新开窗口、前进、后退中生效，而且在用户主动刷新页面（F5）时也同样是生效的，只有用户强制刷新（Ctrl+F5）或者明确禁用缓存（譬如在 DevTools 中设定）时才会失效，此时客户端向服务端发出的请求会自动带有“Cache-Control: no-cache”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified&#34;&gt;Last-Modified&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since&#34;&gt;If-Modified-Since&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag&#34;&gt;ETag&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match&#34;&gt;If-None-Match&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Etag 是 HTTP 中一致性最强的缓存机制，譬如，Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；又或者如果某些文件会被定期生成，可能内容并没有任何变化，但 Last-Modified 却改变了，导致文件无法有效使用缓存，这些情况 Last-Modified 都有可能产生资源一致性问题，只能使用 Etag 解决。&lt;/p&gt;
&lt;p&gt;Etag 却又是 HTTP 中性能最差的缓存机制，体现在每次请求时，服务端都必须对资源进行哈希计算，这比起简单获取一下修改时间，开销要大了很多。Etag 和 Last-Modified 是允许一起使用的，服务器会优先验证 Etag，在 Etag 一致的情况下，再去对比 Last-Modified，这是为了防止有一些 HTTP 服务器未将文件修改日期纳入哈希范围内。&lt;/p&gt;
&lt;h1 id=&#34;dns-lookup&#34;&gt;DNS Lookup&lt;/h1&gt;
&lt;p&gt;首先 DNS 会将域名还原为“&lt;code&gt;www.google.com.cn.&lt;/code&gt;”，注意最后多了一个点“&lt;code&gt;.&lt;/code&gt;”，它是“&lt;code&gt;.root&lt;/code&gt;”的含义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端先检查本地的 DNS 缓存，查看是否存在并且是存活着的该域名的地址记录。DNS 是以&lt;a href=&#34;https://en.wikipedia.org/wiki/Time_to_live&#34;&gt;存活时间&lt;/a&gt;（Time to Live，TTL）来衡量缓存的有效情况的，所以，如果某个域名改变了 IP 地址，DNS 服务器并没有任何机制去通知缓存了该地址的机器去更新或者失效掉缓存，只能依靠 TTL 超期后的重新获取来保证一致性。后续每一级 DNS 查询的过程都会有类似的缓存查询操作。&lt;/li&gt;
&lt;li&gt;客户端将地址发送给本机操作系统中配置的本地 DNS（Local DNS），这个本地 DNS 服务器可以由用户手工设置，也可以在 DHCP 分配时或者在拨号时从 PPP 服务器中自动获取到。&lt;/li&gt;
&lt;li&gt;本地 DNS 收到查询请求后，会按照“是否有&lt;code&gt;www.google.com.cn&lt;/code&gt;的权威服务器”→“是否有&lt;code&gt;google.com.cn&lt;/code&gt;的权威服务器”→“是否有&lt;code&gt;com.cn&lt;/code&gt;的权威服务器”→“是否有&lt;code&gt;cn&lt;/code&gt;的权威服务器”的顺序，依次查询自己的地址记录，如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。这个步骤里涉及了两个重要名词：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;权威域名服务器&lt;/strong&gt;（Authoritative DNS）：是指负责翻译特定域名的 DNS 服务器，“权威”意味着这个域名应该翻译出怎样的结果是由它来决定的。DNS 翻译域名时无需像查电话本一样刻板地一对一翻译，根据来访机器、网络链路、服务内容等各种信息，可以玩出很多花样，权威 DNS 的灵活应用，在后面的内容分发网络、服务发现等章节都还会有所涉及。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根域名服务器&lt;/strong&gt;（Root DNS）是指固定的、无需查询的&lt;a href=&#34;https://en.wikipedia.org/wiki/Top-level_domain&#34;&gt;顶级域名&lt;/a&gt;（Top-Level Domain）服务器，可以默认为它们已内置在操作系统代码之中。全世界一共有 13 组根域名服务器（注意并不是 13 台，每一组根域名都通过&lt;a href=&#34;https://en.wikipedia.org/wiki/Anycast&#34;&gt;任播&lt;/a&gt;的方式建立了一大群镜像，根据维基百科的数据，迄今已经超过 1000 台根域名服务器的镜像了）。13 这个数字是由于 DNS 主要采用 UDP 传输协议（在需要稳定性保证的时候也可以采用 TCP）来进行数据交换，未分片的 UDP 数据包在 IPv4 下最大有效值为 512 字节，最多可以存放 13 组地址记录，由此而来的限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;现在假设本地 DNS 是全新的，上面不存在任何域名的权威服务器记录，所以当 DNS 查询请求按步骤 3 的顺序一直查到根域名服务器之后，它将会得到“&lt;code&gt;cn&lt;/code&gt;的权威服务器”的地址记录，然后通过“&lt;code&gt;cn&lt;/code&gt;的权威服务器”，得到“&lt;code&gt;com.cn&lt;/code&gt;的权威服务器”的地址记录，以此类推，最后找到能够解释&lt;code&gt;www.google.com.cn&lt;/code&gt;的权威服务器地址。&lt;/li&gt;
&lt;li&gt;通过“&lt;code&gt;www.google.com.cn&lt;/code&gt;的权威服务器”，查询&lt;code&gt;www.google.com.cn&lt;/code&gt;的地址记录，地址记录并不一定就是指 IP 地址，在 RFC 规范中有定义的地址记录类型已经&lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_DNS_record_types&#34;&gt;多达数十种&lt;/a&gt;，譬如 IPv4 下的 IP 地址为 A 记录，IPv6 下的 AAAA 记录、主机别名 CNAME 记录，等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DNS 系统多级分流的设计使得 DNS 系统能够经受住全球网络流量不间断的冲击，但也并非全无缺点。典型的问题是响应速度，当极端情况（各级服务器均无缓存）下的域名解析可能导致每个域名都必须递归多次才能查询到结果，显著影响传输的响应速度。专门有一种被称为“&lt;a href=&#34;https://en.wikipedia.org/wiki/Link_prefetching&#34;&gt;DNS 预取&lt;/a&gt;”（DNS Prefetching）的前端优化手段用来避免这类问题：如果网站后续要使用来自于其他域的资源，那就在网页加载时生成一个 link 请求，促使浏览器提前对该域名进行预解释&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;link&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;rel&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dns-prefetch&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;href&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;//domain.not-icyfenx.cn&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而另一种可能更严重的缺陷是 DNS 的分级查询意味着每一级都有可能受到中间人攻击的威胁，产生被劫持的风险。要攻陷位于递归链条顶层的（譬如根域名服务器，cn 权威服务器）服务器和链路是非常困难的，它们都有很专业的安全防护措施。但很多位于递归链底层或者来自本地运营商的 Local DNS 服务器的安全防护则相对松懈，甚至不少地区的运营商自己就会主动进行劫持，专门返回一个错的 IP，通过在这个 IP 上代理用户请求，以便给特定类型的资源（主要是 HTML）注入广告，以此牟利。&lt;/p&gt;
&lt;p&gt;为此，最近几年出现了另一种新的 DNS 工作模式：&lt;a href=&#34;https://en.wikipedia.org/wiki/DNS_over_HTTPS&#34;&gt;HTTPDNS&lt;/a&gt;（也称为 DNS over HTTPS，DoH）。它将原本的 DNS 解析服务开放为一个基于 HTTPS 协议的查询服务，替代基于 UDP 传输协议的 DNS 域名解析，通过程序代替操作系统直接从权威 DNS 或者可靠的 Local DNS 获取解析数据，从而绕过传统 Local DNS。这种做法的好处是完全免去了“中间商赚差价”的环节，不再惧怕底层的域名劫持，能够有效避免 Local DNS 不可靠导致的域名生效缓慢、来源 IP 不准确、产生的智能线路切换错误等问题。&lt;/p&gt;
&lt;h1 id=&#34;transmission-optimization&#34;&gt;Transmission Optimization&lt;/h1&gt;
&lt;p&gt;程序发出的请求能否与应用层、传输层协议提倡的方式相匹配，对传输的效率也会有极大影响。优化链路传输为目的的前端设计不少，譬如经典的&lt;a href=&#34;https://developer.yahoo.com/performance/rules.html&#34;&gt;雅虎 YSlow-23 条规则&lt;/a&gt;中与传输相关的内容如下。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Minimize HTTP Requests。&lt;/p&gt;
&lt;p&gt;减少请求数量：请求每次都需要建立通信链路进行数据传输，这些开销很昂贵，减少请求的数量可有效的提高访问性能，对于前端开发者，可能用来减少请求数量的手段包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;雪碧图（&lt;a href=&#34;https://en.wikipedia.org/w/index.php?title=CSS_Sprites&amp;amp;redirect=no&#34;&gt;CSS Sprites&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;CSS、JS 文件合并/内联（Concatenation / Inline）&lt;/li&gt;
&lt;li&gt;分段文档（&lt;a href=&#34;https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html&#34;&gt;Multipart Document&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;媒体（图片、音频）内联（&lt;a href=&#34;https://en.wikipedia.org/wiki/Data_URI_scheme&#34;&gt;Data Base64 URI&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;合并 Ajax 请求（Batch Ajax Request）&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Split Components Across Domains。
扩大并发请求数：现代浏览器（Chrome、Firefox）一般对每个域名支持 6 个（IE 为 8-13 个）并发请求，如果希望更快地加载大量图片或其他资源，需要进行域名分片（Domain Sharding），将图片同步到不同主机或者同一个主机的不同域名上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GZip Components。
启用压缩传输：启用压缩能够大幅度减少需要在网络上传输内容的大小，节省网络流量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Avoid Redirects。
避免页面重定向：当页面发生了重定向，就会延迟整个文档的传输。在 HTML 文档到达之前，页面中不会呈现任何东西，降低了用户体验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Put Stylesheets at the Top，Put Scripts at the Bottom。
按重要性调节资源优先级：将重要的、马上就要使用的、对客户端展示影响大的资源，放在 HTML 的头部，以便优先下载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;…………&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;连接数优化&#34;&gt;连接数优化&lt;/h2&gt;
&lt;p&gt;TCP 协议要求必须在&lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Connection_establishment&#34;&gt;三次握手&lt;/a&gt;完成之后才能开始数据传输，这是一个可能高达“百毫秒”为计时尺度的事件；另外，TCP 还有&lt;a href=&#34;https://en.wikipedia.org/wiki/TCP_congestion_control#Slow_start&#34;&gt;慢启动&lt;/a&gt;的特性，使得刚刚建立连接时传输速度是最低的，后面再逐步加速直至稳定。由于 TCP 协议本身是面向于长时间、大数据传输来设计的，在长时间尺度下，它连接建立的高昂成本才不至于成为瓶颈，它的稳定性和可靠性的优势才能展现出来。因此，可以说 HTTP over TCP 这种搭配在目标特征上确实是有矛盾的，以至于 HTTP/1.x 时代，大量短而小的 TCP 连接导致了网络性能的瓶颈。为了缓解 HTTP 与 TCP 之间的矛盾，聪明的程序员们一面致力于减少发出的请求数量，另外一方面也致力于增加客户端到服务端的连接数量，这就是上面 Yslow 规则中“Minimize HTTP Requests”与“Split Components Across Domains”两条优化措施的根本依据所在。&lt;/p&gt;
&lt;p&gt;通过前端开发者的各种 Tricks，的确能够减少消耗 TCP 连接数量。但是，通过开发人员的 Tricks 来节省 TCP 连接，这样的优化措施并非只有好处，它们同时也带来了诸多不良的副作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你用 CSS Sprites 将多张图片合并，意味着任何场景下哪怕只用到其中一张小图，也必须完整加载整个大图片；任何场景下哪怕一张小图要进行修改，都会导致整个缓存失效，类似地，样式、脚本等其他文件的合并也会造成同样的问题。&lt;/li&gt;
&lt;li&gt;如果你使用了媒体内嵌，除了要承受 Base64 编码导致传输容量膨胀 1/3 的代价外（Base64 以 8 bit 表示 6 bit 数据），也将无法有效利用缓存。&lt;/li&gt;
&lt;li&gt;如果你合并了异步请求，这就会导致所有请求返回时间都受最慢的那个请求的拖累，整体响应速度下降.&lt;/li&gt;
&lt;li&gt;如果你把图片放到不同子域下面，将会导致更大的 DNS 解析负担，而且浏览器对两个不同子域下的同一图片必须持有两份缓存，也使得缓存效率的下降。&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP 协议的最初版本（指 HTTP/1.0，忽略非正式的 HTTP/0.9 版本）就已经支持了连接复用技术（连接复用技术在 HTTP/1.0 中并不是默认开启的，是在 HTTP/1.1 中变为默认开启），即今天大家所熟知的&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_persistent_connection&#34;&gt;持久连接&lt;/a&gt;（Persistent Connection），也称为连接&lt;a href=&#34;https://en.wikipedia.org/wiki/Keepalive&#34;&gt;Keep-Alive 机制&lt;/a&gt;。持久连接的原理是让客户端对同一个域名长期持有一个或多个不会用完即断的 TCP 连接。典型做法是在客户端维护一个 FIFO 队列，每次取完数据（如何在不断开连接下判断取完数据将会放到稍后&lt;a href=&#34;http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/transmission-optimization.html#%E4%BC%A0%E8%BE%93%E5%8E%8B%E7%BC%A9&#34;&gt;传输压缩&lt;/a&gt;部分去讨论）之后一段时间内不自动断开连接，以便获取下一个资源时直接复用，避免创建 TCP 连接的成本。&lt;/p&gt;
&lt;p&gt;但是，连接复用技术依然是不完美的，最明显的副作用是“&lt;a href=&#34;https://en.wikipedia.org/wiki/Head-of-line_blocking&#34;&gt;队首阻塞&lt;/a&gt;”（Head-of-Line Blocking）。队首阻塞问题一直持续到第二代的 HTTP 协议，即 HTTP/2 发布后才算是被比较完美地解决。在 HTTP/1.x 中，HTTP 请求就是传输过程中最小粒度的信息单位了，所以如果将多个请求切碎，再混杂在一块传输，客户端势必难以分辨重组出有效信息。而在 HTTP/2 中，帧（Frame）才是最小粒度的信息单位，它可以用来描述各种数据，譬如请求的 Headers、Body，或者用来做控制标识，譬如打开流、关闭流。这里说的流（Stream）是一个逻辑上的数据通道概念，每个帧都附带一个流 ID 以标识这个帧属于哪个流。这样，在同一个 TCP 连接中传输的多个数据帧就可以根据流 ID 轻易区分出开来，在客户端毫不费力地将不同流中的数据重组出不同 HTTP 请求和响应报文来。这项设计是 HTTP/2 的最重要的技术特征一，被称为 HTTP/2 &lt;a href=&#34;https://tools.ietf.org/html/rfc7540#page-15&#34;&gt;多路复用&lt;/a&gt;（HTTP/2 Multiplexing）技术，如图 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://icyfenix.cn/assets/img/http2-con.f8b394df.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;有了多路复用的支持，HTTP/2 就可以对每个域名只维持一个 TCP 连接（One Connection Per Origin）来以任意顺序传输任意数量的资源，既减轻了服务器的连接压力，开发者也不用去考虑域名分片这种事情来突破浏览器对每个域名最多 6 个连接数限制了。而更重要的是，没有了 TCP 连接数的压力，就无须刻意压缩 HTTP 请求了，所有通过合并、内联文件（无论是图片、样式、脚本）以减少请求数的需求都不再成立，甚至反而是徒增副作用的反模式。&lt;/p&gt;
&lt;p&gt;必须先承认一个事实，在 HTTP 传输中 Headers 占传输成本的比重是相当的大，对于许多小资源，甚至可能出现 Headers 的容量比 Body 的还要大，以至于在 HTTP/2 中必须专门考虑如何进行 Header 压缩的问题。但是，以下几个因素决定了通过合并资源文件减少请求数，对节省 Headers 成本也并没有太大帮助：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Header 的传输成本在 Ajax（尤其是只返回少量数据的请求）请求中可能是比重很大的开销，但在图片、样式、脚本这些静态资源的请求中，通常并不占主要。&lt;/li&gt;
&lt;li&gt;在 HTTP/2 中 Header 压缩的原理是基于字典编码的信息复用，简而言之是同一个连接上产生的请求和响应越多，动态字典积累得越全，头部压缩效果也就越好。所以 HTTP/2 是单域名单连接的机制，合并资源和域名分片反而对性能提升不利。&lt;/li&gt;
&lt;li&gt;与 HTTP/1.x 相反，HTTP/2 本身反而变得更适合传输小资源了，譬如传输 1000 张 10K 的小图，HTTP/2 要比 HTTP/1.x 快，但传输 10 张 1000K 的大图，则应该 HTTP/1.x 会更快。这一方面是 TCP 连接数量（相当于多点下载）的影响，更多的是由于 TCP 协议&lt;a href=&#34;https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Reliable_transmission&#34;&gt;可靠传输机制&lt;/a&gt;导致的，一个错误的 TCP 包会导致所有的流都必须等待这个包重传成功，这个问题就是 HTTP/3 要解决的目标了。因此，把小文件合并成大文件，在 HTTP/2 下是毫无好处的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;传输压缩&#34;&gt;传输压缩&lt;/h2&gt;
&lt;p&gt;HTTP 很早就支持了&lt;a href=&#34;https://en.wikipedia.org/wiki/Gzip&#34;&gt;GZip&lt;/a&gt;压缩，由于 HTTP 传输的主要内容，譬如 HTML、CSS、Script 等，主要是文本数据，对于文本数据启用压缩的收益是非常高的，传输数据量一般会降至原有的 20%左右。而对于那些不适合压缩的资源，Web 服务器则能根据 MIME 类型来自动判断是否对响应进行压缩，这样，已经采用过压缩算法存储的资源，如 JPEG、PNG 图片，便不会被二次压缩，空耗性能。&lt;/p&gt;
&lt;p&gt;早期，服务器处理能力还很薄弱，为了启用压缩，会是把静态资源先预先压缩为.gz 文件的形式存放起来，当客户端可以接受压缩版本的资源时（请求的 Header 中包含 Accept-Encoding: gzip）就返回压缩后的版本（响应的 Header 中包含 Content-Encoding: gzip），否则就返回未压缩的原版，这种方式被称为“&lt;a href=&#34;http://nginx.org/en/docs/http/ngx_http_gzip_static_module.html&#34;&gt;静态预压缩&lt;/a&gt;”（Static Precompression）。而现代的 Web 服务器处理能力有了大幅提升，已经没有人再采用麻烦的预压缩方式了，都是由服务器对符合条件的请求将在输出时进行“&lt;a href=&#34;https://www.usenix.org/legacy/publications/library/proceedings/jvm01/full_papers/hovemeyer/hovemeyer_html/node7.html&#34;&gt;即时压缩&lt;/a&gt;”（On-The-Fly Compression），整个压缩过程全部在内存的数据流中完成，不必等资源压缩完成再返回响应，这样可以显著提高“&lt;a href=&#34;https://en.wikipedia.org/wiki/Time_to_first_byte&#34;&gt;首字节时间&lt;/a&gt;”（Time To First Byte，TTFB），改善 Web 性能体验。而这个过程中唯一不好的地方就是服务器再也没有办法给出 Content-Length 这个响应 Header 了，因为输出 Header 时服务器还不知道压缩后资源的确切大小。&lt;/p&gt;
&lt;p&gt;由于启用即时压缩后就无法给出 Content-Length 了，如果是 HTTP/1.0 的话，持久链接和即时压缩只能二选其一，事实上在 HTTP/1.0 中两者都支持，却默认都是不启用的。依靠 Content-Length 来判断传输结束的缺陷，不仅仅在于即时压缩这一种场景，譬如对于动态内容（Ajax、PHP、JSP 等输出），服务器也同样无法事项得知 Content-Length。&lt;/p&gt;
&lt;p&gt;HTTP/1.1 版本中修复了这个缺陷，增加了另一种“&lt;a href=&#34;https://en.wikipedia.org/wiki/Chunked_transfer_encoding&#34;&gt;分块传输编码&lt;/a&gt;”（Chunked Transfer Encoding）的资源结束判断机制，彻底解决了 Content-Length 与持久链接的冲突问题。分块编码原理相当简单：在响应 Header 中加入“Transfer-Encoding: chunked”之后，就代表这个响应报文将采用分块编码。此时，报文中的 Body 需要改为用一系列“分块”来传输。每个分块包含十六进制的长度值和对应长度的数据内容，长度值独占一行，数据从下一行开始。最后以一个长度值为 0 的分块来表示资源结束。&lt;/p&gt;
&lt;h2 id=&#34;quick-udp-internet-connections&#34;&gt;Quick UDP Internet Connections&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/QUIC&#34;&gt;快速 UDP 网络连接&lt;/a&gt;（Quick UDP Internet Connections，QUIC）会以 UDP 协议为基础，而 UDP 协议没有丢包自动重传的特性。的另一个设计目标是面向移动设备的专门支持，由于以前 TCP、UDP 传输协议在设计时根本不可能设想到今天移动设备盛行的场景，因此肯定不会有任何专门的支持。QUIC 在移动设备上的优势体现在网络切换时的响应速度上，譬如当移动设备在不同 WiFi 热点之间切换，或者从 WiFi 切换到移动网络时，如果使用 TCP 协议，现存的所有连接都必定会超时、中断，然后根据需要重新创建。这个过程会带来很高的延迟，因为超时和重新握手都需要大量时间。为此，QUIC 提出了连接标识符的概念，该标识符可以唯一地标识客户端与服务器之间的连接，而无须依靠 IP 地址。这样，切换网络后，只需向服务端发送一个包含此标识符的数据包即可重用既有的连接，因为即使用户的 IP 地址发生变化，原始连接连接标识符依然是有效的。&lt;/p&gt;
&lt;h1 id=&#34;content-distribution-network&#34;&gt;Content Distribution Network&lt;/h1&gt;
&lt;p&gt;如果把某个互联网系统比喻为一家企业，那内容分发网络就是它遍布世界各地的分支销售机构，现在有客户要买一块 CPU，那么订机票飞到美国加州 Intel 总部肯定是不合适的，到本地电脑城找个装机铺才是通常的做法，在此场景中，内容分发网络就相当于电脑城里的本地经销商。&lt;/p&gt;
&lt;p&gt;如果抛却其他影响服务质量的因素，仅从网络传输的角度看，一个互联网系统的速度取决于以下四点因素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网站服务器接入网络运营商的链路所能提供的出口带宽。&lt;/li&gt;
&lt;li&gt;用户客户端接入网络运营商的链路所能提供的入口带宽。&lt;/li&gt;
&lt;li&gt;从网站到用户之间经过的不同运营商之间互联节点的带宽，一般来说两个运营商之间只有固定的若干个点是互通的，所有跨运营商之间的交互都要经过这些点。&lt;/li&gt;
&lt;li&gt;从网站到用户之间的物理链路传输时延。爱打游戏的同学应该都清楚，延迟（Ping 值）比带宽更重要。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上四个网络问题，除了第二个只能通过换一个更好的宽带才能解决之外，其余三个都能通过内容分发网络来显著改善。一个运作良好的内容分发网络，能为互联网系统解决跨运营商、跨地域物理距离所导致的时延问题，能为网站流量带宽起到分流、减负的作用。举个例子，如果不是有遍布全国乃至全世界的阿里云 CDN 网络支持，哪怕把整个杭州所有市民上网的权力都剥夺了，把带宽全部让给淘宝的机房，恐怕也撑不住全国乃至全球用户在双十一期间的疯狂“围殴”。&lt;/p&gt;
&lt;h2 id=&#34;路由解析&#34;&gt;路由解析&lt;/h2&gt;
&lt;p&gt;路由解析过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220214153530661.png&#34; alt=&#34;image-20220214153530661&#34;&gt;&lt;/p&gt;
&lt;p&gt;CDN 路由解析的具体工作过程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;架设好“&lt;code&gt;icyfenix.cn&lt;/code&gt;”的服务器后，将服务器的 IP 地址在你的 CDN 服务商上注册为“源站”，注册后你会得到一个 CNAME，即本例中的“&lt;code&gt;icyfenix.cn.cdn.dnsv1.com.&lt;/code&gt;”。&lt;/li&gt;
&lt;li&gt;将得到的 CNAME 在你购买域名的 DNS 服务商上注册为一条 CNAME 记录。&lt;/li&gt;
&lt;li&gt;当第一位用户来访你的站点时，将首先发生一次未命中缓存的 DNS 查询，域名服务商解析出 CNAME 后，返回给本地 DNS，至此之后链路解析的主导权就开始由内容分发网络的调度服务接管了。&lt;/li&gt;
&lt;li&gt;本地 DNS 查询 CNAME 时，由于能解析该 CNAME 的权威服务器只有 CDN 服务商所架设的权威 DNS，这个 DNS 服务将根据一定的均衡策略和参数，如拓扑结构、容量、时延等，在全国各地能提供服务的 CDN 缓存节点中挑选一个最适合的，将它的 IP 代替源站的 IP 地址，返回给本地 DNS。&lt;/li&gt;
&lt;li&gt;浏览器从本地 DNS 拿到 IP 地址，将该 IP 当作源站服务器来进行访问，此时该 IP 的 CDN 节点上可能有，也可能没有缓存过源站的资源，这点将在稍后“&lt;a href=&#34;http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cdn.html#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91&#34;&gt;内容分发&lt;/a&gt;”小节讨论。&lt;/li&gt;
&lt;li&gt;经过内容分发后的 CDN 节点，就有能力代替源站向用户提供所请求的资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;路由解析时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220214161418262.png&#34; alt=&#34;image-20220214161418262&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;内容分发&#34;&gt;内容分发&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主动分发&lt;/strong&gt;（Push）：分发由源站主动发起，将内容从源站或者其他资源库推送到用户边缘的各个 CDN 缓存节点上。这个推送的操作没有什么业界标准可循，可以采用任何传输方式（HTTP、FTP、P2P，等等）、任何推送策略（满足特定条件、定时、人工，等等）、任何推送时间，只要与后面说的更新策略相匹配即可。由于主动分发通常需要源站、CDN 服务双方提供程序 API 接口层面的配合，所以它对源站并不是透明的，只对用户一侧单向透明。主动分发一般用于网站要预载大量资源的场景。譬如双十一之前一段时间内，淘宝、京东等各个网络商城就会开始把未来活动中所需用到的资源推送到 CDN 缓存节点中，特别常用的资源甚至会直接缓存到你的手机 APP 的存储空间或者浏览器的&lt;a href=&#34;https://en.wikipedia.org/wiki/Web_storage#localStorage&#34;&gt;localStorage&lt;/a&gt;上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;被动回源&lt;/strong&gt;（Pull）：被动回源由用户访问所触发全自动、双向透明的资源缓存过程。当某个资源首次被用户请求的时候，CDN 缓存节点发现自己没有该资源，就会实时从源站中获取，这时资源的响应时间可粗略认为是资源从源站到 CDN 缓存节点的时间，再加上资源从 CDN 发送到用户的时间之和。因此，被动回源的首次访问通常是比较慢的（但由于 CDN 的网络条件一般远高于普通用户，并不一定就会比用户直接访问源站更慢），不适合应用于数据量较大的资源。被动回源的优点是可以做到完全的双向透明，不需要源站在程序上做任何的配合，使用起来非常方便。这种分发方式是小型站点使用 CDN 服务的主流选择，如果不是自建 CDN，而是购买阿里云、腾讯云的 CDN 服务的站点，多数采用的就是这种方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cdn-应用&#34;&gt;CDN 应用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;加速静态资源：这是 CDN 本职工作。&lt;/li&gt;
&lt;li&gt;安全防御：CDN 在广义上可以视作网站的堡垒机，源站只对 CDN 提供服务，由 CDN 来对外界其他用户服务，这样恶意攻击者就不容易直接威胁源站。CDN 对某些攻击手段的防御，如对&lt;a href=&#34;https://zh.wikipedia.org/zh-tw/%E9%98%BB%E6%96%B7%E6%9C%8D%E5%8B%99%E6%94%BB%E6%93%8A&#34;&gt;DDoS 攻击&lt;/a&gt;的防御尤其有效。但需注意，将安全都寄托在 CDN 上本身是不安全的，一旦源站真实 IP 被泄漏，就会面临很高的风险。&lt;/li&gt;
&lt;li&gt;协议升级：不少 CDN 提供商都同时对接（代售 CA 的）SSL 证书服务，可以实现源站是 HTTP 协议的，而对外开放的网站是基于 HTTPS 的。同理，可以实现源站到 CDN 是 HTTP/1.x 协议，CDN 提供的外部服务是 HTTP/2 或 HTTP/3 协议、实现源站是基于 IPv4 网络的，CDN 提供的外部服务支持 IPv6 网络，等等。&lt;/li&gt;
&lt;li&gt;状态缓存：第一节介绍客户端缓存时简要提到了状态缓存，CDN 不仅可以缓存源站的资源，还可以缓存源站的状态，譬如源站的 301/302 转向就可以缓存起来让客户端直接跳转、还可以通过 CDN 开启&lt;a href=&#34;https://es.wikipedia.org/wiki/HTTP_Strict_Transport_Security&#34;&gt;HSTS&lt;/a&gt;、可以通过 CDN 进行&lt;a href=&#34;https://zh.wikipedia.org/wiki/OCSP%E8%A3%85%E8%AE%A2&#34;&gt;OCSP 装订&lt;/a&gt;加速 SSL 证书访问，等等。有一些情况下甚至可以配置 CDN 对任意状态码（譬如 404）进行一定时间的缓存，以减轻源站压力，但这个操作应当慎重，在网站状态发生改变时去及时刷新缓存。&lt;/li&gt;
&lt;li&gt;修改资源：CDN 可以在返回资源给用户的时候修改它的任何内容，以实现不同的目的。譬如，可以对源站未压缩的资源自动压缩并修改 Content-Encoding，以节省用户的网络带宽消耗、可以对源站未启用客户端缓存的内容加上缓存 Header，自动启用客户端缓存，可以修改&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Glossary/CORS&#34;&gt;CORS&lt;/a&gt;的相关 Header，将源站不支持跨域的资源提供跨域能力，等等。&lt;/li&gt;
&lt;li&gt;访问控制：CDN 可以实现 IP 黑/白名单功能，根据不同的来访 IP 提供不同的响应结果，根据 IP 的访问流量来实现 QoS 控制、根据 HTTP 的 Referer 来实现防盗链，等等。&lt;/li&gt;
&lt;li&gt;注入功能：CDN 可以在不修改源站代码的前提下，为源站注入各种功能，比如国际 CDN 巨头 CloudFlare 提供的 Google Analytics、PACE、Hardenize 等第三方应用，在 CDN 下均能做到无须修改源站任何代码即可使用。&lt;/li&gt;
&lt;li&gt;绕过某些“不存在的”网络措施，这也是在国内申请 CDN 也必须实名备案的原因，就不细说了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;load-balancing&#34;&gt;Load Balancing&lt;/h1&gt;
&lt;p&gt;在互联网时代的早期，网站流量还相对较小，并且业务也比较简单，单台服务器便有可能满足访问需要，但时至今日，互联网应用也好，企业级应用也好，一般实际用于生产的系统，几乎都离不开集群部署了。信息系统不论是采用单体架构多副本部署还是微服务架构，不论是为了实现高可用还是为了获得高性能，都需要利用到多台机器来扩展服务能力，希望用户的请求不管连接到哪台机器上，都能得到相同的处理。另一方面，如何构建和调度服务集群这事情，又必须对用户一侧保持足够的透明，即使请求背后是由一千台、一万台机器来共同响应的，也绝非用户所关心的事情，用户需记住的只有一个域名地址而已。调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件被称为“负载均衡”（Load Balancing）。&lt;/p&gt;
&lt;p&gt;真正大型系统的负载均衡过程往往是多级的。譬如，在各地建有多个机房，或机房有不同网络链路入口的大型互联网站，会从 DNS 解析开始，通过“域名” → “CNAME” → “负载调度服务” → “就近的数据中心入口”的路径，先将来访地用户根据 IP 地址（或者其他条件）分配到一个合适的数据中心中，然后才到稍后将要讨论的各式负载均衡。在 DNS 层面的负载均衡与前面介绍的 DNS 智能线路、内容分发网络等，在工作原理上是类似的，其差别只是数据中心能提供的不仅有缓存，而是全方位的服务能力。由于这种方式此前已经详细讲解过，后续我们所讨论的“负载均衡”就只聚焦于网络请求进入数据中心入口之后的其他级次的负载均衡。&lt;/p&gt;
&lt;p&gt;无论在网关内部建立了多少级的负载均衡，从形式上来说都可以分为两种：四层负载均衡和七层负载均衡。四层负载均衡的优势是性能高，七层负载均衡的优势是功能强。做多级混合负载均衡，通常应是低层的负载均衡在前，高层的负载均衡在后。&lt;/p&gt;
&lt;p&gt;我们所说的“四层”、“七层”，指的是经典的&lt;a href=&#34;https://en.wikipedia.org/wiki/OSI_model&#34;&gt;OSI 七层模型&lt;/a&gt;中第四层传输层和第七层应用层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220214164402864.png&#34; alt=&#34;image-20220214164402864&#34;&gt;&lt;/p&gt;
&lt;p&gt;现在所说的“四层负载均衡”其实是多种均衡器工作模式的统称，“四层”的意思是说这些工作模式的共同特点是维持着同一个 TCP 连接，而不是说它只工作在第四层。事实上，这些模式主要都是工作在二层（数据链路层，改写 MAC 地址）和三层（网络层，改写 IP 地址）上，单纯只处理第四层（传输层，可以改写 TCP、UDP 等协议的内容和端口）的数据无法做到负载均衡的转发，因为 OSI 的下三层是媒体层（Media Layers），上四层是主机层（Host Layers），既然流量都已经到达目标主机上了，也就谈不上什么流量转发，最多只能做代理了。&lt;/p&gt;
&lt;h2 id=&#34;数据链路层负载均衡&#34;&gt;数据链路层负载均衡&lt;/h2&gt;
&lt;p&gt;数据链路层传输的内容是数据帧（Frame），譬如常见的以太网帧、ADSL 宽带的 PPP 帧等。按照&lt;a href=&#34;https://en.wikipedia.org/wiki/IEEE_802.3&#34;&gt;IEEE 802.3&lt;/a&gt;标准，最典型的 1500 Bytes MTU 的以太网帧结构如表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;数据项&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;取值&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;前导码&lt;/td&gt;
&lt;td&gt;10101010 7 Bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;帧开始符&lt;/td&gt;
&lt;td&gt;10101011 1 Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAC 目标地址&lt;/td&gt;
&lt;td&gt;6 Bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MAC 源地址&lt;/td&gt;
&lt;td&gt;6 Bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/IEEE_802.1Q&#34;&gt;802.1Q&lt;/a&gt;标签（可选）&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Ethertype&#34;&gt;以太类型&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2 Bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;有效负载&lt;/td&gt;
&lt;td&gt;1500 Bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C&#34;&gt;冗余校验&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;4 Bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E5%B8%A7%E9%97%B4%E8%B7%9D&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;帧间距&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;12 Bytes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每一块网卡都有独立的 MAC 地址，以太帧上这“MAC 目标地址”和“MAC 源地址”告诉了交换机，此帧应该是从连接在交换机上的哪个端口的网卡发出，送至哪块网卡的。&lt;/p&gt;
&lt;p&gt;数据链路层负载均衡所做的工作，是修改请求的数据帧中的 MAC 目标地址，让用户原本是发送给负载均衡器的请求的数据帧，被二层交换机根据新的 MAC 目标地址转发到服务器集群中对应的服务器（后文称为“真实服务器”，Real Server）的网卡上，这样真实服务器就获得了一个原本目标并不是发送给它的数据帧。&lt;/p&gt;
&lt;p&gt;由于二层负载均衡器在转发请求过程中只修改了帧的 MAC 目标地址，不涉及更上层协议（没有修改 Payload 的数据），所以在更上层（第三层）看来，所有数据都是未曾被改变过的。由于第三层的数据包，即 IP 数据包中包含了源（客户端）和目标（均衡器）的 IP 地址，只有真实服务器保证自己的 IP 地址与数据包中的目标 IP 地址一致，这个数据包才能被正确处理。因此，使用这种负载均衡模式时，需要把真实物理服务器集群所有机器的&lt;a href=&#34;https://en.wikipedia.org/wiki/Virtual_IP_address&#34;&gt;虚拟 IP 地址&lt;/a&gt;（Virtual IP Address，VIP）配置成与负载均衡器的虚拟 IP 一样，这样经均衡器转发后的数据包就能在真实服务器中顺利地使用。也正是因为实际处理请求的真实物理服务器 IP 和数据请求中的目的 IP 是一致的，所以响应结果就不再需要通过负载均衡服务器进行地址交换，可将响应结果的数据包直接从真实服务器返回给用户的客户端，避免负载均衡器网卡带宽成为瓶颈，因此数据链路层的负载均衡效率是相当高的。整个请求到响应的过程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/image-20220215135643227.png&#34; alt=&#34;image-20220215135643227&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述只有请求经过负载均衡器，而服务的响应无须从负载均衡器原路返回的工作模式，整个请求、转发、响应的链路形成一个“三角关系”，所以这种负载均衡模式也常被很形象地称为“三角传输模式”（Direct Server Return，DSR），也有叫“单臂模式”（Single Legged Mode）或者“直接路由”（Direct Routing）。&lt;/p&gt;
&lt;p&gt;虽然数据链路层负载均衡效率很高，但它并不能适用于所有的场合，除了那些需要感知应用层协议信息的负载均衡场景它无法胜任外（所有的四层负载均衡器都无法胜任，将在后续介绍七层均衡器时一并解释），它在网络一侧受到的约束也很大。二层负载均衡器直接改写目标 MAC 地址的工作原理决定了&lt;strong&gt;它与真实的服务器的通信必须是二层可达的，通俗地说就是必须位于同一个子网当中，无法跨 VLAN&lt;/strong&gt;。优势（效率高）和劣势（不能跨子网）共同决定了数据链路层负载均衡最适合用来做数据中心的第一级均衡设备，用来连接其他的下级负载均衡器。&lt;/p&gt;
&lt;h2 id=&#34;网络层负载均衡&#34;&gt;网络层负载均衡&lt;/h2&gt;
&lt;p&gt;根据 OSI 七层模型，在第三层网络层传输的单位是分组数据包（Packets），这是一种在&lt;a href=&#34;https://en.wikipedia.org/wiki/Packet_switching&#34;&gt;分组交换网络&lt;/a&gt;（Packet Switching Network，PSN）中传输的结构化数据单位。以 IP 协议为例，一个 IP 数据包由 Headers 和 Payload 两部分组成， Headers 长度最大为 60 Bytes，其中包括了 20 Bytes 的固定数据和最长不超过 40 Bytes 的可选的额外设置组成。按照 IPv4 标准，一个典型的分组数据包的 Headers 部分具有如表所示的结构：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;长度&lt;/th&gt;
&lt;th&gt;存储信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0-4 Bytes&lt;/td&gt;
&lt;td&gt;版本号（4 Bits）、首部长度（4 Bits）、分区类型（8 Bits)、总长度（16 Bits）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5-8 Bytes&lt;/td&gt;
&lt;td&gt;报文计数标识（16 Bits）、标志位（4 Bits）、片偏移（12 Bits）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9-12 Bytes&lt;/td&gt;
&lt;td&gt;TTL 生存时间（8 Bits）、上层协议代号（8 Bits）、首部校验和（16 Bits）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13-16 Bytes&lt;/td&gt;
&lt;td&gt;源地址（32 Bits）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17-20 Bytes&lt;/td&gt;
&lt;td&gt;目标地址（32 Bits）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20-60 Bytes&lt;/td&gt;
&lt;td&gt;可选字段和空白填充&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;源和目标 IP 地址代表了数据是从分组交换网络中哪台机器发送到哪台机器的，我们可以沿用与二层改写 MAC 地址相似的思路，通过改变这里面的 IP 地址来实现数据包的转发。具体有两种常见的修改方式。&lt;/p&gt;
&lt;p&gt;第一种是保持原来的数据包不变，新创建一个数据包，把原来数据包的 Headers 和 Payload 整体作为另一个新的数据包的 Payload，在这个新数据包的 Headers 中写入真实服务器的 IP 作为目标地址，然后把它发送出去。经过三层交换机的转发，真实服务器收到数据包后，必须在接收入口处设计一个针对性的拆包机制，把由负载均衡器自动添加的那层 Headers 扔掉，还原出原来的数据包来进行使用。这样，真实服务器就同样拿到了一个原本不是发给它（目标 IP 不是它）的数据包，达到了流量转发的目的。设计者给这种“套娃式”的传输起名叫做“&lt;a href=&#34;https://en.wikipedia.org/wiki/IP_tunnel&#34;&gt;IP 隧道&lt;/a&gt;”（IP Tunnel）传输。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/&#34;&gt;http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/&lt;/a&gt;&lt;/p&gt;
- https://www.openheart.icu/cs/transparent-multilevel-diversion-system/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Remote Procedure Call</title>
        <link>https://www.openheart.icu/cs/remote-procedure-call/</link>
        <pubDate>Mon, 15 Nov 2021 23:28:00 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/remote-procedure-call/</guid>
        <description>42th openheart https://www.openheart.icu/cs/remote-procedure-call/ -&lt;h1 id=&#34;inter-process-communication&#34;&gt;Inter-Process Communication&lt;/h1&gt;
&lt;h2 id=&#34;pipe&#34;&gt;Pipe&lt;/h2&gt;
&lt;h2 id=&#34;signal&#34;&gt;Signal&lt;/h2&gt;
&lt;h2 id=&#34;semaphore&#34;&gt;Semaphore&lt;/h2&gt;
&lt;h2 id=&#34;message-queue&#34;&gt;Message Queue&lt;/h2&gt;
&lt;h2 id=&#34;shared-memory&#34;&gt;Shared Memory&lt;/h2&gt;
&lt;h2 id=&#34;socket&#34;&gt;Socket&lt;/h2&gt;
&lt;h1 id=&#34;8-fallacies-of-distributed-computinghttpsenwikipediaorgwikifallacies_of_distributed_computing&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing&#34;&gt;8 Fallacies of Distributed Computing&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;1994 - 1997, ACM 和 Sun 院士&lt;a href=&#34;https://en.wikipedia.org/wiki/L._Peter_Deutsch&#34;&gt;Peter Deutsch&lt;/a&gt;、套接字接口发明者&lt;a href=&#34;https://en.wikipedia.org/wiki/Bill_Joy&#34;&gt;Bill Joy&lt;/a&gt;、Java 之父&lt;a href=&#34;https://en.wikipedia.org/wiki/James_Gosling&#34;&gt;James Gosling&lt;/a&gt;等一众在 Sun Microsystems 工作的大佬们共同总结了&lt;a href=&#34;https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing&#34;&gt;通过网络进行分布式运算的八宗罪&lt;/a&gt;（8 Fallacies of Distributed Computing）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The network is reliable —— 网络是可靠的。&lt;/li&gt;
&lt;li&gt;Latency is zero —— 延迟是不存在的。&lt;/li&gt;
&lt;li&gt;Bandwidth is infinite —— 带宽是无限的。&lt;/li&gt;
&lt;li&gt;The network is secure —— 网络是安全的。&lt;/li&gt;
&lt;li&gt;Topology doesn&amp;rsquo;t change —— 拓扑结构是一成不变的。&lt;/li&gt;
&lt;li&gt;There is one administrator —— 总会有一个管理员。&lt;/li&gt;
&lt;li&gt;Transport cost is zero —— 不必考虑传输成本。&lt;/li&gt;
&lt;li&gt;The network is homogeneous —— 网络是同质化（Homogeneous networks are networks where all the nodes have the same function in the network.）的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/Homogeneous_vs._Heterogeneous_Networks.png&#34; alt=&#34;Homogeneous vs. Heterogeneous Networks&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/PARC_(company)&#34;&gt;施乐 Palo Alto 研究中心&lt;/a&gt;首次提出远程服务调用的定义&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Remote procedure call is the synchronous language-level transfer of control between programs in disjoint address spaces whose primary communication medium is a narrow channel.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;远程服务调用是指位于互不重合的内存地址空间中的两个程序，在语言层面上，以同步的方式使用带宽有限的信道来传输程序控制信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://icyfenix.cn/assets/img/rpc.38c28315.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-basic-questions&#34;&gt;3 Basic Questions&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;20 世纪 80 年代中后期，惠普和 Apollo 提出了&lt;a href=&#34;https://en.wikipedia.org/wiki/Network_Computing_System&#34;&gt;网络运算架构&lt;/a&gt;（Network Computing Architecture，NCA）的设想，并随后在&lt;a href=&#34;https://en.wikipedia.org/wiki/Distributed_Computing_Environment&#34;&gt;DCE 项目&lt;/a&gt;中将其发展成在 UNIX 系统下的远程服务调用框架&lt;a href=&#34;https://zh.wikipedia.org/wiki/DCE/RPC&#34;&gt;DCE/RPC&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;微软 COM/DCOM 的前身&lt;a href=&#34;https://en.wikipedia.org/wiki/Microsoft_RPC&#34;&gt;MS RPC&lt;/a&gt;算是 DCE 的一种变体版本。&lt;/p&gt;
&lt;p&gt;在 1988 年，Sun Microsystems 起草并向&lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force&#34;&gt;互联网工程任务组&lt;/a&gt;（Internet Engineering Task Force，IETF）提交了&lt;a href=&#34;https://tools.ietf.org/html/rfc1050&#34;&gt;RFC 1050&lt;/a&gt;规范，此规范中设计了一套面向于广域网或混合网络环境的、基于 TCP/IP 的、支持 C 语言的 RPC 协议，后被称为&lt;a href=&#34;https://en.wikipedia.org/wiki/Open_Network_Computing_Remote_Procedure_Call&#34;&gt;ONC RPC&lt;/a&gt;（Open Network Computing RPC，也被称为 Sun RPC）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;如何表示数据&#34;&gt;如何表示数据&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;数据包括了传递给方法的参数，以及方法执行后的返回值。无论是将参数传递给另外一个进程，还是从另外一个进程中取回执行结果，都涉及到它们应该如何表示。进程内的方法调用，使用程序语言预置的和程序员自定义的数据类型，就很容易解决数据表示问题，远程方法调用则完全可能面临交互双方各自使用不同程序语言的情况；即使只支持一种程序语言的 RPC 协议，在不同硬件指令集、不同操作系统下，同样的数据类型也完全可能有不一样表现细节，譬如数据宽度、字节序的差异等等。有效的做法是将交互双方所涉及的数据转换为某种事先约定好的中立数据流格式来进行传输，将数据流转换回不同语言中对应的数据类型来进行使用，这个过程说起来拗口，但相信大家一定很熟悉，就是序列化与反序列化。每种 RPC 协议都应该要有对应的序列化协议，譬如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ONC RPC 的&lt;a href=&#34;https://en.wikipedia.org/wiki/External_Data_Representation&#34;&gt;External Data Representation&lt;/a&gt; （XDR）&lt;/li&gt;
&lt;li&gt;CORBA 的&lt;a href=&#34;https://en.wikipedia.org/wiki/Common_Data_Representation&#34;&gt;Common Data Representation&lt;/a&gt;（CDR）&lt;/li&gt;
&lt;li&gt;Java RMI 的&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html#a10258&#34;&gt;Java Object Serialization Stream Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;gRPC 的&lt;a href=&#34;https://developers.google.com/protocol-buffers&#34;&gt;Protocol Buffers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Web Service 的&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/standard/serialization/xml-serialization-with-xml-web-services&#34;&gt;XML Serialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;众多轻量级 RPC 支持的&lt;a href=&#34;https://tools.ietf.org/html/rfc7159&#34;&gt;JSON Serialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;如何传递数据&#34;&gt;如何传递数据&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;如何通过网络，在两个服务的 Endpoint 之间相互操作、交换数据。这里“交换数据”通常指的是应用层协议，实际传输一般是基于标准的 TCP、UDP 等标准的传输层协议来完成的。两个服务交互不是只扔个序列化数据流来表示参数和结果就行的，许多在此之外信息，譬如异常、超时、安全、认证、授权、事务，等等，都可能产生双方需要交换信息的需求。在计算机科学中，专门有一个名称“&lt;a href=&#34;https://en.wikipedia.org/wiki/Wire_protocol&#34;&gt;Wire Protocol&lt;/a&gt;”来用于表示这种两个 Endpoint 之间交换这类数据的行为，常见的 Wire Protocol 有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java RMI 的&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/platform/rmi/spec/rmi-protocol3.html&#34;&gt;Java Remote Message Protocol&lt;/a&gt;（JRMP，也支持&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=RMI-IIOP&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;RMI-IIOP&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;CORBA 的&lt;a href=&#34;https://en.wikipedia.org/wiki/General_Inter-ORB_Protocol&#34;&gt;Internet Inter ORB Protocol&lt;/a&gt;（IIOP，是 GIOP 协议在 IP 协议上的实现版本）&lt;/li&gt;
&lt;li&gt;DDS 的&lt;a href=&#34;https://en.wikipedia.org/wiki/Data_Distribution_Service&#34;&gt;Real Time Publish Subscribe Protocol&lt;/a&gt;（RTPS）&lt;/li&gt;
&lt;li&gt;Web Service 的&lt;a href=&#34;https://en.wikipedia.org/wiki/SOAP&#34;&gt;Simple Object Access Protocol&lt;/a&gt;（SOAP）&lt;/li&gt;
&lt;li&gt;如果要求足够简单，双方都是 HTTP Endpoint，直接使用 HTTP 协议也是可以的（如 JSON-RPC）&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;如何确定方法&#34;&gt;如何确定方法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这在本地方法调用中并不是太大的问题，编译器或者解释器会根据语言规范，将调用的方法签名转换为进程空间中子过程入口位置的指针。不过一旦要考虑不同语言，事情又立刻麻烦起来，每门语言的方法签名都可能有所差别，所以“如何表示同一个方法”，“如何找到对应的方法”还是得弄个跨语言的统一的标准才行。这个标准做起来可以非常简单，譬如直接给程序的每个方法都规定一个唯一的、在任何机器上都绝不重复的编号，调用时压根不管它什么方法签名是如何定义的，直接传这个编号就能找到对应的方法。这种听起既粗鲁又寒碜的办法，还真的就是 DCE/RPC 当初准备的解决方案。虽然最终 DCE 还是弄出了一套语言无关的&lt;a href=&#34;https://en.wikipedia.org/wiki/Interface_description_language&#34;&gt;接口描述语言&lt;/a&gt;（Interface Description Language，IDL），成为此后许多 RPC 参考或依赖的基础（如 CORBA 的 OMG IDL），但那个唯一的绝不重复的编码方案&lt;a href=&#34;https://en.wikipedia.org/wiki/Universally_unique_identifier&#34;&gt;UUID&lt;/a&gt;（Universally Unique Identifier）却也被保留且广为流传开来，今天已广泛应用于程序开发的方方面面。类似地，用于表示方法的协议还有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android 的&lt;a href=&#34;https://developer.android.com/guide/components/aidl&#34;&gt;Android Interface Definition Language&lt;/a&gt;（AIDL）&lt;/li&gt;
&lt;li&gt;CORBA 的&lt;a href=&#34;https://www.omg.org/spec/IDL&#34;&gt;OMG Interface Definition Language&lt;/a&gt;（OMG IDL）&lt;/li&gt;
&lt;li&gt;Web Service 的&lt;a href=&#34;https://zh.wikipedia.org/wiki/WSDL&#34;&gt;Web Service Description Language&lt;/a&gt;（WSDL）&lt;/li&gt;
&lt;li&gt;JSON-RPC 的&lt;a href=&#34;https://en.wikipedia.org/wiki/JSON-WSP&#34;&gt;JSON Web Service Protocol&lt;/a&gt;（JSON-WSP）&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;那些面向透明的、简单的 RPC 协议，如 DCE/RPC、DCOM、Java RMI，要么依赖于操作系统，要么依赖于特定语言，总有一些先天约束；那些面向通用的、普适的 RPC 协议；如 CORBA，就无法逃过使用复杂性的困扰，CORBA 烦琐的 OMG IDL、ORB 都是很好的佐证；而那些意图通过技术手段来屏蔽复杂性的 RPC 协议，如 Web Service，又不免受到性能问题的束缚。简单、普适、高性能这三点，似乎真的难以同时满足。&lt;/p&gt;
&lt;p&gt;由于一直没有一个同时满足以上三点的“完美 RPC 协议”出现，所以远程服务器调用这个小小的领域里，已经相继出现过 RMI（Sun/Oracle）、Thrift（Facebook/Apache）、Dubbo（阿里巴巴/Apache）、gRPC（Google）、Motan1/2（新浪）、Finagle（Twitter）、brpc（百度/Apache）、.NET Remoting（微软）、Arvo（Hadoop）、JSON-RPC 2.0（公开规范，JSON-RPC 工作组）……等等难以穷举的协议和框架。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;朝着&lt;strong&gt;面向对象&lt;/strong&gt;发展，不满足于 RPC 将面向过程的编码方式带到分布式，希望在分布式系统中也能够进行跨进程的面向对象编程，代表为 RMI、&lt;a href=&#34;https://zh.wikipedia.org/wiki/.NET_Remoting&#34;&gt;.NET Remoting&lt;/a&gt;(已集成到&lt;a href=&#34;https://en.wikipedia.org/wiki/Windows_Communication_Foundation&#34;&gt;WCF&lt;/a&gt;中)，之前的 CORBA 和 DCOM 也可以归入这类，这条线有一个别名叫做&lt;a href=&#34;https://en.wikipedia.org/wiki/Distributed_object&#34;&gt;分布式对象&lt;/a&gt;（Distributed Object）。&lt;/li&gt;
&lt;li&gt;朝着&lt;strong&gt;性能&lt;/strong&gt;发展，代表为 gRPC 和 Thrift。决定 RPC 性能的主要就两个因素：序列化效率和信息密度。序列化效率很好理解，序列化输出结果的容量越小，速度越快，效率自然越高；信息密度则取决于协议中有效荷载（Payload）所占总传输数据的比例大小，使用传输协议的层次越高，信息密度就越低，SOAP 使用 XML 拙劣的性能表现就是前车之鉴。gRPC 和 Thrift 都有自己优秀的专有序列化器，而传输协议方面，gRPC 是基于 HTTP/2 的，支持多路复用和 Header 压缩，Thrift 则直接基于传输层的 TCP 协议来实现，省去了额外应用层协议的开销。&lt;/li&gt;
&lt;li&gt;朝着&lt;strong&gt;简化&lt;/strong&gt;发展，代表为 JSON-RPC，说要选功能最强、速度最快的 RPC 可能会很有争议，但选功能弱的、速度慢的，JSON-RPC 肯定会候选人中之一。牺牲了功能和效率，换来的是协议的简单轻便，接口与格式都更为通用，尤其适合用于 Web 浏览器这类一般不会有额外协议支持、额外客户端支持的应用场合。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Andrew Tanenbaum, 1987, &lt;a href=&#34;https://www.cs.vu.nl/~ast/Publications/Papers/euteco-1988.pdf&#34;&gt;A Critique of The Remote Procedure Call Paradigm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bruce Jay Nelson，&lt;a href=&#34;http://www.bitsavers.org/pdf/xerox/parc/techReports/CSL-81-9_Remote_Procedure_Call.pdf&#34;&gt;Remote Procedure Call&lt;/a&gt;，Xerox PARC，1981&lt;/li&gt;
&lt;li&gt;惠普 Apollo, &lt;a href=&#34;https://en.wikipedia.org/wiki/Network_Computing_System&#34;&gt;网络运算架构&lt;/a&gt;（Network Computing Architecture，NCA）&lt;/li&gt;
&lt;li&gt;Michi Henning, &lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/1142031.1142044&#34;&gt;The Rise and Fall of CORBA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-netod/bfd49902-36d7-4479-bf75-a2431bd99039&#34;&gt;MS-NETOD: .NET Remoting | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/dotnet/framework/wcf/migrating-from-net-remoting-to-wcf&#34;&gt;Migrating from .NET Remoting to WCF - WCF | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://guides.co/g/the-network-effects-bible/121732&#34;&gt;Homogeneous vs. Heterogeneous Networks | The Network Effects Bible | Guides&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/remote-procedure-call/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>AWS</title>
        <link>https://www.openheart.icu/cs/aws/</link>
        <pubDate>Sun, 17 Oct 2021 11:35:34 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/aws/</guid>
        <description>42th openheart https://www.openheart.icu/cs/aws/ -&lt;h1 id=&#34;s3&#34;&gt;S3&lt;/h1&gt;
&lt;h2 id=&#34;access-to-s3-object&#34;&gt;Access to S3 Object&lt;/h2&gt;
&lt;h3 id=&#34;notes&#34;&gt;Notes:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Add permission &lt;code&gt;AmazonS3ReadOnlyAccess&lt;/code&gt; for IMA User.&lt;/li&gt;
&lt;li&gt;If you use postman, set Authorization to AWS Signature type. Fill the field &lt;code&gt;AccessKey&lt;/code&gt; &amp;amp; &lt;code&gt;SecretKey&lt;/code&gt; &amp;amp; &lt;code&gt;AWS Region&lt;/code&gt; &amp;amp; &lt;code&gt;Service Name&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If you use Infor File Server, add Additional properties for AWS S3 servers. It contains &lt;code&gt;aws_region&lt;/code&gt;, and you need set the full path to the External Bucket Name.&lt;/li&gt;
&lt;li&gt;Unlike standard Windows file systems, the &lt;strong&gt;Amazon S3 storage is case-sensitive&lt;/strong&gt;. Unfortunately, Infor File Server always uses lowercase path!&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/aws/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>CI/CD</title>
        <link>https://www.openheart.icu/cs/cicd/</link>
        <pubDate>Sun, 17 Oct 2021 11:35:34 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/cicd/</guid>
        <description>42th openheart https://www.openheart.icu/cs/cicd/ -&lt;h1 id=&#34;what-is-cicd&#34;&gt;What is CI/CD?&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;In &lt;a href=&#34;https://en.wikipedia.org/wiki/Software_engineering&#34;&gt;software engineering&lt;/a&gt;, &lt;strong&gt;CI/CD&lt;/strong&gt; or &lt;strong&gt;CICD&lt;/strong&gt; is the combined practices of &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_integration&#34;&gt;continuous integration&lt;/a&gt; (CI) and either &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_delivery&#34;&gt;continuous delivery&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Continuous_deployment&#34;&gt;continuous deployment&lt;/a&gt; (CD).&lt;/p&gt;
&lt;p&gt;CI/CD bridges the gaps between development and operation activities and teams by enforcing automation in building, testing and deployment of applications. The process contrasts with traditional methods where all updates were integrated into one large batch before rolling out the newer version. Modern day &lt;a href=&#34;https://en.wikipedia.org/wiki/DevOps&#34;&gt;DevOps&lt;/a&gt; practices involve continuous development, continuous testing, continuous integration, continuous deployment and continuous monitoring of software applications throughout its development life cycle. The CI/CD practice, or &lt;em&gt;CI/CD pipeline&lt;/em&gt;, forms the backbone of modern day DevOps operations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;continuous-integration&#34;&gt;Continuous integration&lt;/h2&gt;
&lt;p&gt;这个阶段应该是在VCS下，codebase要对每个MR进行自动化的build，甚至自动化的run unit testing。目的是为了保证merge的代码是OK的。&lt;/p&gt;
&lt;h2 id=&#34;continuous-delivery&#34;&gt;Continuous delivery&lt;/h2&gt;
&lt;p&gt;已经完成CI的代码表示可以交付给用户，此时的代码应该是随时都可以部署到生产环境中。&lt;/p&gt;
&lt;h2 id=&#34;continuous-deployment&#34;&gt;Continuous deployment&lt;/h2&gt;
&lt;p&gt;这个应该是重点，要自动部署可能基于cloud更为方便。CD过程可以更好的与蓝绿部署/滚动发布/灰度发布相结合，对用户&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/CI/CD&#34;&gt;https://en.wikipedia.org/wiki/CI/CD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.redhat.com/en/topics/devops/what-is-ci-cd&#34;&gt;https://www.redhat.com/en/topics/devops/what-is-ci-cd&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
- https://www.openheart.icu/cs/cicd/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>CSAPP</title>
        <link>https://www.openheart.icu/cs/csapp/</link>
        <pubDate>Sun, 17 Oct 2021 11:35:34 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/csapp/</guid>
        <description>42th openheart https://www.openheart.icu/cs/csapp/ -&lt;h1 id=&#34;issues&#34;&gt;ISSUES&lt;/h1&gt;
&lt;h2 id=&#34;application-binary-interface&#34;&gt;Application binary interface&lt;/h2&gt;
&lt;h2 id=&#34;区分高可靠性与高可用性&#34;&gt;区分高可靠性与高可用性&lt;/h2&gt;
&lt;p&gt;Reliability和Availability分别对应可靠性和可用性, 这两个概念既有区别也有联系:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reliability定义为一个服务连续无故障运行的时间，无故障运行的时间越长，可靠性就越高。&lt;/li&gt;
&lt;li&gt;Availiability定义为在足够长的时间里，比如一年的时间里，一个服务可用的时间，服务可用时间越长越好。一般用可服务时间除于总时间算出一个百分比，用百分比作为度量。比如一个服务如果有5个9的可用性，指的就是一年里99.999%时间里服务都是可用的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有两个极端的例子可以很好的说明这两个概念的区别:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假想一个服务，可靠性很高，平均来说可以稳定运行10年，但是一旦服务中断，要用一年的时间来恢复，那么它的可用性只有90%。&lt;/li&gt;
&lt;li&gt;假想另一个服务，可靠性很差，运行10秒就会宕机，但是恢复服务只需要1ms, 那么它的可用性是99.99%&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从这两个极端的例子可以看出，提高可用性有两条路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一是提高可靠性，当然影响可靠性的原因有很多，包括硬件，软件，网络，运维等。但是有人做过统计，软件的bug是影响可靠性的最主要的因素。并且提高软件质量相较于使用更可靠的硬件也算成本较低的方式了，&lt;/li&gt;
&lt;li&gt;二是减少恢复时间，一旦出现宕机，如果能在秒级恢复，那对业务影响是很小的。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;高可靠性的实现&#34;&gt;高可靠性的实现&lt;/h3&gt;
&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;高可用性的实现&#34;&gt;高可用性的实现&lt;/h3&gt;
&lt;p&gt;高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。&lt;/p&gt;
&lt;h4 id=&#34;在设计高可用性策略时应该首先考虑下述因素&#34;&gt;在设计高可用性策略时应该首先考虑下述因素&lt;/h4&gt;
&lt;p&gt;​    • RTO（Recovery Time Objective）-也就是恢复时间目标，意味着允许多少宕机时间，通常用几个9表示，比如说99.999%的可用性意味着每年的宕机时间不超过5分钟、99.99%的可用性意味着每年的宕机时间不超过52.5分钟、99.9%的可用性意味着每年的宕机时间不超过8.75小时。值得注意的是，RTO的计算方法要考虑系统是24*365，还是仅仅是上午6点到下午9点等。您还需要注意是否维护窗口的时间在算在宕机时间之内，如果允许在维护窗口时间进行数据库维护和打补丁，则更容易实现更高的可用性。&lt;/p&gt;
&lt;p&gt;​    • RPO（Recovery Point Objective）-也就是恢复点目标，意味着允许多少数据损失。通常只要做好备份，可以比较容易的实现零数据损失。但当灾难发生时，取决于数据库损坏的程度，从备份恢复数据所需要的时间会导致数据库不可用，这会影响RTO的实现。一个早期比较著名的例子是某欧美的银行系统，只考虑的RPO，系统里只存在了完整备份和日志备份，每3个月一次完整备份，每15分钟一次日志备份，当灾难发生时，只能够通过完整备份和日志备份来恢复数据，因此虽然没有数据丢失，但由于恢复数据花了整整两天时间，造成银行系统2天时间不可用，因此流失了大量客户。另外一个相反的例子是国内某在线视频网站，使用SQL Server作为后端关系数据库，前端使用了No-SQL，定期将No-SQL的数据导入关系数据库作为备份，当灾难发生时最多允许丢失一天的数据，但是要保证高可用性。&lt;/p&gt;
&lt;h4 id=&#34;高可用的实现&#34;&gt;高可用的实现&lt;/h4&gt;
&lt;p&gt;整个互联网分层系统架构的高可用，又是通过每一层的&lt;strong&gt;冗余+自动故障转移&lt;/strong&gt;来综合实现的，具体的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移&lt;/li&gt;
&lt;li&gt;【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移&lt;/li&gt;
&lt;li&gt;【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移&lt;/li&gt;
&lt;li&gt;【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性&lt;/li&gt;
&lt;li&gt;【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移&lt;/li&gt;
&lt;li&gt;【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;sqlserver所支持的高可用特性&#34;&gt;SQlServer所支持的高可用特性&lt;/h4&gt;
&lt;p&gt;SQL Server中所支持的高可用性功能与版本息息相关，企业版支持所有的高可用性功能，这些功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;故障转移集群&lt;/li&gt;
&lt;li&gt;数据库镜像（在SQL Server 2012中被标记为“过时”）&lt;/li&gt;
&lt;li&gt;事务日志传送&lt;/li&gt;
&lt;li&gt;数据库快照&lt;/li&gt;
&lt;li&gt;AlwaysOn可用性组&lt;/li&gt;
&lt;li&gt;热加载内存&lt;/li&gt;
&lt;li&gt;在线索引操作&lt;/li&gt;
&lt;li&gt;数据库部分在线（只还原了主文件组或主文件组和额外的NDF文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;故障转移集群&#34;&gt;故障转移集群&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;故障转移集群为整个SQL Server实例提供高可用性支持，这意味着在集群上某个节点的SQL Server实例发生了硬件错误、操作系统错误等会故障转移到该集群上的其它节点。通过多个服务器（节点）共享一个或多个磁盘来实现高可用性，故障转移集群在网络中出现的方式就像单台计算机一样，但是具有高可用特性。值得注意的是，由于故障转移集群是基于共享磁盘，因此会存在磁盘单点故障，因此需要在磁盘层面部署SAN复制等额外的保护措施。常见的故障转移集群是双节点的故障转移集群，包括主主节点和主从节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;事务日志传送&#34;&gt;事务日志传送&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;事务日志传送提供了数据库级别的高可用性保护。日志传送可用来维护相应生产数据库（称为“主数据库”）的一个或多个备用数据库（称为“辅助数据库”）。发生故障转移之前，必须通过手动应用全部未还原的日志备份来完全更新辅助数据库。日志传送具有支持多个备用数据库的灵活性。如果需要多个备用数据库，可以单独使用日志传送或将其作为数据库镜像的补充。当这些解决方案一起使用时，当前数据库镜像配置的主体数据库同时也是当前日志传送配置的主数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务日志传送可用于做冷备份和暖备份的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;数据库镜像&#34;&gt;数据库镜像&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据库镜像实际上是个软件解决方案，同样提供了数据库级别的保护，可提供几乎是瞬时的故障转移，以提高数据库的可用性。数据库镜像可以用来维护相应生产数据库（称为“主体数据库”）的单个备用数据库（或“镜像数据库”）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为镜像数据库一直处于还原状态，但并不会恢复数据库，因此无法直接访问镜像数据库。但是，为了用于报表等只读的负载，可创建镜像数据库的数据库快照来间接地使用镜像数据库。数据库快照为客户端提供了快照创建时对数据库中数据的只读访问。每个数据库镜像配置都涉及包含主体数据库的“主体服务器”，并且还涉及包含镜像数据库的镜像服务器。镜像服务器不断地使镜像数据库随主体数据库一起更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库镜像在高安全性模式下以同步操作运行，或在高性能模式下以异步操作运行。在高性能模式下，事务不需要等待镜像服务器将日志写入磁盘便可提交，这样可较大程度地提高性能。在高安全性模式下，已提交的事务将由伙伴双方提交，但会延长事务滞后时间。数据库镜像的最简单配置仅涉及主体服务器和镜像服务器。在该配置中，如果主体服务器丢失，则该镜像服务器可以用作备用服务器，但可能会造成数据丢失。高安全性模式支持具有自动故障转移功能的备用配置高安全性模式。这种配置涉及到称为“见证服务器”的第三方服务器实例，它能够使镜像服务器用作热备份服务器。从主体数据库至镜像数据库的故障转移通常要用几秒钟的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库镜像可用于做暖备份和热备份。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;复制&#34;&gt;复制&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;复制严格来说并不算是一个为高可用性设计的功能，但的确可以被应用于高可用性。复制提供了数据库对象级别的保护。复制使用的是发布-订阅模式，即由主服务器（称为发布服务器）向一个或多个辅助服务器或订阅服务器发布数据。复制可在这些服务器间提供实时的可用性和可伸缩性。它支持筛选，以便为订阅服务器提供数据子集，同时还支持分区更新。订阅服务器处于联机状态，并且可用于报表或其他功能，而无需进行查询恢复。SQL Server 提供四种复制类型：快照复制、事务复制、对等复制以及合并复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;alwayson可用性组&#34;&gt;AlwaysOn可用性组&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;AlwaysOn可用性组是SQL Server 2012推出的新功能。同样提供了数据库级别的保护。它取数据库镜像和故障转移集群之长，使得业务上有关联的数据库作为一个可用性组共同故障转移，该功能还拓展了数据库镜像只能1对1的限制，使得1个主副本可以对应最多4个辅助副本（在SQL Server 2014中，该限制被拓展到8个），其中2个辅助副本可以被作为热备份和主副本实时同步，而另外两个异步辅助副本可以作为暖备份。此外，辅助副本还可以被配置为只读，并可用于承担备份的负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;处理器中的流水线&#34;&gt;处理器中的流水线&lt;/h2&gt;
&lt;p&gt;在现代处理器中，流水线是一个最基本的概念。在了解cpu的时候，很多时候会提及拥有多少级流水线。虽然这个概念并不是在计算机技术中诞生的，但是这个技术却在处理器世界中大放异彩。&lt;/p&gt;
&lt;p&gt;流水线(Pipeline)技术是指程序在执行时候多条指令重叠进行操作的一种准并行处理实现技术。通俗的讲将一个时序过程，分解成若干个子过程，每个过程都能有效的与其他子过程同时执行。这种思想最初是在RISC的架构中出现的，旨在提高处理器处理效率，争取在一个时钟周期中完成一条指令。&lt;/p&gt;
&lt;p&gt;最经典的当属MIPS(无内部互锁的流水线处理器)的五级流水线技术。MIPS体系结构本身就是为了流水线而设计的，cpu在高速缓存中运行，每条指令的执行过程都分成五级。每一级成为一个流水线阶段，每个阶段占用固定的时间，通常是一个时钟周期。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BF1365345053_3598.jpg&#34; alt=&#34;五级流水线&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图是MIPS的五级流水线&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IF(instruction fetch)&lt;/code&gt;：从指令高速缓存中获取下一条指令。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RD(Read register)&lt;/code&gt;：从指定的源寄存器域中指定的cpu寄存器中读取数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ALU(arithmetic/logic  unit)&lt;/code&gt;：算术和逻辑运算操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MEM(memory R/W)&lt;/code&gt;：读写数据高速缓存中的内存变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WB(Write back)&lt;/code&gt;：将结果写入寄存器堆中。&lt;/p&gt;
&lt;p&gt;很明显，如果只执行一条指令的话，流水线是不会提高效率的。但是如果要完成多条指令，利用流水线的并行原理，其实是可以提高几倍的处理速度。&lt;/p&gt;
&lt;p&gt;由于流水线技术的高效性，后来所有的处理器都引进了该实现，当然包括x86的处理器，当年奔四号称20级的流水线结构。但是，是不是流水线级数越多越好呢？流水线级数越多，在处理多指令的时候确实也会越高效，但必然以高成本为代价，同时也会出现很多相关的一些副作用。&lt;/p&gt;
&lt;p&gt;流水线的更多详细说明可以参阅更多书籍或者wiki。对于基础书籍推荐一下《&lt;em&gt;大话处理器&lt;/em&gt;》的部分章节。&lt;/p&gt;
&lt;h2 id=&#34;处理器中的冒险&#34;&gt;处理器中的冒险&lt;/h2&gt;
&lt;p&gt;流水线给处理器带来了效率，当然也有问题。称之为流水线冒险(HaZard)。&lt;/p&gt;
&lt;h3 id=&#34;结构冒险&#34;&gt;结构冒险&lt;/h3&gt;
&lt;p&gt;由于处理器资源冲突，而无法实现某些指令或者阶段的组合实现，就称之为处理器有结构冒险。&lt;/p&gt;
&lt;p&gt;比如，早期的处理器中，程序和数据是存储在一起的，那么容易出现下图的情况：在第四个cycle中，IF和MEM同时访问存储器导致有一个操作要等待，此时hazard就出现了。现在的处理器已经解决了该问题：指令存储在L1P cache中，数据存储L1D cache中，单独访问，不会影响相互操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A91365345110_7686.jpg&#34; alt=&#34;结构冒险&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据冒险&#34;&gt;数据冒险&lt;/h3&gt;
&lt;p&gt;如果流水线中原来有先后顺序的指令同一时刻处理时，可能会导致出现访问了错误的数据的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A91365345212_2478.jpg&#34; alt=&#34;数据冒险&#34;&gt;&lt;/p&gt;
&lt;p&gt;在汇编语句中，add R1,R2,R3 将寄存器R2和R3的和赋予R1，改变R1的值；而紧接着下面的语句：add R4,R1,R5则会使用R1的值，可是R1必须在第一条语句中的第5个cycle才能更新到寄存器中，语句二是在第4个cycle就要访问R1，也就是说第二,条指令此时在使用错误的R1的值。这是数据hazard出现了。&lt;/p&gt;
&lt;p&gt;很容易就能想到一种方式解决：在两条指令中添加一条空指令：nop。但是会影响处理器的指令的执行效率。在现代处理器技术中，已经用forwarding的方式解决了。如下图，如果处理器在检测到当前指令的源操作数正好在流水线的EX或者MEM阶段，接直接将ex和mem寄存器的值传递给ALU的输入，而不是再从寄存器堆中获取数据了。因为此时寄存器堆中的数据可能是没有被及时更新的。&lt;/p&gt;
&lt;p&gt;当然不仅在EX阶段有这种问题出现，在mem阶段也容易出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/KrisNie/ImageHosting/main/Blog/%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A91365345292_2683.jpg&#34; alt=&#34;解决数据冒险&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;控制冒险&#34;&gt;控制冒险&lt;/h3&gt;
&lt;p&gt;在流水线中的的执行指令时，由于并行处理的关系，后面很多指令其实都在流水线中开始处理了，包括预取值和译码。那么，如果此时程序中出现一条跳转语句怎么办呢？因为程序已经跑到其他地址处执行，流水线中之前已经做好的预取值和译码动作都不能使用了。这些会被处理器的专有部件flush掉，重新开始新的流水线。此时我们可以称之为出现了控制hazard。这种情况对于程序和效率来说是存在很大损失的。&lt;/p&gt;
&lt;p&gt;当然，我们也有解决方案，也就是在jump指令后面(不会被真正使用，但是会进入流水线)添加nop。在MIPS程序中，经常在jump指令后面添加nop语句。&lt;/p&gt;
&lt;p&gt;在X86架构中，是通过硬件来实现flush，将无效的流水线排空，以保证正确运行流水线。这里会涉及到分支预测技术的使用。&lt;/p&gt;
&lt;p&gt;在其他一些处理器中，用软件的方式来处理，添加nop。同时在编译器中通过乱序的思想用有效指令代替nop。这样也可以避免转跳带来的性能损失。&lt;/p&gt;
- https://www.openheart.icu/cs/csapp/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Database</title>
        <link>https://www.openheart.icu/cs/database/</link>
        <pubDate>Sun, 17 Oct 2021 11:35:34 +0000</pubDate>
        
        <guid>https://www.openheart.icu/cs/database/</guid>
        <description>42th openheart https://www.openheart.icu/cs/database/ -&lt;h1 id=&#34;mysql&#34;&gt;MySQL&lt;/h1&gt;
&lt;h2 id=&#34;install-mysql&#34;&gt;Install MySQL&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;lsb_release -a						&lt;span style=&#34;color:#228b22&#34;&gt;# 查看操作系统版本&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# LSB Version:	:core-4.1-amd64:core-4.1-noarch&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# Distributor ID:	CentOS&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# Description:	CentOS Linux release 7.8.2003 (Core)&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# Release:	7.8.2003&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# Codename:	Core&lt;/span&gt;

cat /etc/redhat-release		&lt;span style=&#34;color:#228b22&#34;&gt;# 查看Linux内核版本&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# CentOS Linux release 7.8.2003 (Core)&lt;/span&gt;

getconf LONG_BIT					&lt;span style=&#34;color:#228b22&#34;&gt;# 查看系统位数&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# 64&lt;/span&gt;

yum -y update							&lt;span style=&#34;color:#228b22&#34;&gt;# 更新 yum&lt;/span&gt;
rpm -qa | grep mysql			&lt;span style=&#34;color:#228b22&#34;&gt;# 查看是否安装过MySQL&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;# 此处版本为在CentOS7下安装MySQL8.0&lt;/span&gt;
wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm

&lt;span style=&#34;color:#228b22&#34;&gt;# 安装&lt;/span&gt;
sudo yum localinstall mysql80-community-release-el7-3.noarch.rpm

&lt;span style=&#34;color:#228b22&#34;&gt;# 此时检查是否安装过 rpm -qa | grep mysql 显示：（端口默认为80）&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;#mysql80-community-release-el7-3.noarch&lt;/span&gt;

&lt;span style=&#34;color:#228b22&#34;&gt;# 禁用 mysql8.0:&lt;/span&gt;
sudo yum-config-manager --disable mysql80-community

&lt;span style=&#34;color:#228b22&#34;&gt;# 启用 mysql8.0&lt;/span&gt;
sudo yum-config-manager --enable mysql80-community

&lt;span style=&#34;color:#228b22&#34;&gt;# 校验当前启用(enable)的 mysql 版本是否为 5.7:&lt;/span&gt;
yum repolist enabled | grep mysql
&lt;span style=&#34;color:#228b22&#34;&gt;# mysql-connectors-community/x86_64 MySQL Connectors Community                 165&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# mysql-tools-community/x86_64      MySQL Tools Community                      115&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# mysql80-community/x86_64          MySQL 8.0 Community Server                 193&lt;/span&gt;

&lt;span style=&#34;color:#228b22&#34;&gt;# 安装MySQL&lt;/span&gt;
sudo yum install -y mysql-community-server

&lt;span style=&#34;color:#228b22&#34;&gt;# 启动 mysql 服务&lt;/span&gt;
sudo service mysqld start

&lt;span style=&#34;color:#228b22&#34;&gt;# 查看 mysql 服务状态&lt;/span&gt;
sudo service mysqld status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;# 查看初始密码&lt;/span&gt;
sudo grep &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;temporary password&amp;#39;&lt;/span&gt; /var/log/mysqld.log

&lt;span style=&#34;color:#228b22&#34;&gt;# 使用初始密码进行登录&lt;/span&gt;
mysql -u root -p

&lt;span style=&#34;color:#228b22&#34;&gt;# 登录成功之后设置新密码&lt;/span&gt;
ALTER USER &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;root&amp;#39;&lt;/span&gt;@&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt; IDENTIFIED BY &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;123456&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#228b22&#34;&gt;# 创建用户&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# 允许本地 IP（localhost, 127.0.0.1）访问：&lt;/span&gt;
create user &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;@&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt; identified by &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;123456&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#228b22&#34;&gt;# 允许任何 IP 访问：&lt;/span&gt;
create user &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;@&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;%&amp;#39;&lt;/span&gt; identified by &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;123456&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#228b22&#34;&gt;# 刷新权限&lt;/span&gt;
FLUSH PRIVILEGES;

&lt;span style=&#34;color:#228b22&#34;&gt;# 8.0版本后&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# 创建账户&lt;/span&gt;
create user &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;root&amp;#39;&lt;/span&gt;@&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;172.16.10.203&amp;#39;&lt;/span&gt; identified by  &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;password&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# 赋予权限，with grant option这个选项表示该用户可以将自己拥有的权限授权给别人&lt;/span&gt;
grant all privileges on *.* to &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;root&amp;#39;&lt;/span&gt;@&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;172.16.10.203&amp;#39;&lt;/span&gt; with grant option;
&lt;span style=&#34;color:#228b22&#34;&gt;# 改密码&amp;amp;授权超用户，flush privileges 命令本质上的作用是将当前user和privilige表中的用户信息/权限设置从mysql库(MySQL数据库的内置库)中提取到内存里&lt;/span&gt;
flush privileges;

&lt;span style=&#34;color:#228b22&#34;&gt;# 修改host 将kris用作登录账户名&lt;/span&gt;
update mysql.user &lt;span style=&#34;color:#658b00&#34;&gt;set&lt;/span&gt; &lt;span style=&#34;color:#00688b&#34;&gt;host&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;%&amp;#39;&lt;/span&gt; where &lt;span style=&#34;color:#00688b&#34;&gt;User&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Kris&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;postgresql&#34;&gt;PostgreSQL&lt;/h1&gt;
&lt;h2 id=&#34;operation&#34;&gt;Operation&lt;/h2&gt;
&lt;h2 id=&#34;issue&#34;&gt;Issue&lt;/h2&gt;
&lt;h3 id=&#34;postgres-full-text-search-a-search-engine-in-a-databasehttpsblogcrunchydatacomblogpostgres-full-text-search-a-search-engine-in-a-database&#34;&gt;&lt;a href=&#34;https://blog.crunchydata.com/blog/postgres-full-text-search-a-search-engine-in-a-database&#34;&gt;Postgres Full-Text Search: A Search Engine in a Database&lt;/a&gt;&lt;/h3&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.postgresql.org/docs/&#34;&gt;https://www.postgresql.org/docs/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;oracle&#34;&gt;Oracle&lt;/h1&gt;
&lt;h2 id=&#34;common-operation&#34;&gt;Common Operation&lt;/h2&gt;
&lt;h3 id=&#34;删除操作前一定要先执行一遍查询&#34;&gt;删除操作前一定要先执行一遍查询&lt;/h3&gt;
&lt;p&gt;如题， 带的一个新员工做补丁把项目历史数据干掉了 My bad.&lt;/p&gt;
&lt;p&gt;2020-8-7&lt;/p&gt;
&lt;h2 id=&#34;optimize&#34;&gt;Optimize&lt;/h2&gt;
&lt;h3 id=&#34;索引失效&#34;&gt;索引失效&lt;/h3&gt;
&lt;p&gt;SQL在&lt;code&gt;WHERE&lt;/code&gt;条件里面使用了&lt;code&gt;IN&lt;/code&gt;导致有一个关联表的索引失效，Oracle版本为11g&lt;/p&gt;
&lt;p&gt;条件中有or，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引&lt;/p&gt;
&lt;p&gt;like查询是以%开头&lt;/p&gt;
&lt;p&gt;如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引&lt;/p&gt;
&lt;h3 id=&#34;分库-分表-分区&#34;&gt;分库 分表 分区&lt;/h3&gt;
&lt;h3 id=&#34;视图优化&#34;&gt;视图优化&lt;/h3&gt;
&lt;h4 id=&#34;基表增加索引&#34;&gt;基表增加索引&lt;/h4&gt;
&lt;p&gt;对基表中，视图查询SQL的&lt;code&gt;WHERE&lt;/code&gt;条件中用到的字段增加索引&lt;/p&gt;
&lt;h4 id=&#34;重新进行表分析&#34;&gt;重新进行表分析&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- 视图查询慢
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;delete&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;

&lt;span style=&#34;color:#228b22&#34;&gt;-- 在当前用户下执行
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;analyze table &amp;#39;&lt;/span&gt;||&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;||&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; compute statistics;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;where&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;IN&lt;/span&gt; (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;tablename&amp;#39;&lt;/span&gt;);   

&lt;span style=&#34;color:#228b22&#34;&gt;-- 得到如下语句，将这些语句整体执行一遍
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;analyze&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; PRODUCT_REF_LIST_NESTEDTAB compute &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;statistics&lt;/span&gt;;
    &lt;span style=&#34;color:#228b22&#34;&gt;-- ....
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;-- 查看统计信息
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table_name&lt;/span&gt;,num_rows &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; user_tables;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分析的结果被Oracle用于基于成本的优化生成更好的查询计划。&lt;/p&gt;
&lt;p&gt;遇到当前表的查询或其他性能不好时，就可以对相应的表进行一次分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你的表经常由几千万变成几百万，又变成几千万那么需要制定分析计划定期表分析，同时可以一并分析索引，计算索引中数据的分布情况，这样CBO会选择更加准确的执行计划。&lt;/li&gt;
&lt;li&gt;如果表结构变化了也要做下，也就是经常对表做dml就需要分析，现在推荐使用dbms_stats包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;error&#34;&gt;ERROR&lt;/h2&gt;
&lt;h3 id=&#34;ora-01779-无法修改与非键值保存表对应的列&#34;&gt;ORA-01779: 无法修改与非键值保存表对应的列&lt;/h3&gt;
&lt;p&gt;这里要搞清楚三个概念：视图、联接视图、可更新的联接视图&lt;/p&gt;
&lt;h4 id=&#34;视图&#34;&gt;视图&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;视图&lt;/strong&gt;可以分为视图对象和内嵌视图两种。&lt;/p&gt;
&lt;p&gt;视图对象（View Object）&lt;/p&gt;
&lt;p&gt;数据库里的&lt;strong&gt;视图对象&lt;/strong&gt;跟一张表或索引等一样，是数据库对象中的一种，它其实是将基于表中原始数据的查询给虚拟了一层之后，提供给外部查询的一种对象。
其本质是并不保存查询的实际结果，而只是将查询语句保存在数据库中，当用户查询某张视图的时候，就会找到并执行这个视图的语句。
而&lt;strong&gt;联接视图&lt;/strong&gt;其实就是在一个视图中将两个表建立关联就是了。&lt;/p&gt;
&lt;p&gt;内嵌视图（Inline View）&lt;/p&gt;
&lt;p&gt;在SQL语句中，很多地方都可以写嵌套的语句，比如说，FROM后面可以套括号嵌套其他的语句，WHERE、SELECT、UPDATE、INSERT、DELETE后面都是可以写的。只是写的位置不同，执行的方式还有处理时的一些限制不同，这些SQL中嵌套的SQL被称为&lt;strong&gt;子查询（Subquery）&lt;/strong&gt; 。子查询可以分为如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内嵌视图：位置位于FROM语句中，也相当于一个预处理结果集的概念&lt;/li&gt;
&lt;li&gt;标量子查询（Scalar Subquery）：只返还一个结果值的子查询。位于SELECT语句的子查询只能返还一个值，所以必然是标量子查询，WHERE语句里也会出现这样的子查询&lt;/li&gt;
&lt;li&gt;关联子查询：将查询的结果传递给子查询作为参数的使用的形式&lt;/li&gt;
&lt;li&gt;一般子查询：除了那些特殊形式的子查询以外的一般用法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可更新联接视图（Updatable Join View ）&lt;/p&gt;
&lt;p&gt;将一个联接视图（包括视图对象和内嵌视图）放到UPADTE语句中这样的语法形式。&lt;/p&gt;
&lt;p&gt;同样的道理，如果只是用一个表来作为视图的基表，则可以对该视图直接进行&lt;code&gt;DELETE&lt;/code&gt;和&lt;code&gt;UPDATE&lt;/code&gt;，但无法直接执行&lt;code&gt;INSERT&lt;/code&gt;，因为该视图没有默认值的非空列(&lt;code&gt;brand_id&lt;/code&gt;)。该视图称为&lt;strong&gt;可更新视图&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;报错原理&#34;&gt;报错原理&lt;/h4&gt;
&lt;p&gt;Oracle的键值保存表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     ENAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     SAL              &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DEPTNO           &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
SCOTT   EMP_DEPT_V     DNAME            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;视图&lt;code&gt;EMP_DEPT_V&lt;/code&gt;里的字段都无法变更。&lt;/p&gt;
&lt;p&gt;如果能保证DEPT_T表里的数据是唯一的就能够更新。也就是说在DEPT_T表上加&lt;code&gt;主键约束&lt;/code&gt;或&lt;code&gt;唯一约束&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ALTER&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE&lt;/span&gt; DEPT_T
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CONSTRAINT&lt;/span&gt; PK_DEPT_T &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;PRIMARY&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;KEY&lt;/span&gt; (DEPTNO);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;再看一下之前的视图：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; *
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; DBA_UPDATABLE_COLUMNS
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;SCOTT&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;EMP_DEPT_V&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OWNER&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;TABLE_NAME&lt;/span&gt; | &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COLUMN_NAME&lt;/span&gt; | UPDATABLE | INSERTABLE | DELETABLE
SCOTT   EMP_DEPT_V     EMPNO            YES         YES         YES
SCOTT   EMP_DEPT_V     ENAME            YES         YES         YES
SCOTT   EMP_DEPT_V     SAL              YES         YES         YES
SCOTT   EMP_DEPT_V     DEPTNO           YES         YES         YES
SCOTT   EMP_DEPT_V     DNAME             &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;          &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个时候就可以看到，视图中&lt;code&gt;EMP_DEPT_V&lt;/code&gt;表中原来的字段都是可以更新的了。&lt;/p&gt;
&lt;p&gt;在对联接视图进行变更的时候，必须保证修改后的值是唯一的，并且这个事实要让数据库知道，而告知数据库的方法是建立主键约束或唯一约束。&lt;/p&gt;
&lt;p&gt;并不是所有的表都可以随意建这些约束，有什么方法能够不添加约束也能变更？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加&lt;code&gt;/*+ BYPASS_UJVC */&lt;/code&gt; 提示，让ORACLE跳过检查（11g R2之后无效，不建议使用）&lt;/li&gt;
&lt;li&gt;改写&lt;code&gt;UPDATE&lt;/code&gt;语句，通过其他方式判断后处理&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;UPDATE&lt;/code&gt;改成&lt;code&gt;MERGE&lt;/code&gt;语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;reference-1&#34;&gt;Reference&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Oracle：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The concept of a &lt;strong&gt;key-preserved table&lt;/strong&gt; is fundamental to understanding the restrictions on &lt;strong&gt;modifying join views&lt;/strong&gt;. A table is key-preserved if every key of the table can also be a key of the result of the join. So, a key-preserved table has its keys preserved through a join.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;An &lt;strong&gt;updatable join view&lt;/strong&gt; (also referred to as a &lt;strong&gt;modifiable join view&lt;/strong&gt;) is a view that contains multiple tables in the top-level FROM clause of the SELECT statement, and is not restricted by the WITH READ ONLY clause.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/60a56760b19f&#34;&gt;https://www.jianshu.com/p/60a56760b19f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yiibai.com/oracle/oracle-updatable-view.html&#34;&gt;https://www.yiibai.com/oracle/oracle-updatable-view.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sqlserver&#34;&gt;SQLServer&lt;/h1&gt;
&lt;h2 id=&#34;common-operation-1&#34;&gt;Common Operation&lt;/h2&gt;
&lt;h3 id=&#34;sqlcmd&#34;&gt;SQLCMD&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sqlcmd -S localhost -d CSI10 -q &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;SELECT * FROM SITE&amp;#34;&lt;/span&gt;
sqlcmd -S localhost -d CSI10 -Q &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;SELECT * FROM SITE&amp;#34;&lt;/span&gt;
sqlcmd -S localhost -U SA -Q &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;select @@VERSION&amp;#39;&lt;/span&gt;
sqlcmd -S localhost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;is-null&#34;&gt;IS NULL&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ISNULL&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;column&lt;/span&gt;, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;) &amp;lt;&amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;issues&#34;&gt;Issues&lt;/h2&gt;
&lt;h3 id=&#34;cannot-insert-explicit-value-for-identity-column-in-table-table-when-identity_insert-is-set-to-offhttpsstackoverflowcomquestions1334012cannot-insert-explicit-value-for-identity-column-in-table-table-when-identity&#34;&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1334012/cannot-insert-explicit-value-for-identity-column-in-table-table-when-identity&#34;&gt;Cannot insert explicit value for identity column in table &amp;lsquo;table&amp;rsquo; when IDENTITY_INSERT is set to OFF&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SET&lt;/span&gt; IDENTITY_INSERT Table1 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ON&lt;/span&gt;

&lt;span style=&#34;color:#228b22&#34;&gt;--Do INSERT
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SET&lt;/span&gt; IDENTITY_INSERT Table1 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OFF&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;sql-server-the-backup-set-holds-a-backup-of-a-database-other-than-the-existinghttpsstackoverflowcomquestions10204480sql-server-the-backup-set-holds-a-backup-of-a-database-other-than-the-existing&#34;&gt;&lt;a href=&#34;https://stackoverflow.com/questions/10204480/sql-server-the-backup-set-holds-a-backup-of-a-database-other-than-the-existing&#34;&gt;SQL-Server: The backup set holds a backup of a database other than the existing&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Don&amp;rsquo;t create an empty database and restore the &lt;code&gt;.bak&lt;/code&gt; file on to it.&lt;/li&gt;
&lt;li&gt;Use &lt;strong&gt;&amp;lsquo;Restore Database&amp;rsquo;&lt;/strong&gt; option accessible by right clicking the &amp;ldquo;Databases&amp;rdquo; branch of the SQL Server Management Studio and provide the database name while providing the source to restore.&lt;/li&gt;
&lt;li&gt;Also change the file names at &amp;ldquo;Files&amp;rdquo; if the other database still exists. Otherwise you get &amp;ldquo;The file &amp;lsquo;&amp;hellip;&amp;rsquo; cannot be overwritten. It is being used by database &amp;lsquo;yourFirstDb&amp;rsquo;&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;what-is-the-t-sql-syntax-to-connect-to-another-sql-serverhttpsstackoverflowcomquestions125457what-is-the-t-sql-syntax-to-connect-to-another-sql-server&#34;&gt;&lt;a href=&#34;https://stackoverflow.com/questions/125457/what-is-the-t-sql-syntax-to-connect-to-another-sql-server&#34;&gt;What is the T-SQL syntax to connect to another SQL Server?&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/sql/ssms/scripting/edit-sqlcmd-scripts-with-query-editor?view=sql-server-ver15&#34;&gt;Edit SQLCMD Scripts with Query Editor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In SQL Server Management Studio, turn on SQLCMD mode from the Query menu. Then at the top of your script, type in the command below&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;connect&lt;/span&gt; USDB -U sa -P mypassword
USE [&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;database&lt;/span&gt;]
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GO&lt;/span&gt;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; * &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; site;

:&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CONNECT&lt;/span&gt; CNDB
USE [&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;database&lt;/span&gt;]
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GO&lt;/span&gt;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; * &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; site;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: IntelliSense is turned off in the Database Engine Query Editor when the SQLCMD mode is set on.&lt;/p&gt;
&lt;h3 id=&#34;enable-xp_cmdshell-sql-serverhttpsstackoverflowcomquestions5131491enable-xp-cmdshell-sql-server&#34;&gt;&lt;a href=&#34;https://stackoverflow.com/questions/5131491/enable-xp-cmdshell-sql-server&#34;&gt;Enable &amp;lsquo;xp_cmdshell&amp;rsquo; SQL Server&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/xp-cmdshell-server-configuration-option?redirectedfrom=MSDN&amp;amp;view=sql-server-ver15&#34;&gt;If you need to enable &lt;strong&gt;xp_cmdshell&lt;/strong&gt;, you can use Policy-Based Managementhttps://docs.microsoft.com/en-us/sql/relational-databases/policy-based-management/administer-servers-by-using-policy-based-management?view=sql-server-ver15 or run the &lt;strong&gt;sp_configure&lt;/strong&gt; system stored procedure as shown in the following code example:&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- To allow advanced options to be changed.  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;EXECUTE&lt;/span&gt; sp_configure &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;show advanced options&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GO&lt;/span&gt;  
&lt;span style=&#34;color:#228b22&#34;&gt;-- To update the currently configured value for advanced options.  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;RECONFIGURE;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GO&lt;/span&gt;  
&lt;span style=&#34;color:#228b22&#34;&gt;-- To enable the feature.  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;EXECUTE&lt;/span&gt; sp_configure &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;xp_cmdshell&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GO&lt;/span&gt;  
&lt;span style=&#34;color:#228b22&#34;&gt;-- To update the currently configured value for this feature.  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;RECONFIGURE;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GO&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;use-xp_cmdshell-to-print-variables-into-a-file&#34;&gt;Use &amp;lsquo;xp_cmdshell&amp;rsquo; to print variables into a file&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- print variables 
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;DECLARE&lt;/span&gt; @cmdtxt &lt;span style=&#34;color:#658b00&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;4000&lt;/span&gt;);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; @cmdtxt = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;echo &amp;#39;&lt;/span&gt; +&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;@TtPmtpckCurrCode&amp;#39;&lt;/span&gt;+ &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CAST&lt;/span&gt;(@TtPmtpckCurrCode &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;))  + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;@CurrparmsCurrCode&amp;#39;&lt;/span&gt;+&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CAST&lt;/span&gt;(@CurrparmsCurrCode &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AS&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;)) +&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39; &amp;gt;&amp;gt; C:\Development\SubFolder\outPut.txt&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;exec&lt;/span&gt; master..xp_cmdshell @cmdtxt

&lt;span style=&#34;color:#228b22&#34;&gt;-- use FOR XML to print table-valued variable
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;declare&lt;/span&gt; @rates &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;table&lt;/span&gt; (
  curr_code CurrCodeType
, site_ref SiteType
, exch_rate ExchRateType
, rate_is_divisor ListYesNoType
, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;primary&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;key&lt;/span&gt; (curr_code, site_ref)
)

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;into&lt;/span&gt; @rates (curr_code, site_ref)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;distinct&lt;/span&gt; curr_code, site
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;from&lt;/span&gt; tt_pmtpck
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;where&lt;/span&gt; tt_pmtpck.ProcessId = @PProcessId
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;and&lt;/span&gt; (tt_pmtpck.exch_rate &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;or&lt;/span&gt; tt_pmtpck.dom_amt_applied &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;or&lt;/span&gt; tt_pmtpck.dom_disc_amt &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;)
  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;DECLARE&lt;/span&gt; @xmltmp xml = (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; rat.curr_code,rat.site_ref,rat.exch_rate,rat.rate_is_divisor &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; @rates &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AS&lt;/span&gt; rat &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FOR&lt;/span&gt; XML AUTO,ELEMENTS XSINIL);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; @cmdtxt = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;echo &amp;#39;&lt;/span&gt; +&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;@rates &amp;#34;&amp;#39;&lt;/span&gt;+ &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;CONVERT&lt;/span&gt;(&lt;span style=&#34;color:#658b00&#34;&gt;VARCHAR&lt;/span&gt;(&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;max&lt;/span&gt;),@xmltmp) + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;#34; &amp;gt;&amp;gt; C:\Development\SubFolder\outPut.txt&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;exec&lt;/span&gt; master..xp_cmdshell @cmdtxt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;offset-fetch--top&#34;&gt;Offset-Fetch &amp;amp; TOP&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;offset&lt;/code&gt;并不是万能的，在偏移量越来越大的情况性能表现会越来越差。解决方案为固定偏移量，分页之后用上次标签的行当做起点，使用类似&lt;code&gt;TOP&lt;/code&gt;方式再进行查询。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; * &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; demo_table &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; demo_column1=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; ((&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ISNULL&lt;/span&gt;(demo_column2, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;) &amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OR&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ISNULL&lt;/span&gt;(demo_column2, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;) = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AND&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ISNULL&lt;/span&gt;(demo_column3, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;) &amp;gt; &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;75&amp;#39;&lt;/span&gt;)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ORDER&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;BY&lt;/span&gt; demo_column1,demo_column2 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;OFFSET&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;49999&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ROWS&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FETCH&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;NEXT&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ROWS&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ONLY&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;reference-2&#34;&gt;Reference:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.microsoftpressstore.com/articles/article.aspx?p=2314819&#34;&gt;T-SQL Querying: TOP and OFFSET-FETCH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dba.stackexchange.com/questions/220326/reduce-query-time-for-higher-offset-in-sql-server&#34;&gt;Reduce query time for higher offset in sql server&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cannot-login-with-sa&#34;&gt;Cannot login with sa.&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;安装mss过程中如果没有设置sa和sa的密码，那可能&lt;code&gt;server authorization&lt;/code&gt;会被default成&lt;code&gt;Windows Authorization mode&lt;/code&gt;，sa 登录需要&lt;code&gt;SQL Server and Windows Authorization mode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;sa 需要enable login&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;the-difference-between-where-and-having&#34;&gt;The difference between WHERE and HAVING&lt;/h3&gt;
&lt;h4 id=&#34;where&#34;&gt;WHERE&lt;/h4&gt;
&lt;p&gt;In a single-table query, &lt;code&gt;WHERE&lt;/code&gt; comes in at the beginning of a query execution. We used to think that it determines which rows will be returned by the query, but this is not accurate:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;WHERE&lt;/code&gt; determines which rows will be processed by the query.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The difference becomes clear when we use a &lt;code&gt;GROUP BY&lt;/code&gt; clause.&lt;/p&gt;
&lt;h4 id=&#34;match&#34;&gt;MATCH&lt;/h4&gt;
&lt;h4 id=&#34;having&#34;&gt;HAVING&lt;/h4&gt;
&lt;p&gt;HAVING comes in at the end of a query execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;After all rows have been processed, &lt;code&gt;HAVING&lt;/code&gt; determines which of rows will be sent to the client.&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;text&lt;/strong&gt;, &lt;strong&gt;image&lt;/strong&gt;, and &lt;strong&gt;ntext&lt;/strong&gt; data types cannot be used in a HAVING clause.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;the-differences-with-group-by&#34;&gt;The differences with GROUP BY&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; site_ref, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COUNT&lt;/span&gt;(*) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AS&lt;/span&gt; num
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; item_mst
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; u_m = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;BX&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GROUP&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;BY&lt;/span&gt; site_ref
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;HAVING&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;COUNT&lt;/span&gt;(*) &amp;lt; &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;query-performance&#34;&gt;Query performance&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;In that case we’re telling the database to read all rows, and only return the ones that match the condition. This is unnecessarily slow.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;reference-3&#34;&gt;Reference:&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://sql-bits.com/the-difference-between-where-and-having/&#34;&gt;https://sql-bits.com/the-difference-between-where-and-having/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/sql/t-sql/queries/select-having-transact-sql?view=sql-server-ver15&#34;&gt;HAVING (Transact-SQL) - SQL Server | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/sql/t-sql/queries/match-sql-graph?view=sql-server-ver15&#34;&gt;MATCH (SQL Graph) - SQL Server | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/sql/t-sql/queries/where-transact-sql?view=sql-server-ver15&#34;&gt;WHERE (Transact-SQL) - SQL Server | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;delete-from-from&#34;&gt;Delete from from&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;FROM &lt;em&gt;table_source&lt;/em&gt;
Specifies an additional FROM clause. This Transact-SQL extension to DELETE allows specifying data from &amp;lt;table_source&amp;gt; and deleting the corresponding rows from the table in the first FROM clause.&lt;/p&gt;
&lt;p&gt;This extension, specifying a join, can be used instead of a subquery in the WHERE clause to identify rows to be removed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The following examples show two ways to delete rows in one table based on data in another table. In both examples, rows from the &lt;code&gt;SalesPersonQuotaHistory&lt;/code&gt; table in the AdventureWorks2012 database are deleted based on the year-to-date sales stored in the &lt;code&gt;SalesPerson&lt;/code&gt; table. The first &lt;code&gt;DELETE&lt;/code&gt; statement shows the ISO-compatible subquery solution, and the second &lt;code&gt;DELETE&lt;/code&gt; statement shows the Transact-SQL FROM extension to join the two tables.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- SQL-2003 Standard subquery  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;DELETE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; Sales.SalesPersonQuotaHistory   
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; BusinessEntityID &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;IN&lt;/span&gt;   
    (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;SELECT&lt;/span&gt; BusinessEntityID   
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; Sales.SalesPerson   
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; SalesYTD &amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2500000&lt;/span&gt;.&lt;span style=&#34;color:#b452cd&#34;&gt;00&lt;/span&gt;);  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GO&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- Transact-SQL extension  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;DELETE&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; Sales.SalesPersonQuotaHistory   
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt; Sales.SalesPersonQuotaHistory &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AS&lt;/span&gt; spqh  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;INNER&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;JOIN&lt;/span&gt; Sales.SalesPerson &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AS&lt;/span&gt; sp  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ON&lt;/span&gt; spqh.BusinessEntityID = sp.BusinessEntityID  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt; sp.SalesYTD &amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2500000&lt;/span&gt;.&lt;span style=&#34;color:#b452cd&#34;&gt;00&lt;/span&gt;;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;GO&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;-- No need to mention target table more than once.  
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;  
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;DELETE&lt;/span&gt; spqh  
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;FROM&lt;/span&gt;  
        Sales.SalesPersonQuotaHistory &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AS&lt;/span&gt; spqh  
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;INNER&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;JOIN&lt;/span&gt; Sales.SalesPerson &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;AS&lt;/span&gt; sp  
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;ON&lt;/span&gt; spqh.BusinessEntityID = sp.BusinessEntityID  
  &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;WHERE&lt;/span&gt;  sp.SalesYTD &amp;gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2500000&lt;/span&gt;.&lt;span style=&#34;color:#b452cd&#34;&gt;00&lt;/span&gt;;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;reference-4&#34;&gt;Reference：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/56453021/sql-server-delete-from-table-from-table&#34;&gt;SQL Server : DELETE FROM table FROM table&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/en-us/sql/t-sql/statements/delete-transact-sql?view=sql-server-2017#d-using-joins-and-subqueries-to-data-in-one-table-to-delete-rows-in-another-table&#34;&gt;DELETE (Transact-SQL) - SQL Server | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;redis&#34;&gt;Redis&lt;/h1&gt;
&lt;p&gt;MongoDB vs Redis&lt;/p&gt;
&lt;p&gt;MongoDB is a document-oriented, disk-based database optimized for operational simplicity, schema-free design and very large data volumes. &lt;em&gt;Redis is an in-memory, persistent data structure store that enables developers to perform common operations with minimal complexity and maximum performance.&lt;/em&gt; MongoDB and Redis are both NoSQL languages, but because they’re built for different purposes, Redis’ enhanced capabilities significantly augment MongoDB’s capabilities.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;issues-1&#34;&gt;ISSUES&lt;/h1&gt;
&lt;h2 id=&#34;orms&#34;&gt;ORMs&lt;/h2&gt;
&lt;h2 id=&#34;acidhttpsenwikipediaorgwikiacid&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/ACID&#34;&gt;ACID&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Atomicity 原子性
Transactions are often composed of multiple statements. Atomicity guarantees that each transaction is treated as a single &amp;ldquo;unit&amp;rdquo;, which either succeeds completely, or fails completely: if any of the statements constituting a transaction fails to complete, the entire transaction fails and the database is left unchanged. An atomic system must guarantee atomicity in each and every situation, including power failures, errors and crashes. A guarantee of atomicity prevents updates to the database occurring only partially, which can cause greater problems than rejecting the whole series outright. As a consequence, the transaction cannot be observed to be in progress by another database client. At one moment in time, it has not yet happened, and at the next it has already occurred in whole (or nothing happened if the transaction was cancelled in progress).&lt;/p&gt;
&lt;p&gt;An example of an atomic transaction is a monetary transfer from bank account A to account B. It consists of two operations, withdrawing the money from account A and saving it to account B. Performing these operations in an atomic transaction ensures that the database remains in a consistent state, that is, money is neither debited nor credited if either of those two operations fail.&lt;/p&gt;
&lt;p&gt;Consistency (Correctness) 一致性
&lt;strong&gt;Consistency ensures that a transaction can only bring the database from one valid state to another&lt;/strong&gt;, maintaining database invariants: any data written to the database must be valid according to all defined rules, including constraints, cascades, triggers, and any combination thereof. This prevents database corruption by an illegal transaction, but does not guarantee that a transaction is correct. Referential integrity guarantees the primary key – foreign key relationship.&lt;/p&gt;
&lt;p&gt;Isolation 隔离性
Transactions are often executed concurrently (e.g., multiple transactions reading and writing to a table at the same time). Isolation ensures that concurrent execution of transactions leaves the database in the same state that would have been obtained if the transactions were executed sequentially. Isolation is the main goal of concurrency control; depending on the method used, the effects of an incomplete transaction might not even be visible to other transactions.&lt;/p&gt;
&lt;p&gt;Durability 永久性
Durability guarantees that once a transaction has been committed, it will remain committed even in the case of a system failure (e.g., power outage or crash). This usually means that completed transactions (or their effects) are recorded in non-volatile memory.&lt;/p&gt;
&lt;h2 id=&#34;transactions&#34;&gt;Transactions&lt;/h2&gt;
&lt;h2 id=&#34;n1-problem&#34;&gt;N+1 Problem&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/97197/what-is-the-n1-selects-problem-in-orm-object-relational-mapping&#34;&gt;What is the &amp;ldquo;N+1 selects problem&amp;rdquo; in ORM (Object-Relational Mapping)?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;N+1是指，在两个表关联查询中，容易出现先查询主表，然后根据主表多次查询从表的情况。数据库执行语句此时为1+N。&lt;/p&gt;
&lt;p&gt;ORM可以使用相关method实现join。比如，在EF中可以使用&lt;code&gt;Include&lt;/code&gt;方法查询related数据。&lt;/p&gt;
&lt;h2 id=&#34;database-normalization&#34;&gt;Database Normalization&lt;/h2&gt;
&lt;h2 id=&#34;indexes-and-how-they-work&#34;&gt;Indexes and how they work&lt;/h2&gt;
&lt;p&gt;You can find relevant content in dotnet interview page.&lt;/p&gt;
&lt;h2 id=&#34;what-is-the-difference-between-varchar-and-nvarcharhttpsstackoverflowcomquestions144283what-is-the-difference-between-varchar-and-nvarchar&#34;&gt;&lt;a href=&#34;https://stackoverflow.com/questions/144283/what-is-the-difference-between-varchar-and-nvarchar&#34;&gt;What is the difference between varchar and nvarchar?&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;An &lt;code&gt;nvarchar&lt;/code&gt; column can store any Unicode data. A &lt;code&gt;varchar&lt;/code&gt; column is restricted to an 8-bit codepage. Some people think that &lt;code&gt;varchar&lt;/code&gt; should be used because it takes up less space. I believe this is not the correct answer. Codepage incompatabilities are a pain, and Unicode is the cure for codepage problems. With cheap disk and memory nowadays, there is really no reason to waste time mucking around with code pages anymore.&lt;/p&gt;
&lt;p&gt;All modern operating systems and development platforms use Unicode internally. By using &lt;code&gt;nvarchar&lt;/code&gt; rather than &lt;code&gt;varchar&lt;/code&gt;, you can avoid doing encoding conversions every time you read from or write to the database. Conversions take time, and are prone to errors. And recovery from conversion errors is a non-trivial problem.&lt;/p&gt;
&lt;p&gt;If you are interfacing with an application that uses only ASCII, I would still recommend using Unicode in the database. The OS and database collation algorithms will work better with Unicode. Unicode avoids conversion problems when interfacing with &lt;em&gt;other&lt;/em&gt; systems. And you will be preparing for the future. And you can always validate that your data is restricted to 7-bit ASCII for whatever legacy system you&amp;rsquo;re having to maintain, even while enjoying some of the benefits of full Unicode storage.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
- https://www.openheart.icu/cs/database/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Backtracking</title>
        <link>https://www.openheart.icu/arithmetic/backtracking/</link>
        <pubDate>Sun, 19 Sep 2021 17:15:26 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/backtracking/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/backtracking/ -&lt;h1 id=&#34;backtrackinghttpsenwikipediaorgwikibacktracking&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Backtracking&#34;&gt;Backtracking&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/&#34;&gt;17. Letter Combinations of a Phone Number&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;depth-first-searchdfshttpsenwikipediaorgwikidepth-first_search&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Depth-first_search&#34;&gt;Depth-First-Search，DFS&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/sudoku-solver/&#34;&gt;37. Sudoku Solver&lt;/a&gt;&lt;/p&gt;
- https://www.openheart.icu/arithmetic/backtracking/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
    
        <item>
        <title>Binary Search</title>
        <link>https://www.openheart.icu/arithmetic/binary-search/</link>
        <pubDate>Sun, 19 Sep 2021 17:15:26 +0000</pubDate>
        
        <guid>https://www.openheart.icu/arithmetic/binary-search/</guid>
        <description>42th openheart https://www.openheart.icu/arithmetic/binary-search/ -&lt;h1 id=&#34;binary-search-algorithmhttpsenwikipediaorgwikibinary_search_algorithm&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search_algorithm&#34;&gt;Binary Search Algorithm&lt;/a&gt;&lt;/h1&gt;
- https://www.openheart.icu/arithmetic/binary-search/ - ALL RIGHTS RESERVED KRIS NIE</description>
        </item>
    
    
  </channel>
</rss> 