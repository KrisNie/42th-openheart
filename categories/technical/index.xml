<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical on 42th openheart</title>
    <link>https://www.openheart.icu/categories/technical/</link>
    <description>Recent content in Technical on 42th openheart</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>ALL RIGHTS RESERVED KRIS NIE</copyright>
    <lastBuildDate>Sat, 30 Jul 2022 17:15:26 +0000</lastBuildDate><atom:link href="https://www.openheart.icu/categories/technical/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Banker&#39;s algorithm</title>
      <link>https://www.openheart.icu/arithmetic/bankers-algorithm/</link>
      <pubDate>Sat, 30 Jul 2022 17:15:26 +0000</pubDate>
      
      <guid>https://www.openheart.icu/arithmetic/bankers-algorithm/</guid>
      <description>Data Structure  可利用资源向量 Available ：含有 m 个元素的数组，其中每个元素代表一类可用的资源数目。Available[J] = K 表示系统中现有 R~j~ 类资源 K 个。 最大需求矩阵 Max ： n * m 矩阵，定义系统中 n 个进程中的每个进程对 m 类资源的最大需求。一行代表一个进程，一列代表一类资源。 Max[i,j] = K 表示进程 i 需要 R~j~ 类资源的最大数目是 K 。 分配矩阵 Allocation ： n * m 矩阵，定义系统中每类资源当前已分配给每个进程的资源数。 Allocation[i,j] = K 表示进程 i 当前已分得 R~j~ 类资源的数目为 K 。 需求矩阵 Need ： n * m 矩阵，表示每个进程接下来最多还需要多少资源。 Need[i,j] = K 表示进程 i 还需要 R~j~ 类资源的数目为K。  上述三个矩阵存在关系： Need = Max - Allocation</description>
    </item>
    
    <item>
      <title>Schema Security</title>
      <link>https://www.openheart.icu/computing-science/schema-security/</link>
      <pubDate>Tue, 19 Jul 2022 17:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/schema-security/</guid>
      <description>Authentication 系统如何正确分辨出操作用户的真实身份？
认证并不是仅仅是校验一下用户名、密码是否正确这么简单。
账户和权限信息作为一种必须最大限度保障安全和隐私，同时又要兼顾各个系统模块甚至系统间共享访问的基础主数据，它的存储、管理与使用都面临一系列复杂的问题。对于某些大规模的信息系统，账户和权限的管理往往要由专门的基础设施来负责，譬如微软的活动目录（Active Directory，AD）或者轻量目录访问协议（Lightweight Directory Access Protocol，LDAP），跨系统的共享使用甚至会用到区块链技术。
Authentication standards 基于 HTML 和 JavaScript 的超文本 Web 应用（B/S 系统）对最终用户认证的需求使得“安全认证”的重点逐渐从“代码级安全”转为“用户级安全”，即你是否信任正在操作的用户。
认证需要覆盖通信信道、协议和内容三个层面，而这三种层面认证恰好涵盖了主流的三种认证方式，具体含义和应用场景列举如下。
 通信信道上的认证：你和我建立通信连接之前，要先证明你是谁。在网络传输（Network）场景中的典型是基于 SSL/TLS 传输安全层的认证。 通信协议上的认证：你请求获取我的资源之前，要先证明你是谁。在互联网（Internet）场景中的典型是基于 HTTP 协议的认证。 通信内容上的认证：你使用我提供的服务之前，要先证明你是谁。在万维网（World Wide Web）场景中的典型是基于 Web 内容的认证。  HTTP Authentication 认证方案（Authentication Schemes），它是指生成用户身份凭证的某种方法，这个概念最初源于 HTTP 协议的认证框架（Authentication Framework）。
IETF 在RFC 7235中定义了 HTTP 协议的通用认证框架，要求所有支持 HTTP 协议的服务器，在未授权的用户意图访问服务端保护区域的资源时，应返回 401 Unauthorized 的状态码，同时应在响应报文头里附带以下两个分别代表网页认证和代理认证的 Header 之一，告知客户端应该采取何种方式产生能代表访问者身份的凭证信息：
WWW-Authenticate: &amp;lt;认证方案&amp;gt; realm=&amp;lt;保护区域的描述信息&amp;gt; Proxy-Authenticate: &amp;lt;认证方案&amp;gt; realm=&amp;lt;保护区域的描述信息&amp;gt; 接收到该响应后，客户端必须遵循服务端指定的认证方案，在请求资源的报文头中加入身份凭证信息，由服务端核实通过后才会允许该请求正常返回，否则将返回 403 Forbidden 错误。请求头报文应包含以下 Header 项之一：
Authorization: &amp;lt;认证方案&amp;gt; &amp;lt;凭证内容&amp;gt; Proxy-Authorization: &amp;lt;认证方案&amp;gt; &amp;lt;凭证内容&amp;gt; HTTP 认证框架提出认证方案是希望能把认证“要产生身份凭证”的目的与“具体如何产生凭证”的实现分离开来，无论客户端通过生物信息（指纹、人脸）、用户密码、数字证书抑或其他方式来生成凭证，都属于是如何生成凭证的具体实现，都可以包容在 HTTP 协议预设的框架之内。</description>
    </item>
    
    <item>
      <title>Dot Net 6&#43;</title>
      <link>https://www.openheart.icu/microsoft-dotnet/dot-net-6&#43;/</link>
      <pubDate>Wed, 25 May 2022 00:14:11 +0000</pubDate>
      
      <guid>https://www.openheart.icu/microsoft-dotnet/dot-net-6&#43;/</guid>
      <description>.Net6.0 Minimal APIs  Minimal APIs are architected to create HTTP APIs with minimal dependencies. They are ideal for microservices and apps that want to include only the minimum files, features, and dependencies in ASP.NET Core. For more information, see:
 Tutorial: Create a minimal web API with ASP.NET Core Differences between minimal APIs and APIs with controllers Minimal APIs overview Code samples migrated to the new minimal hosting model in 6.</description>
    </item>
    
    <item>
      <title>Technical debt</title>
      <link>https://www.openheart.icu/computing-science/technical-debt/</link>
      <pubDate>Tue, 19 Apr 2022 11:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/technical-debt/</guid>
      <description>Technical debt  Shipping first time code is like going into debt. A little debt speeds development so long as it is paid back promptly with a rewrite. Objects make the cost of this transaction tolerable. The danger occurs when the debt is not repaid. Every minute spent on not-quite-right code counts as interest on that debt. Entire engineering organizations can be brought to a stand-still under the debt load of an unconsolidated implementation, object- oriented or otherwise.</description>
    </item>
    
    <item>
      <title>Representational State Transfer</title>
      <link>https://www.openheart.icu/computing-science/representational-state-transfer/</link>
      <pubDate>Wed, 01 Dec 2021 14:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/representational-state-transfer/</guid>
      <description>What&amp;rsquo;s REST? Representational State Transfer, 表征状态转移
 比较容易理解 REST 思想的途径是先理解什么是 HTTP，再配合一些实际例子来进行类比，你会发现“REST”（Representational State Transfer）实际上是“HTT”（Hypertext Transfer）的进一步抽象，两者就如同接口与实现类的关系一般。
 Hypertext:
 By now the word &amp;ldquo;hypertext&amp;rdquo; has become generally accepted for branching and responding text, but the corresponding word &amp;ldquo;hypermedia&amp;rdquo;, meaning complexes of branching and responding graphics, movies and sound – as well as text – is much less used.
现在，&amp;ldquo;超文本 &amp;ldquo;一词已被普遍接受，它指的是能够进行分支判断和差异响应的文本，相应地， &amp;ldquo;超媒体 &amp;ldquo;一词指的是能够进行分支判断和差异响应的图形、电影和声音（也包括文本）的复合体。
—— Theodor Holm Nelson Literary Machines, 1992
 Resource  资源：譬如你现在正在阅读一篇有关REST的文章，这篇文章的内容本身（你可以将其理解为其蕴含的信息、数据）我们称之为“资源”。无论你是购买的书籍、是在浏览器看的网页、是打印出来看的文稿、是在电脑屏幕上阅读抑或是手机上浏览，尽管呈现的样子各不相同，但其中的信息是不变的，你所阅读的仍是同一份“资源”。</description>
    </item>
    
    <item>
      <title>Transactions</title>
      <link>https://www.openheart.icu/computing-science/transactions/</link>
      <pubDate>Wed, 01 Dec 2021 14:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/transactions/</guid>
      <description>ACID  事务处理几乎在每一个信息系统中都会涉及，它存在的意义是为了保证系统中所有的数据都是符合期望的，且相互关联的数据之间不会产生矛盾，即数据状态的一致性（Consistency）。
按照数据库的经典理论，要达成这个目标，需要三方面共同努力来保障。
 原子性（Atomic）：在同一项业务处理过程中，事务保证了对多个数据的修改，要么同时成功，要么同时被撤销。 隔离性（Isolation）：在不同的业务处理过程中，事务保证了各自业务正在读、写的数据互相独立，不会彼此影响。 持久性（Durability）：事务应当保证所有成功被提交的数据修改都能够正确地被持久化，不丢失数据。    场景事例
Fenix&amp;rsquo;s Bookstore 是一个在线书店。每当一本书被成功售出时，需要确保以下三件事情被正确地处理：
 用户的账号扣减相应的商品款项。 商品仓库中扣减库存，将商品标识为待配送状态。 商家的账号增加相应的商品款项。   Local Transaction Atomicity &amp;amp; Durability Commit Logging Crash Recovery 通常采用Commit Logging（提交日志）方式，只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化。
 In any database context, a &amp;ldquo;commit&amp;rdquo; is the application of a single transaction to the DB. A commit log is a record of transactions. It&amp;rsquo;s used to keep track of what&amp;rsquo;s happening, and help with e.</description>
    </item>
    
    <item>
      <title>Transparent Multilevel Diversion</title>
      <link>https://www.openheart.icu/computing-science/transparent-multilevel-diversion-system/</link>
      <pubDate>Wed, 01 Dec 2021 14:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/transparent-multilevel-diversion-system/</guid>
      <description>在用户使用信息系统的过程中，请求从浏览器出发，在域名服务器的指引下找到系统的入口，经过网关、负载均衡器、缓存、服务集群等一系列设施，最后触及到末端存储于数据库服务器中的信息，然后逐级返回到用户的浏览器之中。这其中要经过很多技术部件：
 有一些部件位于客户端或网络的边缘，能够迅速响应用户的请求，避免给后方的 I/O 与 CPU 带来压力，典型如本地缓存、内容分发网络、反向代理等。 有一些部件的处理能力能够线性拓展，易于伸缩，可以使用较小的代价堆叠机器来获得与用户数量相匹配的并发性能，应尽量作为业务逻辑的主要载体，典型如集群中能够自动扩缩的服务节点。 有一些部件稳定服务对系统运行有全局性的影响，要时刻保持着容错备份，维护着高可用性，典型如服务注册中心、配置中心。 有一些设施是天生的单点部件，只能依靠升级机器本身的网络、存储和运算性能来提升处理能力，如位于系统入口的路由、网关或者负载均衡器（它们都可以做集群，但一次网络请求中无可避免至少有一个是单点的部件）、位于请求调用链末端的传统关系数据库等，都是典型的容易形成单点部件。  对系统进行流量规划时，我们应该充分理解这些部件的价值差异，有两条简单、普适的原则能指导我们进行设计：
 第一条原则是尽可能减少单点部件，如果某些单点是无可避免的，则应尽最大限度减少到达单点部件的流量。在系统中往往会有多个部件能够处理、响应用户请求，譬如要获取一张存储在数据库的用户头像图片，浏览器缓存、内容分发网络、反向代理、Web 服务器、文件服务器、数据库都可能提供这张图片。恰如其分地引导请求分流至最合适的组件中，避免绝大多数流量汇集到单点部件（如数据库），同时依然能够在绝大多数时候保证处理结果的准确性，使单点系统在出现故障时自动而迅速地实施补救措施，这便是系统架构中多级分流的意义。 另一条更关键的原则是奥卡姆剃刀原则。作为一名架构设计者，你应对多级分流的手段有全面的理解与充分的准备，同时清晰地意识到这些设施并不是越多越好。在实际构建系统时，你应当在有明确需求、真正必要的时候再去考虑部署它们。不是每一个系统都要追求高并发、高可用的，根据系统的用户量、峰值流量和团队本身的技术与运维能力来考虑如何部署这些设施才是合理的做法，在能满足需求的前提下，最简单的系统就是最好的系统。  Client Cache Force Caching 假设在某个时点到来以前，譬如收到响应后的 10 分钟内，资源的内容和状态一定不会被改变，因此客户端可以无须经过任何请求，在该时点前一直持有和使用该资源的本地缓存副本。
根据约定，强制缓存在浏览器的地址输入、页面链接跳转、新开窗口、前进和后退中均可生效，但在用户主动刷新页面时应当自动失效。
 Expires  受限于客户端的本地时间。 无法处理涉及到用户身份的私有资源，譬如，某些资源被登录用户缓存在自己的浏览器上是合理的，但如果被代理服务器或者内容分发网络缓存起来，则可能被其他未认证的用户所获取。 无法描述“不缓存”的语义。譬如，浏览器为了提高性能，往往会自动在当次会话中缓存某些 MIME 类型的资源，在 HTTP/1.0 的服务器中就缺乏手段强制浏览器不允许缓存某个资源。以前为了实现这类功能，通常不得不使用脚本，或者手工在资源后面增加时间戳（譬如如“xx.js?t=1586359920”、“xx.jpg?t=1586359350”）来保证每次资源都会重新获取。 关于“不缓存”的语义，在 HTTP/1.0 中其实预留了“Pragma: no-cache”来表达，但 Pragma 参数在 HTTP/1.0 中并没有确切描述其具体行为，随后就被 HTTP/1.1 中出现过的 Cache-Control 所替代，现在，尽管主流浏览器通常都会支持 Pragma，但行为仍然是不确定的，实际并没有什么使用价值。   Cache-Control  Negotiate Caching 强制缓存是基于时效性的，但无论是人还是服务器，其实多数情况下都并没有什么把握去承诺某项资源多久不会发生变化。
根据约定，协商缓存不仅在浏览器的地址输入、页面链接跳转、新开窗口、前进、后退中生效，而且在用户主动刷新页面（F5）时也同样是生效的，只有用户强制刷新（Ctrl+F5）或者明确禁用缓存（譬如在 DevTools 中设定）时才会失效，此时客户端向服务端发出的请求会自动带有“Cache-Control: no-cache”。
 Last-Modified &amp;amp; If-Modified-Since ETag &amp;amp; If-None-Match  Etag 是 HTTP 中一致性最强的缓存机制，譬如，Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；又或者如果某些文件会被定期生成，可能内容并没有任何变化，但 Last-Modified 却改变了，导致文件无法有效使用缓存，这些情况 Last-Modified 都有可能产生资源一致性问题，只能使用 Etag 解决。</description>
    </item>
    
    <item>
      <title>Remote Procedure Call</title>
      <link>https://www.openheart.icu/computing-science/remote-procedure-call/</link>
      <pubDate>Mon, 15 Nov 2021 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/remote-procedure-call/</guid>
      <description>Inter-Process Communication Pipe Signal Semaphore Message Queue Shared Memory Socket 8 Fallacies of Distributed Computing 1994 - 1997, ACM 和 Sun 院士Peter Deutsch、套接字接口发明者Bill Joy、Java 之父James Gosling等一众在 Sun Microsystems 工作的大佬们共同总结了通过网络进行分布式运算的八宗罪（8 Fallacies of Distributed Computing）
  The network is reliable —— 网络是可靠的。 Latency is zero —— 延迟是不存在的。 Bandwidth is infinite —— 带宽是无限的。 The network is secure —— 网络是安全的。 Topology doesn&amp;rsquo;t change —— 拓扑结构是一成不变的。 There is one administrator —— 总会有一个管理员。 Transport cost is zero —— 不必考虑传输成本。 The network is homogeneous —— 网络是同质化（Homogeneous networks are networks where all the nodes have the same function in the network.</description>
    </item>
    
    <item>
      <title>AWS</title>
      <link>https://www.openheart.icu/computing-science/aws/</link>
      <pubDate>Sun, 17 Oct 2021 11:35:34 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/aws/</guid>
      <description>S3 Access to S3 Object Notes:  Add permission AmazonS3ReadOnlyAccess for IMA User. If you use postman, set Authorization to AWS Signature type. Fill the field AccessKey &amp;amp; SecretKey &amp;amp; AWS Region &amp;amp; Service Name. If you use Infor File Server, add Additional properties for AWS S3 servers. It contains aws_region, and you need set the full path to the External Bucket Name. Unlike standard Windows file systems, the Amazon S3 storage is case-sensitive.</description>
    </item>
    
    <item>
      <title>CI/CD</title>
      <link>https://www.openheart.icu/computing-science/cicd/</link>
      <pubDate>Sun, 17 Oct 2021 11:35:34 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/cicd/</guid>
      <description>What is CI/CD?  In software engineering, CI/CD or CICD is the combined practices of continuous integration (CI) and either continuous delivery or continuous deployment (CD).
CI/CD bridges the gaps between development and operation activities and teams by enforcing automation in building, testing and deployment of applications. The process contrasts with traditional methods where all updates were integrated into one large batch before rolling out the newer version. Modern day DevOps practices involve continuous development, continuous testing, continuous integration, continuous deployment and continuous monitoring of software applications throughout its development life cycle.</description>
    </item>
    
    <item>
      <title>CSAPP</title>
      <link>https://www.openheart.icu/computing-science/csapp/</link>
      <pubDate>Sun, 17 Oct 2021 11:35:34 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/csapp/</guid>
      <description>ISSUES Application binary interface 区分高可靠性与高可用性 Reliability和Availability分别对应可靠性和可用性, 这两个概念既有区别也有联系:
 Reliability定义为一个服务连续无故障运行的时间，无故障运行的时间越长，可靠性就越高。 Availiability定义为在足够长的时间里，比如一年的时间里，一个服务可用的时间，服务可用时间越长越好。一般用可服务时间除于总时间算出一个百分比，用百分比作为度量。比如一个服务如果有5个9的可用性，指的就是一年里99.999%时间里服务都是可用的。  有两个极端的例子可以很好的说明这两个概念的区别:
 假想一个服务，可靠性很高，平均来说可以稳定运行10年，但是一旦服务中断，要用一年的时间来恢复，那么它的可用性只有90%。 假想另一个服务，可靠性很差，运行10秒就会宕机，但是恢复服务只需要1ms, 那么它的可用性是99.99%  从这两个极端的例子可以看出，提高可用性有两条路:
 一是提高可靠性，当然影响可靠性的原因有很多，包括硬件，软件，网络，运维等。但是有人做过统计，软件的bug是影响可靠性的最主要的因素。并且提高软件质量相较于使用更可靠的硬件也算成本较低的方式了， 二是减少恢复时间，一旦出现宕机，如果能在秒级恢复，那对业务影响是很小的。   高可靠性的实现 &amp;hellip;
 高可用性的实现 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。
在设计高可用性策略时应该首先考虑下述因素 ​ • RTO（Recovery Time Objective）-也就是恢复时间目标，意味着允许多少宕机时间，通常用几个9表示，比如说99.999%的可用性意味着每年的宕机时间不超过5分钟、99.99%的可用性意味着每年的宕机时间不超过52.5分钟、99.9%的可用性意味着每年的宕机时间不超过8.75小时。值得注意的是，RTO的计算方法要考虑系统是24*365，还是仅仅是上午6点到下午9点等。您还需要注意是否维护窗口的时间在算在宕机时间之内，如果允许在维护窗口时间进行数据库维护和打补丁，则更容易实现更高的可用性。
​ • RPO（Recovery Point Objective）-也就是恢复点目标，意味着允许多少数据损失。通常只要做好备份，可以比较容易的实现零数据损失。但当灾难发生时，取决于数据库损坏的程度，从备份恢复数据所需要的时间会导致数据库不可用，这会影响RTO的实现。一个早期比较著名的例子是某欧美的银行系统，只考虑的RPO，系统里只存在了完整备份和日志备份，每3个月一次完整备份，每15分钟一次日志备份，当灾难发生时，只能够通过完整备份和日志备份来恢复数据，因此虽然没有数据丢失，但由于恢复数据花了整整两天时间，造成银行系统2天时间不可用，因此流失了大量客户。另外一个相反的例子是国内某在线视频网站，使用SQL Server作为后端关系数据库，前端使用了No-SQL，定期将No-SQL的数据导入关系数据库作为备份，当灾难发生时最多允许丢失一天的数据，但是要保证高可用性。
高可用的实现 整个互联网分层系统架构的高可用，又是通过每一层的冗余+自动故障转移来综合实现的，具体的：
 【客户端层】到【反向代理层】的高可用，是通过反向代理层的冗余实现的，常见实践是keepalived + virtual IP自动故障转移 【反向代理层】到【站点层】的高可用，是通过站点层的冗余实现的，常见实践是nginx与web-server之间的存活性探测与自动故障转移 【站点层】到【服务层】的高可用，是通过服务层的冗余实现的，常见实践是通过service-connection-pool来保证自动故障转移 【服务层】到【缓存层】的高可用，是通过缓存数据的冗余实现的，常见实践是缓存客户端双读双写，或者利用缓存集群的主从数据同步与sentinel保活与自动故障转移；更多的业务场景，对缓存没有高可用要求，可以使用缓存服务化来对调用方屏蔽底层复杂性 【服务层】到【数据库“读”】的高可用，是通过读库的冗余实现的，常见实践是通过db-connection-pool来保证自动故障转移 【服务层】到【数据库“写”】的高可用，是通过写库的冗余实现的，常见实践是keepalived + virtual IP自动故障转移  SQlServer所支持的高可用特性 SQL Server中所支持的高可用性功能与版本息息相关，企业版支持所有的高可用性功能，这些功能包括：
 故障转移集群 数据库镜像（在SQL Server 2012中被标记为“过时”） 事务日志传送 数据库快照 AlwaysOn可用性组 热加载内存 在线索引操作 数据库部分在线（只还原了主文件组或主文件组和额外的NDF文件）  故障转移集群  故障转移集群为整个SQL Server实例提供高可用性支持，这意味着在集群上某个节点的SQL Server实例发生了硬件错误、操作系统错误等会故障转移到该集群上的其它节点。通过多个服务器（节点）共享一个或多个磁盘来实现高可用性，故障转移集群在网络中出现的方式就像单台计算机一样，但是具有高可用特性。值得注意的是，由于故障转移集群是基于共享磁盘，因此会存在磁盘单点故障，因此需要在磁盘层面部署SAN复制等额外的保护措施。常见的故障转移集群是双节点的故障转移集群，包括主主节点和主从节点。  事务日志传送   事务日志传送提供了数据库级别的高可用性保护。日志传送可用来维护相应生产数据库（称为“主数据库”）的一个或多个备用数据库（称为“辅助数据库”）。发生故障转移之前，必须通过手动应用全部未还原的日志备份来完全更新辅助数据库。日志传送具有支持多个备用数据库的灵活性。如果需要多个备用数据库，可以单独使用日志传送或将其作为数据库镜像的补充。当这些解决方案一起使用时，当前数据库镜像配置的主体数据库同时也是当前日志传送配置的主数据库。</description>
    </item>
    
    <item>
      <title>Database</title>
      <link>https://www.openheart.icu/computing-science/database/</link>
      <pubDate>Sun, 17 Oct 2021 11:35:34 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/database/</guid>
      <description>Common ORMs  ACID Atomicity 原子性 Transactions are often composed of multiple statements. Atomicity guarantees that each transaction is treated as a single &amp;ldquo;unit&amp;rdquo;, which either succeeds completely, or fails completely: if any of the statements constituting a transaction fails to complete, the entire transaction fails and the database is left unchanged. An atomic system must guarantee atomicity in each and every situation, including power failures, errors and crashes. A guarantee of atomicity prevents updates to the database occurring only partially, which can cause greater problems than rejecting the whole series outright.</description>
    </item>
    
    <item>
      <title>Backtracking</title>
      <link>https://www.openheart.icu/arithmetic/backtracking/</link>
      <pubDate>Sun, 19 Sep 2021 17:15:26 +0000</pubDate>
      
      <guid>https://www.openheart.icu/arithmetic/backtracking/</guid>
      <description>Backtracking 17. Letter Combinations of a Phone Number
Depth-First-Search，DFS 37. Sudoku Solver</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://www.openheart.icu/arithmetic/binary-search/</link>
      <pubDate>Sun, 19 Sep 2021 17:15:26 +0000</pubDate>
      
      <guid>https://www.openheart.icu/arithmetic/binary-search/</guid>
      <description>Binary Search Algorithm </description>
    </item>
    
    <item>
      <title>Working Effectively with Legacy Code</title>
      <link>https://www.openheart.icu/computing-science/working-effectively-with-legacy-code/</link>
      <pubDate>Thu, 12 Aug 2021 15:15:57 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/working-effectively-with-legacy-code/</guid>
      <description>The Mechanics of Change Changing Software Four Reasons to Change Software  Adding a feature Fixing a bug Improving the design Optimizing resource usage  Changing Software Dependency-Breaking Techniques </description>
    </item>
    
    <item>
      <title>Design Patterns</title>
      <link>https://www.openheart.icu/computing-science/design-patterns/</link>
      <pubDate>Mon, 02 Aug 2021 15:57:23 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/design-patterns/</guid>
      <description>Overengineering keep it simple, stupid
Structural Design Patterns Creational Design Patterns Singleton Reference:
 https://csharpindepth.com/articles/Singleton https://www.cnblogs.com/leolion/p/10241822.html  Behavioral Design Patterns Observer  The observer design pattern is suitable for distributed push-based notifications, because it supports a clean separation between two different components or application layers, such as a data source (business logic) layer and a user interface (display) layer. The pattern can be implemented whenever a provider uses callbacks to supply its clients with current information.</description>
    </item>
    
    <item>
      <title>Behavior-driven development</title>
      <link>https://www.openheart.icu/computing-science/behavior-driven-development/</link>
      <pubDate>Sat, 24 Jul 2021 00:00:50 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/behavior-driven-development/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Effective CSharp</title>
      <link>https://www.openheart.icu/microsoft-dotnet/effective-csharp6.0/</link>
      <pubDate>Sat, 09 Jan 2021 16:22:42 +0000</pubDate>
      
      <guid>https://www.openheart.icu/microsoft-dotnet/effective-csharp6.0/</guid>
      <description>Effective C# Effective C# does not take you on a historical journey through the changes in the language. Rather, I provide advice on how to use the current C# language.
C # Language Idioms You change tools or languages because you can be more productive.
Item 1: Prefer Implicitly Typed Local Variables The var keyword may be used in the following contexts:
  On local variables (variables declared at method scope).</description>
    </item>
    
    <item>
      <title>Dot Net Runtime</title>
      <link>https://www.openheart.icu/microsoft-dotnet/dot-net-runtime/</link>
      <pubDate>Sat, 26 Dec 2020 11:25:57 +0000</pubDate>
      
      <guid>https://www.openheart.icu/microsoft-dotnet/dot-net-runtime/</guid>
      <description>Source Code Learning for 「Dot Net Runtime」.
 Microsoft.Extensions.DependencyInjection Branch: release/5.0
之前使用的都是.NET MVC DI，相对封装较为严重。公司的设计为Composition Root实现MVC中的ConfigureDependencies然后创建BuildServiceProvider。在对方法进行调用前通过IServiceProvider.GetService注入所需类构造函数中的依赖。
 Dependency injection addresses these problems through:
 The use of an interface or base class to abstract the dependency implementation. Registration of the dependency in a service container. .NET provides a built-in service container, IServiceProvider. Services are typically registered at the app&amp;rsquo;s start-up, and appended to an IServiceCollection. Once all services are added, you use BuildServiceProvider to create the service container.</description>
    </item>
    
    <item>
      <title>Adaptive Code</title>
      <link>https://www.openheart.icu/computing-science/adaptive-code/</link>
      <pubDate>Sat, 21 Nov 2020 22:30:12 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/adaptive-code/</guid>
      <description>Adaptive Code: Agile coding with design patterns and SOLID principles 从标题中就不难发现，Adaptive Code的重点有三个：
  敏捷编码
  设计模式
  SOLID(单一功能、开闭原则、里氏替换、接口隔离以及依赖反转)原则
  Scrum scrum.org 2020-Scrum-Guide-US
 Scrum is:
 Lightweight Simple to understand Difficult to master   What  All work is prioritized on the product backlog and, at the start of each sprint, the development team commits to the work that they will complete during the new iteration by placing it on the sprint backlog.</description>
    </item>
    
    <item>
      <title>Domain-driven design</title>
      <link>https://www.openheart.icu/computing-science/domain-driven-design/</link>
      <pubDate>Sat, 21 Nov 2020 22:30:12 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/domain-driven-design/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Test-driven development</title>
      <link>https://www.openheart.icu/computing-science/test-driven-development/</link>
      <pubDate>Sat, 21 Nov 2020 22:30:12 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/test-driven-development/</guid>
      <description>Unit Test Practice 纸上得来终觉浅，绝知此事要躬行。
Shifting Left 所谓左移，左倾，不是指冒险主义。是将整个流程中右边部分向左边移动，比如测试。 : )
 Shift Left is a practice intended to find and prevent defects early in the software delivery process. The idea is to improve quality by moving tasks to the left as early in the lifecycle as possible.
In the traditional software development model, requirements are kept on the left side of the plan, and the delivery and testing requirements on the right.</description>
    </item>
    
    <item>
      <title>Idempotent</title>
      <link>https://www.openheart.icu/computing-science/idempotent/</link>
      <pubDate>Thu, 12 Nov 2020 15:58:21 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/idempotent/</guid>
      <description>什么是幂等？ 在数学里，幂等有两种主要的定义。
 在某二元运算下，幂等元素是指被自己重复运算（或对于函数是为复合）的结果等于它自己的元素。例如，乘法下唯一两个幂等实数为0和1。 某一元运算为幂等的时，其作用在任一元素两次后会和其作用一次的结果相同。例如，高斯符号便是幂等的。 一元运算的定义是二元运算定义的特例  In computer science, the term idempotence may have a different meaning depending on the context in which it is applied:
 in imperative programming(命令编程), a subroutine(子程序) with side effects is idempotent if the system state remains the same after one or several calls, in other words if the function from the system state space to itself associated to the subroutine is idempotent in the mathematical sense given in the definition; in functional programming, a pure function is idempotent if it is idempotent in the mathematical sense given in the definition.</description>
    </item>
    
    <item>
      <title>Dependency Injection</title>
      <link>https://www.openheart.icu/computing-science/dependency-injection/</link>
      <pubDate>Thu, 15 Oct 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/dependency-injection/</guid>
      <description>Dependency Injection IOC Spring 框架为Java提供了IOC（Inversion of Control），只是提供了一个服务容器，程序控制我们需要的对象，而不是在使用对象时我们亲自直接控制。既然提到了IOC就详细了解一下这种设计思想：
为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”。
控制反转是一种是面向对象编程中的一种设计原则，用来减低计算机代码之间的耦合度。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。
软件系统在没有引入IOC容器之前，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。
软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程，由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。
控制反转可以用来减低计算机代码之间的耦合度。 其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。
DIP 要了解控制反转( Inversion of Control ), 我觉得有必要先了解软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）。
依赖倒置原则（Dependence Inversion Principle）是程序要依赖于抽象接口，不要依赖于具体实现。 简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。
在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。
该原则规定：
 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。 抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。  该原则颠倒了一部分人对于面向对象设计的认识方式。如高层次和低层次对象都应该依赖于相同的抽象接口。控制反转就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）。
设计模式中的五大原则 SOLID 中的 D 指代的就是依赖反转原则。
eg: Lamp and Button：A Simple DIP Example
DI IOC与DI的区别  控制反转是一种在软件工程中解耦合的思想，调用类只依赖接口，而不依赖具体的实现类，减少了耦合。控制权交给了容器，在运行的时候才由容器决定将具体的实现动态的“注入”到调用类的对象中。 依赖注入是一种设计模式，可以作为控制反转的一种实现方式。依赖注入就是将实例变量传入到一个对象中去(Dependency injection means giving an object its instance variables)。 通过IOC框架，类A依赖类B的强耦合关系可以在运行时通过容器建立，也就是说把创建B实例的工作移交给容器，类A只管使用就可以。  .net core 框架自带IServiceProvider以实现依赖注入</description>
    </item>
    
    <item>
      <title>Dot Net Issue</title>
      <link>https://www.openheart.icu/microsoft-dotnet/dot-net-issue/</link>
      <pubDate>Thu, 10 Sep 2020 11:00:35 +0000</pubDate>
      
      <guid>https://www.openheart.icu/microsoft-dotnet/dot-net-issue/</guid>
      <description>Hot-Reload Razor Views 在mac上使用Rider创建 .net core mvc项目后发现run和debug，都无法热加载razor页面。经过Google后发现，这并不是Rider的bug，这得需要知道mvc到底是如何运行的（it&amp;rsquo;s fundamentally how ASP.NET MVC Core works）。
 Razor files are compiled at both build and publish time using the Razor SDK. Runtime compilation may be optionally enabled by configuring your application.
 使用Razor SDK在构建和发布时都会编译Razor文件。通过配置您的应用程序，可以选择启用运行时编译。
Note that run time is not included in this list by default. To change this behaviour:
 Add the Nuget package Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation. Change your Startup.ConfigureServices code to include runtime compilation:  public void ConfigureServices(IServiceCollection services) { services .</description>
    </item>
    
    <item>
      <title>Serverless </title>
      <link>https://www.openheart.icu/computing-science/serverless/</link>
      <pubDate>Sat, 15 Aug 2020 16:27:30 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/serverless/</guid>
      <description>Implement AWS Lambda </description>
    </item>
    
    <item>
      <title>Static Search Table &amp; Dynamic Search Table</title>
      <link>https://www.openheart.icu/arithmetic/static-search-table-dynamic-search-table/</link>
      <pubDate>Sat, 25 Jul 2020 18:32:23 +0000</pubDate>
      
      <guid>https://www.openheart.icu/arithmetic/static-search-table-dynamic-search-table/</guid>
      <description>今天在看BST时，指导书上讲二叉排序树时与二分查找进行对比，引出几个模棱两可的概念（静态查找表、动态查找表），经查找后整理得本文
概述 首先要了解几个基础概念
查找(Searching) 是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。
查找表(Search Table) 是由同⼀类型的数据元素(记录)构成的集合。
关键字(Key) 是数据元素中某个数据项的值，又称为键值，用它可以表示⼀个数据元素，也可以标识一个记录的某个数据项(字段)，我们称为关键码。 若关键字可以唯⼀地标识一个记录, 则称此关键字为主关键字 (Primary Key)。 对于那些可以识别多个属于元素(记录)的关键字，我们称为次关键字(Secondary Key)。
查找表操作可分为静态查找和动态查找。
静态查找表(Static Search Table) 只作查找操作的查找表。
 查询某个”特定的”数据元素是否在查找表中; 检索某个&amp;quot;特定的&amp;quot;数据元素和各种属性;  静态查找只是仅查找，并不会去改变集合内的数据元素。常用的查找有。
顺序查找（ Linear search，又称线性查找）  原理 ：顺序查找就是按顺序从头到尾依次往下查找，从表中的第一个(或最后一个)记录开始，逐个进行记录关键字和给定值比较，找到数据，则提前结束查找，找不到便一直查找下去，直到数据最后一位
 public static int linearSearch(int[] a, int num) { for(int i = 0; i &amp;lt; a.length; i++) { if(a[i] == num){ // 返回数据所在的下标，也就是位置  return i; } } // 不存在的话返回-1  return -1; } 索引顺序表查找（分块查找） 整个表中的元素未必有序，但若划分为若干块后，每一块中的所有元素均小于（或大于）其后面块中的所有元素。我们称这种为分块有序。
分块查找要求把一个数据分为若干块，每一块里面的元素可以是无序的，但是块与块之间的元素需要是有序的。（对于一个非递减的数列来说，第i块中的每个元素一定比第i-1块中的任意元素大）
 原理：</description>
    </item>
    
    <item>
      <title>C# in Depth</title>
      <link>https://www.openheart.icu/microsoft-dotnet/csharp-in-depth/</link>
      <pubDate>Sat, 25 Jul 2020 00:14:11 +0000</pubDate>
      
      <guid>https://www.openheart.icu/microsoft-dotnet/csharp-in-depth/</guid>
      <description>本文为「C# in Depth」(4th edition)学习记录。
Part 1 C# in context Survival of the sharpest 本章主要讲C#的由来与介绍（吹嘘）。
开始前可以回顾一下C#的历史，现在是北京时间2021-05-29 14:06:54，the last C# version is C# 9.
Reference  The history of C#  Part 2 C# in 2-5 C# 3: LINQ and everything that comes with it Extension methods  Extension methods allow existing classes to be extended without relying on inheritance or having to change the class&amp;rsquo;s source code. This means that if you want to add some methods into the existing String class you can do it quite easily.</description>
    </item>
    
    <item>
      <title>Architecture</title>
      <link>https://www.openheart.icu/computing-science/architecture/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:50 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/architecture/</guid>
      <description>Evolvement Monolithic “单体”只是表明系统中主要的过程调用都是进程内调用，不会发生进程间通信，仅此而已。
Monolithic Application  Monolith means composed all in one piece. The Monolithic application describes a single-tiered software application in which different components combined into a single program from a single platform.
单体意味着自包含。单体应用描述了一种由同一技术平台的不同组件构成的单层软件。
 Layered Architecture 分层架构
 从横向扩展（Scale Horizontally）的角度来衡量，可在负载均衡器之后同时部署若干个相同的单体系统副本，以达到分摊流量压力的效果。
  Service-Oriented Architecture 面向服务的架构（SOA）是一次具体地、系统性地成功解决分布式服务主要问题的架构模式。
Information Silo Architecture  信息烟囱又名信息孤岛（Information Island），使用这种架构的系统也被称为孤岛式信息系统或者烟囱式信息系统。它指的是一种完全不与其他相关信息系统进行互操作或者协调工作的设计模式。这样的系统其实并没有什么“架构设计”可言。接着上一节中企业与部门的例子来说，如果两个部门真的完全不会发生任何交互，就并没有什么理由强迫它们必须在一栋楼里办公；两个不发生交互的信息系统，让它们使用独立的数据库和服务器即可实现拆分，而唯一的问题，也是致命的问题是，企业中真的存在完全不发生交互的部门吗？对于两个信息系统来说，哪怕真的毫无业务往来关系，但系统的人员、组织、权限等主数据，会是完全独立、没有任何重叠的吗？这样“独立拆分”“老死不相往来”的系统，显然不可能是企业所希望见到的。
 Microkernel Architecture  微内核架构也被称为插件式架构（Plug-in Architecture）。既然在烟囱式架构中，没有业务往来关系的系统也可能需要共享人员、组织、权限等一些的公共的主数据，那不妨就将这些主数据，连同其他可能被各子系统使用到的公共服务、数据、资源集中到一块，成为一个被所有业务系统共同依赖的核心（Kernel，也称为 Core System），具体的业务系统以插件模块（Plug-in Modules）的形式存在，这样也可提供可扩展的、灵活的、天然隔离的功能特性，即微内核架构。
 Event-Driven Architecture  为了能让子系统互相通信，一种可行的方案是在子系统之间建立一套事件队列管道（Event Queues），来自系统外部的消息将以事件的形式发送至管道中，各个子系统从管道里获取自己感兴趣、能够处理的事件消息，也可以为事件新增或者修改其中的附加信息，甚至可以自己发布一些新的事件到管道队列中去，如此，每一个消息的处理者都是独立的，高度解耦的，但又能与其他处理者（如果存在该消息处理者的话）通过事件管道进行互动。
  Microservices 微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。</description>
    </item>
    
    <item>
      <title>Binary relation</title>
      <link>https://www.openheart.icu/computing-science/binary-relation/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:50 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/binary-relation/</guid>
      <description>Binary relation Total order Partially ordered set </description>
    </item>
    
    <item>
      <title>Distributed</title>
      <link>https://www.openheart.icu/computing-science/distributed/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:50 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/distributed/</guid>
      <description>CAP Consistency Every read receives the most recent write or an error.
Availability Every request receives a (non-error) response, without the guarantee that it contains the most recent write.
Partition tolerance The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes.
Solution  Cloud Spanner  Reference
 CAP theorem An Illustrated Proof of the CAP Theorem 分布式系统的CAP理论  Issues Andrew File System  Distributed and global time Reference</description>
    </item>
    
    <item>
      <title>Microservice</title>
      <link>https://www.openheart.icu/computing-science/microservice/</link>
      <pubDate>Fri, 24 Jul 2020 00:00:50 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/microservice/</guid>
      <description>API Gateways  The reference microservice application eShopOnContainers is currently using features provided by Envoy to implement the API Gateway instead of the earlier referenced Ocelot. We made this design choice because of Envoy&amp;rsquo;s built-in support for the WebSocket protocol, required by the new gRPC inter-service communications implemented in eShopOnContainers. However, we&amp;rsquo;ve retained this section in the guide so you can consider Ocelot as a simple, capable, and lightweight API Gateway suitable for production-grade scenarios.</description>
    </item>
    
    <item>
      <title>.NET INTERVIEW</title>
      <link>https://www.openheart.icu/microsoft-dotnet/dot-net-interview/</link>
      <pubDate>Fri, 17 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/microsoft-dotnet/dot-net-interview/</guid>
      <description>.NET INTERVIEW from Jeffrey Zhao&amp;rsquo;s blog 我在面试.NET/C#程序员时会提出的问题
 什么是.NET？什么是CLI？什么是CLR？IL是什么？JIT是什么，它是如何工作的？GC是什么，简述一下GC的工作方式？ 什么是.net .NET是个平台，你就把它看成C#
一个.NET应用是一个运行于.NET Framework之上的应用程序。（更精确的说，一个.NET应用是一个使用.NET Framework类库来编写，并运行于公共语言运行时 Common Language Runtime之上的应用程序。）如果一个应用程序跟.NET Framework无关，它就不能叫做.NET程序。比如，仅仅使用了XML并不就是.NET应用，仅仅使用SOAP SDK调用一个Web Service也不是.NET应用
开发平台（Dot Net Framework）：包含通用语言运行时（CLR）和Dot Net框架类库（FCL）两个部分。他们提供了一致的编程模型，简化的编程方式，可靠的版本机制（用全局程序集缓存GAC来避免DLL Hell），轻便的部署管理（程序集自带的元数据可以避免ini文件和注册表） ，广泛的平台支持（只要这台机器兼容标准下的CLR和FCL就可以部署，当然运行的时候IL会变成本机代码），无缝的语言集成，自动化的内存管理（垃圾收集），类型安全（CLR会阻止利用缓冲区溢出错误进行的攻击），CLR支持跨语言调试，统一的错误报告，全新的安全策略（CAS），兼容以往的COM组件
什么是CLR CLR(公用语言运行时)和Java虚拟机一样也是一个运行时环境，它负责资源管理（内存分配和垃圾收集），并保证应用和底层操作系统之间必要的分离。.NET Framework 提供了一个称为公共语言运行时的运行时环境**（Commen Language Runtime）**，它运行代码并提供使开发过程更轻松的服务。公共语言运行时的功能通过编译器和工具公开，你可以编写利用此托管执行环境的代码。 使用基于公共语言运行时的语言编译器开发的代码称为托管代码；托管代码具有许多优点，例如：跨语言集成、跨语言异常处理、增强的安全性、版本控制和部署支持、简化的组件交互模型、调试和分析服务等。
什么是CLI 通用语言基础结构（Common Language Infrastructure，CLI）是CLR的一个子集，也就是.NET中最终对编译成MSIL代码的应用程序的运行环境进行管理的那一部分。在 CLR结构图中CLI位于下半部分，主要包括类加载器(Class Loader)、实时编译器(IL To Native Compilers)和一个运行时环境的垃圾收集器(Garbage Collector)。CLI是.Net和CLR的灵魂，CLI为IL代码提供运行的环境，你可以将使用任何语言编写的代码通过其特定的编译器转换为 MSIL代码之后运行其上，甚至还可以自己写MSIL代码在CLI上面运行。
什么是IL IL是微软.NET平台上衍生出来的一门中间语言，.NET平台上的各种高级语言（如C#，VB，F#）的编译器会将各自的文字表述方式转化为 IL。各种不同的文字形式最终被统一到了IL的表述方式，其中包含了.NET平台上的各种元素，如“范型”，“类”、、“接口”、“模块”、“属性”等 等。值得注意的是，各种高级语言本身可能根本没有这些“概念”在里头，如IronScheme是一个在.NET平台上的Scheme语言实现，其中根本没有前面提到的这些IL——亦或说是.NET平台上的名词。IL本身并不知道自己是由哪种高级语言转化而来的，哪种语言中有哪些特性，IL也根本不会关心。
什么是JIT JIT（Just In Time, JIT）是.Net边运行边编译的一种机制。
开发人员需要通过IL与CLR进行交流，虽然IL本身支持一些面向对象的概念，但是对于开发人员来讲还是过于复杂低效，于是C#应运而生，程序员只需编写C#代码，csc编译器会将其翻译成IL；虽然CLR理解IL，但是CPU只认识二进制指令，所以CLR需要JIT的帮助，将IL翻译成CPU指令. JIT按需工作，当一个.NET方法即将被执行时，JIT会介入，把该方法（IL指令）编译成CPU指令，并保存以供重用。
什么是GC，以及它的工作方式 GC:.NET Framework 的垃圾回收器管理应用程序的内存分配和释放
分配内存 初始化新进程时，运行时会为进程保留一个连续的地址空间区域。 这个保留的地址空间被称为托管堆。 托管堆维护着一个指针，用它指向将在堆中分配的下一个对象的地址。 最初，该指针设置为指向托管堆的基址。 托管堆上包含了所有引用类型。 应用程序创建第一个引用类型时，将为托管堆的基址中的类型分配内存。 应用程序创建下一个对象时，垃圾回收器在紧接第一个对象后面的地址空间内为它分配内存。 只要地址空间可用，垃圾回收器就会继续以这种方式为新对象分配空间。
从托管堆中分配内存要比非托管内存分配速度快。 由于运行时通过为指针添加值来为对象分配内存，所以这几乎和从堆栈中分配内存一样快。 另外，由于连续分配的新对象在托管堆中是连续存储，所以应用程序可以快速访问这些对象。</description>
    </item>
    
    <item>
      <title>Computer network</title>
      <link>https://www.openheart.icu/computing-science/computer-network/</link>
      <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/computer-network/</guid>
      <description>Computer Network Base on &amp;ldquo;Computer Networking - A Top Down Approach, 7th&amp;rdquo;.
Issues 网络的七层架构  物理层 数据链路层 网络层 传输层 会话层 表示层 应用层  TCP/IP 原理 TCP 三次握手/四次挥手 三次握手 TCP 在传输之前会进行三次沟通，一般称为“三次握手”。
四次挥手 TCP在传输完数据断开的时候要进行四次沟通，一般称为“四次挥手”。
Private IP Address vs Public IP Address &amp;amp; Public IP Port  0-1023是公认端口号，即已经公认定义或为将要公认定义的软件保留的，而1024-65535是并没有公共定义的端口号，用户可以自己定义这些端口的作用。
 Reference  常用端口号 为什么ipconfig和浏览器查询出的ip不一样？  How does the internet work? What is HTTP? DNS and how it works? 4 DNS servers  DNS recursor - The recursor can be thought of as a librarian who is asked to go find a particular book somewhere in a library.</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://www.openheart.icu/computing-science/git/</link>
      <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/git/</guid>
      <description>Common Operation # 遇到pull不下来 git reset --hard FETCH_HEAD git clone https://www.github.com/XXXX/XXX.git # 修改邮箱 git config --global user.name &amp;#34;Kris Nie&amp;#34; git config --global user.email krisnie@qq.com # Commit undo git reset HEAD~ #只undo最后一次 git reflog #显示所有操作 git reset d0988e7a0d # delete commit git reset --soft HEAD~1 # 保留修改 git reset --hard HEAD~1 # 不保留修改 git push origin mybranch --force # 强制推送到远端 # delete branch git branch -d mybranch git branch -D mybranch # delete force git remote prune origin # automatically get rid of remote branches that no longer exist on the remote git push origin --delete mybranch # delete remote branch git push origin :mybranch # delete remote branch # update commit after git push git commit --amend # 进入vim修改 修改完成后:wq 保存 git push --force-with-lease origin mybranch #强制修改 git fetch origin # 如果有人已经pull了未修改前的 git reset --hard origin/branch # 本地端的修改會不見 # Stash changes git stash pop git stash list # Operate Commit git rebase -i Head~3 # it will open a vim for u, i to insert, wq to save # Change repositories URL git remote -v # show yoru remote URL git remote set-url origin ssh://git@XXX.</description>
    </item>
    
    <item>
      <title>Hugo</title>
      <link>https://www.openheart.icu/computing-science/hugo/</link>
      <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/hugo/</guid>
      <description>Install tar -zxvf ./hugo_0.74.1_Linux-64bit.tar.gz cp ./hugo /usr/local/bin/ hugo new site site42 cd site42 hugo version rm -r public hugo server -b &amp;#34;https://openheart.icu:1313/&amp;#34; -p 1313 --bind &amp;#34;0.0.0.0&amp;#34; #mac 安装 brew install hugo # show the location of the hugo executable which hugo # show the installed version ls -l $( which hugo ) #lrwxr-xr-x 1 hyomin admin 30 7 17 22:46 /usr/local/bin/hugo -&amp;gt; ../Cellar/hugo/0.74.1/bin/hugo # verify that hugo runs correctly hugo version Hugo Static Site Generator v0.</description>
    </item>
    
    <item>
      <title>Markdown</title>
      <link>https://www.openheart.icu/computing-science/markdown/</link>
      <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/markdown/</guid>
      <description>support.typora.io  Expressions 公式标记 行内公式（inline） eg: $ E=mc^2 $，写法是：$E=mc^2$
整行公式（displayed） 用一对紧挨的两个美元符号$$包裹
 $$ $$
 eg: $$ \sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6} $$
 希腊字母    名称 大写 Tex 小写 Tex     alpha $A$ A α \alpha   beta $B$ B β \beat   gamma $Γ$ \Gamma γ \gamma   delta $Δ$ \Delta δ \delta   epsilon $E$ E ϵ \epsilon   zeta Z Z ζ \zeta   eta H H η \eta   theta $Θ$ \Theta θ \theta   iota I I ι \iota   kappa K K κ \kappa   lambda Λ \Lambda λ \lambda   mu M M μ \mu   nu N N ν \nu   xi $Ξ$ \Xi ξ \xi   omicron O O ο \omicron   pi Π \Pi π \pi   rho P P ρ \rho   sigma Σ \Sigma σ \sigma   tau T T τ \tau   upsilon Υ \Upsilon υ \upsilon   phi Φ \Phi ϕ \phi   chi X X χ \chi   psi $Ψ$ \Psi $ψ$ \psi   omega Ω \Omega ω \omega     角标 Markdown Language is a superset of HTML, so you can use html tag sub,sup to achieve this</description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://www.openheart.icu/computing-science/nginx/</link>
      <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/nginx/</guid>
      <description>Reverse Proxy &amp;amp; Forward Proxy Forward Proxy（正向代理） 我想访问 www.google.com ，然而大家都知道它被墙了，我没法直接访问它。于是我连接了一个 VPN 服务并设定其为本地 HTTP 访问的代理，然后我再访问 www.google.com ，此时我的请求被该 VPN 服务代理了，它帮我访问了 www.google.com 然后把结果返回给我。
正向代理隐藏真实客户端，www.google.com 并不知道访问他的是我。
Reverse Proxy（反向代理） 当我们在访问 www.baidu.com 时，百度背后有成千上万个服务器为我们服务，但具体是哪一台，我们并不知道。此时 www.baidu.com 就充当一个反向代理服务器，帮我们把请求转发到真实的服务器。
反向代理隐藏真实服务端，Nginx就是很好的反向代理服务器，用来做负载均衡。
正向代理与反向代理两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端。
Common Operation $sudo nginx sudo pkill -f nginx &amp;amp; wait $! sudo systemctl start nginx sudo systemctl restart nginx nginx -c /etc/nginx/nginx.conf # 重启服务 设置二级域名 增加一个新的listen 80
server_name设置为二级域名地址
root指向项目地址
server {listen 80;server_name site42.openheart.icu;location / {root /usr/project/openheart;}}强制浏览器使用本地缓存 cache-control/expires
# nginx.conf 中配置location ~ .</description>
    </item>
    
    <item>
      <title>Operating System</title>
      <link>https://www.openheart.icu/computing-science/operating-system/</link>
      <pubDate>Wed, 15 Jul 2020 23:28:00 +0000</pubDate>
      
      <guid>https://www.openheart.icu/computing-science/operating-system/</guid>
      <description>Basic Introduction Processes and Threads 作业与作业调度 在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。
作业（Job），作业是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据，而且还应配有一份作业说明书，系统根据该书名书来对程序的运行进行控制。在批处理系统中，是以作业为基本单位从外存调入内存的。
 A process is an isolated entity of Operating System. A task may be called a process if it is a single task. A job may be called a task if the job to be performed is a single unit of work. A process or group of processes can be termed as a task and a group of tasks can be termed as a job.</description>
    </item>
    
  </channel>
</rss>
